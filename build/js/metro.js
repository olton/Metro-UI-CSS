/*
 * Metro 4 Components Library v4.4.0  (https://metroui.org.ua)
 * Copyright 2012-2020 Sergey Pimenov
 * Built at 27/09/2020 19:46:11
 * Licensed under MIT
 */
(function (global, undefined) {

// Source: src/mode.js

/* jshint -W097 */
'use strict';

// Source: src/func.js

/* global dataSet */
/* exported isSimple, isHidden, isPlainObject, isEmptyObject, isArrayLike, str2arr, parseUnit, getUnit, setStyleProp, acceptData, dataAttr, normName, strip, dashedName */

var numProps = ['opacity', 'zIndex'];

function isSimple(v){
    return typeof v === "string" || typeof v === "boolean" || typeof v === "number";
}

function isVisible(elem) {
    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
}

function isHidden(elem) {
    var s = getComputedStyle(elem);
    return !isVisible(elem) || +s.opacity === 0 || elem.hidden || s.visibility === "hidden";
}

function not(value){
    return value === undefined || value === null;
}

function camelCase(string){
    return string.replace( /-([a-z])/g, function(all, letter){
        return letter.toUpperCase();
    });
}

function dashedName(str){
    return str.replace(/([A-Z])/g, function(u) { return "-" + u.toLowerCase(); });
}

function isPlainObject( obj ) {
    var proto;
    if ( !obj || Object.prototype.toString.call( obj ) !== "[object Object]" ) {
        return false;
    }
    proto = obj.prototype !== undefined;
    if ( !proto ) {
        return true;
    }
    return proto.constructor && typeof proto.constructor === "function";
}

function isEmptyObject( obj ) {
    for (var name in obj ) {
        if (hasProp(obj, name)) return false;
    }
    return true;
}

function isArrayLike (o){
    return o instanceof Object && 'length' in o;
}

function str2arr (str, sep) {
    sep = sep || " ";
    return str.split(sep).map(function(el){
        return  (""+el).trim();
    }).filter(function(el){
        return el !== "";
    });
}

function parseUnit(str, out) {
    if (!out) out = [ 0, '' ];
    str = String(str);
    out[0] = parseFloat(str);
    out[1] = str.match(/[\d.\-+]*\s*(.*)/)[1] || '';
    return out;
}

function getUnit(val, und){
    var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
    return typeof split[1] !== "undefined" ? split[1] : und;
}

function setStyleProp(el, key, val){
    key = camelCase(key);

    if (["scrollLeft", "scrollTop"].indexOf(key) > -1) {
        el[key] = (parseInt(val));
    } else {
        el.style[key] = isNaN(val) || numProps.indexOf(""+key) > -1 ? val : val + 'px';
    }
}

function acceptData(owner){
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
}

function getData(data){
    try {
        return JSON.parse(data);
    } catch (e) {
        return data;
    }
}

function dataAttr(elem, key, data){
    var name;

    if ( not(data) && elem.nodeType === 1 ) {
        name = "data-" + key.replace( /[A-Z]/g, "-$&" ).toLowerCase();
        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            data = getData( data );
            dataSet.set( elem, key, data );
        } else {
            data = undefined;
        }
    }
    return data;
}

function normName(name) {
    return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
}

function strip(name, what) {
    return typeof name !== "string" ? undefined : name.replace(what, "");
}

function hasProp(obj, prop){
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

// Source: src/setimmediate.js

/* global global */
/*
 * setImmediate polyfill
 * Version 1.0.5
 * Url: https://github.com/YuzuJS/setImmediate
 * Copyright (c) 2016 Yuzu (https://github.com/YuzuJS)
 * Licensed under MIT
 */
(function (global) {

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var registerImmediate;

    function setImmediate(callback) {
        if (typeof callback !== "function") {
            /* jshint -W054 */
            callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        tasksByHandle[nextHandle] = { callback: callback, args: args };
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    // global.process
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            global.process.nextTick(function () { runIfPresent(handle); });
        };
    }

    // web workers
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    // Browsers
    function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        global.addEventListener("message", onGlobalMessage, false);

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    if ({}.toString.call(global.process) === "[object process]") {

        installNextTickImplementation();

    } else if (global.MessageChannel) {

        installMessageChannelImplementation();

    } else {

        installPostMessageImplementation();

    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;

}(typeof self === "undefined" ? typeof global === "undefined" ? window : global : self));

// Source: src/promise.js

/* global setImmediate */

/*
 * Promise polyfill
 * Version 1.2.0
 * Url: https://github.com/lahmatiy/es6-promise-polyfill
 * Copyright (c) 2014 Roman Dvornov
 * Licensed under MIT
 */
(function (global) {

    if (global.Promise) {
        return;
    }

    // 

    var PENDING = 'pending';
    var SEALED = 'sealed';
    var FULFILLED = 'fulfilled';
    var REJECTED = 'rejected';
    var NOOP = function(){};

    function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    }

    // async calls
    var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
    var asyncQueue = [];
    var asyncTimer;

    function asyncFlush(){
        // run promise callbacks
        for (var i = 0; i < asyncQueue.length; i++)
            asyncQueue[i][0](asyncQueue[i][1]);

        // reset async asyncQueue
        asyncQueue = [];
        asyncTimer = false;
    }

    function asyncCall(callback, arg){
        asyncQueue.push([callback, arg]);

        if (!asyncTimer)
        {
            asyncTimer = true;
            asyncSetTimer(asyncFlush, 0);
        }
    }

    function invokeResolver(resolver, promise) {
        function resolvePromise(value) {
            resolve(promise, value);
        }

        function rejectPromise(reason) {
            reject(promise, reason);
        }

        try {
            resolver(resolvePromise, rejectPromise);
        } catch(e) {
            rejectPromise(e);
        }
    }

    function invokeCallback(subscriber){
        var owner = subscriber.owner;
        var settled = owner.state_;
        var value = owner.data_;
        var callback = subscriber[settled];
        var promise = subscriber.then;

        if (typeof callback === 'function')
        {
            settled = FULFILLED;
            try {
                value = callback(value);
            } catch(e) {
                reject(promise, e);
            }
        }

        if (!handleThenable(promise, value))
        {
            if (settled === FULFILLED)
                resolve(promise, value);

            if (settled === REJECTED)
                reject(promise, value);
        }
    }

    function handleThenable(promise, value) {
        var resolved;

        try {
            if (promise === value)
                throw new TypeError('A promises callback cannot return that same promise.');

            if (value && (typeof value === 'function' || typeof value === 'object'))
            {
                var then = value.then;  // then should be retrived only once

                if (typeof then === 'function')
                {
                    then.call(value, function(val){
                        if (!resolved)
                        {
                            resolved = true;

                            if (value !== val)
                                resolve(promise, val);
                            else
                                fulfill(promise, val);
                        }
                    }, function(reason){
                        if (!resolved)
                        {
                            resolved = true;

                            reject(promise, reason);
                        }
                    });

                    return true;
                }
            }
        } catch (e) {
            if (!resolved)
                reject(promise, e);

            return true;
        }

        return false;
    }

    function resolve(promise, value){
        if (promise === value || !handleThenable(promise, value))
            fulfill(promise, value);
    }

    function fulfill(promise, value){
        if (promise.state_ === PENDING)
        {
            promise.state_ = SEALED;
            promise.data_ = value;

            asyncCall(publishFulfillment, promise);
        }
    }

    function reject(promise, reason){
        if (promise.state_ === PENDING)
        {
            promise.state_ = SEALED;
            promise.data_ = reason;

            asyncCall(publishRejection, promise);
        }
    }

    function publish(promise) {
        var callbacks = promise.then_;
        promise.then_ = undefined;

        for (var i = 0; i < callbacks.length; i++) {
            invokeCallback(callbacks[i]);
        }
    }

    function publishFulfillment(promise){
        promise.state_ = FULFILLED;
        publish(promise);
    }

    function publishRejection(promise){
        promise.state_ = REJECTED;
        publish(promise);
    }

    /**
     * @class
     */
    function Promise(resolver){
        if (typeof resolver !== 'function')
            throw new TypeError('Promise constructor takes a function argument');

        if (!(this instanceof Promise))
            throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');

        this.then_ = [];

        invokeResolver(resolver, this);
    }

    Promise.prototype = {
        constructor: Promise,

        state_: PENDING,
        then_: null,
        data_: undefined,

        then: function(onFulfillment, onRejection){
            var subscriber = {
                owner: this,
                then: new this.constructor(NOOP),
                fulfilled: onFulfillment,
                rejected: onRejection
            };

            if (this.state_ === FULFILLED || this.state_ === REJECTED)
            {
                // already resolved, call callback async
                asyncCall(invokeCallback, subscriber);
            }
            else
            {
                // subscribe
                this.then_.push(subscriber);
            }

            return subscriber.then;
        },

        done: function(onFulfillment){
            return this.then(onFulfillment, null);
        },

        always: function(onAlways){
            return this.then(onAlways, onAlways);
        },

        'catch': function(onRejection) {
            return this.then(null, onRejection);
        }
    };

    Promise.all = function(promises){
        var Class = this;

        if (!isArray(promises))
            throw new TypeError('You must pass an array to Promise.all().');

        return new Class(function(resolve, reject){
            var results = [];
            var remaining = 0;

            function resolver(index){
                remaining++;
                return function(value){
                    results[index] = value;
                    if (!--remaining)
                        resolve(results);
                };
            }

            for (var i = 0, promise; i < promises.length; i++)
            {
                promise = promises[i];

                if (promise && typeof promise.then === 'function')
                    promise.then(resolver(i), reject);
                else
                    results[i] = promise;
            }

            if (!remaining)
                resolve(results);
        });
    };

    Promise.race = function(promises){
        var Class = this;

        if (!isArray(promises))
            throw new TypeError('You must pass an array to Promise.race().');

        return new Class(function(resolve, reject) {
            for (var i = 0, promise; i < promises.length; i++)
            {
                promise = promises[i];

                if (promise && typeof promise.then === 'function')
                    promise.then(resolve, reject);
                else
                    resolve(promise);
            }
        });
    };

    Promise.resolve = function(value){
        var Class = this;

        if (value && typeof value === 'object' && value.constructor === Class)
            return value;

        return new Class(function(resolve){
            resolve(value);
        });
    };

    Promise.reject = function(reason){
        var Class = this;

        return new Class(function(resolve, reject){
            reject(reason);
        });
    };

    if (typeof  global.Promise === "undefined") {
        global.Promise = Promise;
    }
}(window));

// Source: src/core.js

/* global hasProp */

var m4qVersion = "v1.0.8. Built at 18/09/2020 13:46:29";

/* eslint-disable-next-line */
var matches = Element.prototype.matches
    || Element.prototype.matchesSelector
    || Element.prototype.webkitMatchesSelector
    || Element.prototype.mozMatchesSelector
    || Element.prototype.msMatchesSelector
    || Element.prototype.oMatchesSelector;

var $ = function(selector, context){
    return new $.init(selector, context);
};

$.version = m4qVersion;

$.fn = $.prototype = {
    version: m4qVersion,
    constructor: $,
    length: 0,
    uid: "",

    push: [].push,
    sort: [].sort,
    splice: [].splice,
    indexOf: [].indexOf,
    reverse: [].reverse
};

$.extend = $.fn.extend = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name))
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

$.assign = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name) && options[name] !== undefined)
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

// if (typeof window["hideM4QVersion"] === "undefined") console.info("m4q " + $.version);

// Source: src/interval.js

/* global $ */

var now = function(){
    return Date.now();
};

$.extend({

    intervalId: -1,
    intervalQueue: [],
    intervalTicking: false,
    intervalTickId: null,

    setInterval: function(fn, int){
        var that = this;

        this.intervalId++;

        this.intervalQueue.push({
            id: this.intervalId,
            fn: fn,
            interval: int,
            lastTime: now()
        });

        if (!this.intervalTicking) {
            var tick = function(){
                that.intervalTickId = requestAnimationFrame(tick);
                $.each(that.intervalQueue, function(){
                    var item = this;
                    if (item.interval < 17 || now() - item.lastTime >= item.interval) {
                        item.fn();
                        item.lastTime = now();
                    }
                });
            };
            this.intervalTicking = true;
            tick();
        }

        return this.intervalId;
    },

    clearInterval: function(id){
        for(var i = 0; i < this.intervalQueue.length; i++){
            if (id === this.intervalQueue[i].id) {
                this.intervalQueue.splice(i, 1);
                break;
            }
        }
        if (this.intervalQueue.length === 0) {
            cancelAnimationFrame(this.intervalTickId);
            this.intervalTicking = false;
        }
    },

    setTimeout: function(fn, interval){
        var that = this, id = this.setInterval(function(){
            that.clearInterval(id);
            fn();
        }, interval);

        return id;
    },

    clearTimeout: function(id){
        return this.clearInterval(id);
    }
});

// Source: src/contains.js

/* global $, not, matches, isArrayLike, isVisible */

$.fn.extend({
    index: function(sel){
        var el, _index = -1;

        if (this.length === 0) {
            return _index;
        }

        if (not(sel)) {
            el = this[0];
        } else if (sel instanceof $ && sel.length > 0) {
            el = sel[0];
        } else if (typeof sel === "string") {
            el = $(sel)[0];
        } else {
            el = undefined;
        }

        if (not(el)) {
            return _index;
        }

        if (el && el.parentNode) $.each(el.parentNode.children, function(i){
            if (this === el) {
                _index = i;
            }
        });
        return _index;
    },

    get: function(i){
        if (i === undefined) {
            return this.items();
        }
        return i < 0 ? this[ i + this.length ] : this[ i ];
    },

    eq: function(i){
        return !not(i) && this.length > 0 ? $.extend($(this.get(i)), {_prevObj: this}) : this;
    },

    is: function(s){
        var result = false;

        if (this.length === 0) {
            return false;
        }

        if (s instanceof $) {
            return this.same(s);
        }

        if (s === ":selected") {
            this.each(function(){
                if (this.selected) result = true;
            });
        } else

        if (s === ":checked") {
            this.each(function(){
                if (this.checked) result = true;
            });
        } else

        if (s === ":visible") {
            this.each(function(){
                if (isVisible(this)) result = true;
            });
        } else

        if (s === ":hidden") {
            this.each(function(){
                var styles = getComputedStyle(this);
                if (
                    this.getAttribute('type') === 'hidden'
                        || this.hidden
                        || styles.display === 'none'
                        || styles.visibility === 'hidden'
                        || parseInt(styles.opacity) === 0
                ) result = true;
            });
        } else

        if (typeof  s === "string" && [':selected'].indexOf(s) === -1) {
            this.each(function(){
                if (matches.call(this, s)) {
                    result = true;
                }
            });
        } else

        if (isArrayLike(s)) {
            this.each(function(){
                var el = this;
                $.each(s, function(){
                    var sel = this;
                    if (el === sel) {
                        result = true;
                    }
                });
            });
        } else

        if (typeof s === "object" && s.nodeType === 1) {
            this.each(function(){
                if  (this === s) {
                    result = true;
                }
            });
        }

        return result;
    },

    same: function(o){
        var result = true;

        if (!(o instanceof $)) {
            o = $(o);
        }

        if (this.length !== o.length) return false;

        this.each(function(){
            if (o.items().indexOf(this) === -1) {
                result = false;
            }
        });

        return result;
    },

    last: function(){
        return this.eq(this.length - 1);
    },

    first: function(){
        return this.eq(0);
    },

    odd: function(){
        var result = this.filter(function(el, i){
            return i % 2 === 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    even: function(){
        var result = this.filter(function(el, i){
            return i % 2 !== 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    filter: function(fn){
        if (typeof fn === "string") {
            var sel = fn;
            fn = function(el){
                return matches.call(el, sel);
            };
        }

        return $.extend($.merge($(), [].filter.call(this, fn)), {_prevObj: this});
    },

    find: function(s){
        var res = [], result;

        if (s instanceof $) return s;

        if (this.length === 0) {
            result = this;
        } else {
            this.each(function () {
                var el = this;
                if (typeof el.querySelectorAll !== "undefined") res = res.concat([].slice.call(el.querySelectorAll(s)));
            });
            result = $.merge($(), res);
        }

        return $.extend(result, {_prevObj: this});
    },

    contains: function(s){
        return this.find(s).length > 0;
    },

    children: function(s){
        var i, res = [];

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            for(i = 0; i < el.children.length; i++) {
                if (el.children[i].nodeType === 1)
                    res.push(el.children[i]);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parent: function(s){
        var res = [];
        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            if (this.parentNode) {
                if (res.indexOf(this.parentNode) === -1) res.push(this.parentNode);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parents: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var par = this.parentNode;
            while (par) {
                if (par.nodeType === 1 && res.indexOf(par) === -1) {
                    if (!not(s)) {
                        if (matches.call(par, s)) {
                            res.push(par);
                        }
                    } else {
                        res.push(par);
                    }
                }
                par = par.parentNode;
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    siblings: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            if (el.parentNode) {
                $.each(el.parentNode.children, function(){
                    if (el !== this) res.push(this);
                });
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _siblingAll: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            while (el) {
                el = el[dir];
                if (!el) break;
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _sibling: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this[dir];
            if (el && el.nodeType === 1) {
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    prev: function(s){
        return this._sibling('previousElementSibling', s);
    },

    next: function(s){
        return this._sibling('nextElementSibling', s);
    },

    prevAll: function(s){
        return this._siblingAll('previousElementSibling', s);
    },

    nextAll: function(s){
        return this._siblingAll('nextElementSibling', s);
    },

    closest: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        if (!s) {
            return this.parent(s);
        }

        this.each(function(){
            var el = this;
            while (el) {
                if (!el) break;
                if (matches.call(el, s)) {
                    res.push(el);
                    return ;
                }
                el = el.parentElement;
            }
        });

        return $.extend($.merge($(), res.reverse()), {_prevObj: this});
    },

    has: function(selector){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        this.each(function(){
            var el = $(this);
            var child = el.children(selector);
            if (child.length > 0) {
                res.push(this);
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    back: function(to_start){
        var ret;
        if (to_start === true) {
            ret = this._prevObj;
            while (ret) {
                if (!ret._prevObj) break;
                ret = ret._prevObj;
            }
        } else {
            ret = this._prevObj ? this._prevObj : this;
        }
        return ret;
    }
});

// Source: src/script.js

/* global $, not */

function createScript(script){
    var s = document.createElement('script');
    s.type = 'text/javascript';

    if (not(script)) return $(s);

    var _script = $(script)[0];

    if (_script.src) {
        s.src = _script.src;
    } else {
        s.textContent = _script.innerText;
    }

    document.body.appendChild(s);

    if (_script.parentNode) _script.parentNode.removeChild(_script);

    return s;
}

$.extend({
    script: function(el){

        if (not(el)) {
            return createScript();
        }

        var _el = $(el)[0];

        if (_el.tagName && _el.tagName === "SCRIPT") {
            createScript(_el);
        } else $.each($(_el).find("script"), function(){
            createScript(this);
        });
    }
});

$.fn.extend({
    script: function(){
        return this.each(function(){
            $.script(this);
        });
    }
});

// Source: src/prop.js

/* global $, not */

$.fn.extend({
    _prop: function(prop, value){
        if (arguments.length === 1) {
            return this.length === 0 ? undefined : this[0][prop];
        }

        if (not(value)) {
            value = '';
        }

        return this.each(function(){
            var el = this;

            el[prop] = value;

            if (prop === "innerHTML") {
                $.script(el);
            }
        });
    },

    prop: function(prop, value){
        return arguments.length === 1 ? this._prop(prop) : this._prop(prop, typeof value === "undefined" ? "" : value);
    },

    val: function(value){
        if (not(value)) {
            return this.length === 0 ? undefined : this[0].value;
        }

        return this.each(function(){
            var el = $(this);
            if (typeof this.value !== "undefined") {
                this.value = value;
            } else {
                el.html(value);
            }
        });
    },

    html: function(value){
        var that = this, v = [];

        if (arguments.length === 0) {
            return this._prop('innerHTML');
        }

        if (value instanceof $) {
            value.each(function(){
                v.push($(this).outerHTML());
            });
        } else {
            v.push(value);
        }

        that._prop('innerHTML', v.length === 1 && not(v[0]) ? "" : v.join("\n"));

        return this;
    },

    outerHTML: function(){
        return this._prop('outerHTML');
    },

    text: function(value){
        return arguments.length === 0 ? this._prop('textContent') : this._prop('textContent', typeof value === "undefined" ? "" : value);
    },

    innerText: function(value){
        return arguments.length === 0 ? this._prop('innerText') : this._prop('innerText', typeof value === "undefined" ? "" : value);
    },

    empty: function(){
        return this.each(function(){
            if (typeof this.innerHTML !== "undefined") this.innerHTML = "";
        });
    },

    clear: function(){
        return this.empty();
    }
});

// Source: src/each.js

/* global $, isArrayLike, hasProp */

$.each = function(ctx, cb){
    var index = 0;
    if (isArrayLike(ctx)) {
        [].forEach.call(ctx, function(val, key) {
            cb.apply(val, [key, val]);
        });
    } else {
        for(var key in ctx) {
            if (hasProp(ctx, key))
                cb.apply(ctx[key], [key, ctx[key],  index++]);
        }
    }

    return ctx;
};

$.fn.extend({
    each: function(cb){
        return $.each(this, cb);
    }
});


// Source: src/data.js

/* global acceptData, camelCase, $, not, dataAttr, isEmptyObject, hasProp */

/*
 * Data routines
 * Url: https://jquery.com
 * Copyright (c) Copyright JS Foundation and other contributors, https://js.foundation/
 * Licensed under MIT
 */
var Data = function(ns){
    this.expando = "DATASET:UID:" + ns.toUpperCase();
    Data.uid++;
};

Data.uid = -1;

Data.prototype = {
    cache: function(owner){
        var value = owner[this.expando];
        if (!value) {
            value = {};
            if (acceptData(owner)) {
                if (owner.nodeType) {
                    owner[this.expando] = value;
                } else {
                    Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
        }
        return value;
    },

    set: function(owner, data, value){
        var prop, cache = this.cache(owner);

        if (typeof data === "string") {
            cache[camelCase(data)] = value;
        } else {
            for (prop in data) {
                if (hasProp(data, prop))
                    cache[camelCase(prop)] = data[prop];
            }
        }
        return cache;
    },

    get: function(owner, key){
        return key === undefined ? this.cache(owner) : owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
    },

    access: function(owner, key, value){
        if (key === undefined || ((key && typeof key === "string") && value === undefined) ) {
            return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== undefined ? value : key;
    },

    remove: function(owner, key){
        var i, cache = owner[this.expando];
        if (cache === undefined) {
            return ;
        }
        if (key !== undefined) {
            if ( Array.isArray( key ) ) {
                key = key.map( camelCase );
            } else {
                key = camelCase( key );

                key = key in cache ? [ key ] : ( key.match( /[^\x20\t\r\n\f]+/g ) || [] ); // ???
            }

            i = key.length;

            while ( i-- ) {
                delete cache[ key[ i ] ];
            }
        }
        if ( key === undefined || isEmptyObject( cache ) ) {
            if ( owner.nodeType ) {
                owner[ this.expando ] = undefined;
            } else {
                delete owner[ this.expando ];
            }
        }
        return true;
    },

    hasData: function(owner){
        var cache = owner[ this.expando ];
        return cache !== undefined && !isEmptyObject( cache );
    }
};

var dataSet = new Data('m4q');

$.extend({
    hasData: function(elem){
        return dataSet.hasData(elem);
    },

    data: function(elem, key, val){
        return dataSet.access(elem, key, val);
    },

    removeData: function(elem, key){
        return dataSet.remove(elem, key);
    },

    dataSet: function(ns){
        if (not(ns)) return dataSet;
        if (['INTERNAL', 'M4Q'].indexOf(ns.toUpperCase()) > -1) {
            throw Error("You can not use reserved name for your dataset");
        }
        return new Data(ns);
    }
});

$.fn.extend({
    data: function(key, val){
        var res, elem, data, attrs, name, i;

        if (this.length === 0) {
            return ;
        }

        elem = this[0];

        if ( arguments.length === 0 ) {
            if ( this.length ) {
                data = dataSet.get( elem );

                if ( elem.nodeType === 1) {
                    attrs = elem.attributes;
                    i = attrs.length;
                    while ( i-- ) {
                        if ( attrs[ i ] ) {
                            name = attrs[ i ].name;
                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = camelCase( name.slice( 5 ) );
                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                    }
                }
            }

            return data;
        }

        if ( arguments.length === 1 ) {
            res = dataSet.get(elem, key);
            if (res === undefined) {
                if ( elem.nodeType === 1) {
                    if (elem.hasAttribute("data-"+key)) {
                        res = elem.getAttribute("data-"+key);
                    }
                }
            }
            return res;
        }

        return this.each( function() {
            dataSet.set( this, key, val );
        } );
    },

    removeData: function( key ) {
        return this.each( function() {
            dataSet.remove( this, key );
        } );
    },

    origin: function(name, value, def){

        if (this.length === 0) {
            return this;
        }

        if (not(name) && not(value)) {
            return $.data(this[0]);
        }

        if (not(value)) {
            var res = $.data(this[0], "origin-"+name);
            return !not(res) ? res : def;
        }

        this.data("origin-"+name, value);

        return this;
    }
});

// Source: src/utils.js

/* global $, not, camelCase, dashedName, isPlainObject, isEmptyObject, isArrayLike, acceptData, parseUnit, getUnit, isVisible, isHidden, matches, strip, normName, hasProp */

$.extend({

    device: (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())),

    uniqueId: function (prefix) {
        var d = new Date().getTime();
        if (not(prefix)) {
            prefix = 'm4q';
        }
        return (prefix !== '' ? prefix + '-' : '') + 'xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    },

    toArray: function(n){
        var i, out = [];

        for (i = 0 ; i < n.length; i++ ) {
            out.push(n[i]);
        }

        return out;
    },

    import: function(ctx){
        var res = [];
        this.each(ctx, function(){
            res.push(this);
        });
        return this.merge($(), res);
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for ( ; j < len; j++ ) {
            first[ i++ ] = second[ j ];
        }

        first.length = i;

        return first;
    },

    type: function(obj){
        return Object.prototype.toString.call(obj).replace(/^\[object (.+)]$/, '$1').toLowerCase();
    },

    sleep: function(ms) {
        ms += new Date().getTime();
        /* eslint-disable-next-line */
        while (new Date() < ms){}
    },

    isSelector: function(selector){
        if (typeof selector !== 'string') {
            return false;
        }
        try {
            document.querySelector(selector);
        } catch(error) {
            return false;
        }
        return true;
    },

    remove: function(s){
        return $(s).remove();
    },

    camelCase: function(string){return camelCase(string);},
    dashedName: function(str){return dashedName(str);},
    isPlainObject: function(obj){return isPlainObject(obj);},
    isEmptyObject: function(obj){return isEmptyObject(obj);},
    isArrayLike: function(obj){return isArrayLike(obj);},
    acceptData: function(owner){return acceptData(owner);},
    not: function(val){return not(val);},
    parseUnit: function(str, out){return parseUnit(str, out);},
    getUnit: function(str, und){return getUnit(str, und);},
    unit: function(str, out){return parseUnit(str, out);},
    isVisible: function(elem) {return isVisible(elem);},
    isHidden: function(elem) {return isHidden(elem);},
    matches: function(el, s) {return matches.call(el, s);},
    random: function(from, to) {
        if (arguments.length === 1 && isArrayLike(from)) {
            return from[Math.floor(Math.random()*(from.length))];
        }
        return Math.floor(Math.random()*(to-from+1)+from);
    },
    strip: function(val, what){return strip(val, what);},
    normName: function(val){return normName(val);},
    hasProp: function(obj, prop){return hasProp(obj, prop);},

    serializeToArray: function(form){
        var _form = $(form)[0];
        if (!_form || _form.nodeName !== "FORM") {
            console.warn("Element is not a HTMLFromElement");
            return;
        }
        var i, j, q = [];
        for (i = _form.elements.length - 1; i >= 0; i = i - 1) {
            if (_form.elements[i].name === "") {
                continue;
            }
            switch (_form.elements[i].nodeName) {
                case 'INPUT':
                    switch (_form.elements[i].type) {
                        case 'checkbox':
                        case 'radio':
                            if (_form.elements[i].checked) {
                                q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            }
                            break;
                        case 'file':
                            break;
                        default: q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    }
                    break;
                case 'TEXTAREA':
                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    break;
                case 'SELECT':
                    switch (_form.elements[i].type) {
                        case 'select-one':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                        case 'select-multiple':
                            for (j = _form.elements[i].options.length - 1; j >= 0; j = j - 1) {
                                if (_form.elements[i].options[j].selected) {
                                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].options[j].value));
                                }
                            }
                            break;
                    }
                    break;
                case 'BUTTON':
                    switch (_form.elements[i].type) {
                        case 'reset':
                        case 'submit':
                        case 'button':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                    }
                    break;
            }
        }
        return q;
    },
    serialize: function(form){
        return $.serializeToArray(form).join("&");
    }
});

$.fn.extend({
    items: function(){
        return $.toArray(this);
    }
});

// Source: src/events.js

/* global $, not, camelCase, str2arr, normName, matches, isEmptyObject, isPlainObject */

(function () {
    if ( typeof window.CustomEvent === "function" ) return false;

    function CustomEvent ( event, params ) {
        params = params || { bubbles: false, cancelable: false, detail: null };
        var evt = document.createEvent( 'CustomEvent' );
        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
})();

var overriddenStop =  Event.prototype.stopPropagation;
var overriddenPrevent =  Event.prototype.preventDefault;

Event.prototype.stopPropagation = function(){
    this.isPropagationStopped = true;
    overriddenStop.apply(this, arguments);
};
Event.prototype.preventDefault = function(){
    this.isPreventedDefault = true;
    overriddenPrevent.apply(this, arguments);
};

Event.prototype.stop = function(immediate){
    return immediate ? this.stopImmediatePropagation() : this.stopPropagation();
};

$.extend({
    events: [],
    eventHooks: {},

    eventUID: -1,

    /*
    * el, eventName, handler, selector, ns, id, options
    * */
    setEventHandler: function(obj){
        var i, freeIndex = -1, eventObj, resultIndex;
        if (this.events.length > 0) {
            for(i = 0; i < this.events.length; i++) {
                if (this.events[i].handler === null) {
                    freeIndex = i;
                    break;
                }
            }
        }

        eventObj = {
            element: obj.el,
            event: obj.event,
            handler: obj.handler,
            selector: obj.selector,
            ns: obj.ns,
            id: obj.id,
            options: obj.options
        };

        if (freeIndex === -1) {
            this.events.push(eventObj);
            resultIndex = this.events.length - 1;
        } else {
            this.events[freeIndex] = eventObj;
            resultIndex = freeIndex;
        }

        return resultIndex;
    },

    getEventHandler: function(index){
        if (this.events[index] !== undefined && this.events[index] !== null) {
            this.events[index] = null;
            return this.events[index].handler;
        }
        return undefined;
    },

    off: function(){
        $.each(this.events, function(){
            this.element.removeEventListener(this.event, this.handler, true);
        });
        this.events = [];
        return this;
    },

    getEvents: function(){
        return this.events;
    },

    getEventHooks: function(){
        return this.eventHooks;
    },

    addEventHook: function(event, handler, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            this.eventHooks[camelCase(type+"-"+this)] = handler;
        });
        return this;
    },

    removeEventHook: function(event, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            delete this.eventHooks[camelCase(type+"-"+this)];
        });
        return this;
    },

    removeEventHooks: function(event){
        var that = this;
        if (not(event)) {
            this.eventHooks = {};
        } else {
            $.each(str2arr(event), function(){
                delete that.eventHooks[camelCase("before-"+this)];
                delete that.eventHooks[camelCase("after-"+this)];
            });
        }
        return this;
    }
});

$.fn.extend({
    on: function(eventsList, sel, handler, options){
        if (this.length === 0) {
            return ;
        }

        if (typeof sel === 'function') {
            options = handler;
            handler = sel;
            sel = undefined;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var h, ev = this,
                    event = ev.split("."),
                    name = normName(event[0]),
                    ns = options.ns ? options.ns : event[1],
                    index, originEvent;

                $.eventUID++;

                h = function(e){
                    var target = e.target;
                    var beforeHook = $.eventHooks[camelCase("before-"+name)];
                    var afterHook = $.eventHooks[camelCase("after-"+name)];

                    if (typeof beforeHook === "function") {
                        beforeHook.call(target, e);
                    }

                    if (!sel) {
                        handler.call(el, e);
                    } else {
                        while (target && target !== el) {
                            if (matches.call(target, sel)) {
                                handler.call(target, e);
                                if (e.isPropagationStopped) {
                                    e.stopImmediatePropagation();
                                    break;
                                }
                            }
                            target = target.parentNode;
                        }
                    }

                    if (typeof afterHook === "function") {
                        afterHook.call(target, e);
                    }

                    if (options.once) {
                        index = +$(el).origin( "event-"+e.type+(sel ? ":"+sel:"")+(ns ? ":"+ns:"") );
                        if (!isNaN(index)) $.events.splice(index, 1);
                    }
                };

                Object.defineProperty(h, "name", {
                    value: handler.name && handler.name !== "" ? handler.name : "func_event_"+name+"_"+$.eventUID
                });

                originEvent = name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");

                el.addEventListener(name, h, !isEmptyObject(options) ? options : false);

                index = $.setEventHandler({
                    el: el,
                    event: name,
                    handler: h,
                    selector: sel,
                    ns: ns,
                    id: $.eventUID,
                    options: !isEmptyObject(options) ? options : false
                });
                $(el).origin('event-'+originEvent, index);
            });
        });
    },

    one: function(events, sel, handler, options){
        if (!isPlainObject(options)) {
            options = {};
        }

        options.once = true;

        return this.on.apply(this, [events, sel, handler, options]);
    },

    off: function(eventsList, sel, options){

        if (isPlainObject(sel)) {
            options = sel;
            sel = null;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        if (not(eventsList) || eventsList.toLowerCase() === 'all') {
            return this.each(function(){
                var el = this;
                $.each($.events, function(){
                    var e = this;
                    if (e.element === el) {
                        el.removeEventListener(e.event, e.handler, e.options);
                        e.handler = null;
                        $(el).origin("event-"+name+(e.selector ? ":"+e.selector:"")+(e.ns ? ":"+e.ns:""), null);
                    }
                });
            });
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var evMap = this.split("."),
                    name = normName(evMap[0]),
                    ns = options.ns ? options.ns : evMap[1],
                    originEvent, index;

                originEvent = "event-"+name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");
                index = $(el).origin(originEvent);

                if (index !== undefined && $.events[index].handler) {
                    el.removeEventListener(name, $.events[index].handler, $.events[index].options);
                    $.events[index].handler = null;
                }

                $(el).origin(originEvent, null);
            });
        });
    },

    trigger: function(name, data){
        return this.fire(name, data);
    },

    fire: function(name, data){
        var _name, e;

        if (this.length === 0) {
            return ;
        }

        _name = normName(name);

        if (['focus', 'blur'].indexOf(_name) > -1) {
            this[0][_name]();
            return this;
        }

        if (typeof CustomEvent !== "undefined") {
            e = new CustomEvent(_name, {
                bubbles: true,
                cancelable: true,
                detail: data
            });
        } else {
            e = document.createEvent('Events');
            e.detail = data;
            e.initEvent(_name, true, true);
        }

        return this.each(function(){
            this.dispatchEvent(e);
        });
    }
});

( "blur focus resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu touchstart touchend touchmove touchcancel" )
    .split( " " )
    .forEach(
    function( name ) {
        $.fn[ name ] = function( sel, fn, opt ) {
            return arguments.length > 0 ?
                this.on( name, sel, fn, opt ) :
                this.fire( name );
        };
});

$.fn.extend( {
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
});

$.ready = function(fn, options){
    document.addEventListener('DOMContentLoaded', fn, (options || false));
};

$.load = function(fn){
    return $(window).on("load", fn);
};

$.unload = function(fn){
    return $(window).on("unload", fn);
};

$.fn.extend({
    unload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.unload(fn);
    }
});

$.beforeunload = function(fn){
    if (typeof fn === "string") {
        return $(window).on("beforeunload", function(e){
            e.returnValue = fn;
            return fn;
        });
    } else {
        return $(window).on("beforeunload", fn);
    }
};

$.fn.extend({
    beforeunload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.beforeunload(fn);
    }
});

$.fn.extend({
    ready: function(fn){
        if (this.length && this[0] === document && typeof fn === 'function') {
            return $.ready(fn);
        }
    }
});

// Source: src/ajax.js

/* global $, Promise, not, isSimple, isPlainObject, isEmptyObject, camelCase */

$.ajax = function(p){
    return new Promise(function(resolve, reject){
        var xhr = new XMLHttpRequest(), data;
        var method = (p.method || "GET").toUpperCase();
        var headers = [];
        var async = not(p.async) ? true : p.async;
        var url = p.url;

        var exec = function(fn, params){
            if (typeof fn === "function") {
                fn.apply(null, params);
            }
        };

        var isGet = function(method){
            return ["GET", "JSON"].indexOf(method) !== -1;
        };

        var plainObjectToData = function(obj){
            var _data = [];
            $.each(obj, function(k, v){
                var _v = isSimple(v) ? v : JSON.stringify(v);
                _data.push(k+"=" + _v);
            });
            return _data.join("&");
        };

        if (p.data instanceof HTMLFormElement) {
            var _action = p.data.getAttribute("action");
            var _method = p.data.getAttribute("method");

            if (not(url) && _action && _action.trim() !== "") {url = _action;}
            if (_method && _method.trim() !== "") {method = _method.toUpperCase();}
        }


        if (p.timeout) {
            xhr.timeout = p.timeout;
        }

        if (p.withCredentials) {
            xhr.withCredentials = p.withCredentials;
        }

        if (p.data instanceof HTMLFormElement) {
            data = $.serialize(p.data);
        } else if (p.data instanceof HTMLElement && p.data.getAttribute("type") && p.data.getAttribute("type").toLowerCase() === "file") {
            var _name = p.data.getAttribute("name");
            data = new FormData();
            for (var i = 0; i < p.data.files.length; i++) {
                data.append(_name, p.data.files[i]);
            }
        } else if (isPlainObject(p.data)) {
            data = plainObjectToData(p.data);
        } else if (p.data instanceof FormData) {
            data = p.data;
        } else if (typeof p.data === "string") {
            data = p.data;
        } else {
            data = new FormData();
            data.append("_data", JSON.stringify(p.data));
        }

        if (isGet(method)) {
            url += (typeof data === "string" ? "?"+data : isEmptyObject(data) ? "" : "?"+JSON.stringify(data));
        }

        xhr.open(method, url, async, p.user, p.password);
        if (p.headers) {
            $.each(p.headers, function(k, v){
                xhr.setRequestHeader(k, v);
                headers.push(k);
            });
        }
        if (!isGet(method)) {
            if (headers.indexOf("Content-type") === -1 && p.contentType !== false) {
                xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            }
        }
        xhr.send(data);

        xhr.addEventListener("load", function(e){
            if (xhr.readyState === 4 && xhr.status < 300) {
                var _return = p.returnValue && p.returnValue === 'xhr' ? xhr : xhr.response;
                if (p.parseJson) {
                    try {
                        _return = JSON.parse(_return);
                    } catch (ex) {
                        _return = {};
                    }
                }
                exec(resolve, [_return]);
                exec(p.onSuccess, [e, xhr]);
            } else {
                exec(reject, [xhr]);
                exec(p.onFail, [e, xhr]);
            }
            exec(p.onLoad, [e, xhr]);
        });

        $.each(["readystatechange", "error", "timeout", "progress", "loadstart", "loadend", "abort"], function(){
            var ev = camelCase("on-"+(this === 'readystatechange' ? 'state' : this));
            xhr.addEventListener(ev, function(e){
                exec(p[ev], [e, xhr]);
            });
        });
    });
};

['get', 'post', 'put', 'patch', 'delete', 'json'].forEach(function(method){
    $[method] = function(url, data, options){
        var _method = method.toUpperCase();
        var _options = {
            method: _method === 'JSON' ? 'GET' : _method,
            url: url,
            data: data,
            parseJson: _method === 'JSON'
        };
        return $.ajax($.extend({}, _options, options));
    };
});

$.fn.extend({
    load: function(url, data, options){
        var that = this;

        if (this.length && this[0].self === window ) {
            return $.load(url);
        }

        return $.get(url, data, options).then(function(data){
            that.each(function(){
                this.innerHTML = data;
            });
        });
    }
});

// Source: src/css.js

/* global $, not, setStyleProp */

$.fn.extend({

    style: function(name, pseudo){
        var el;

        function _getStyle(el, prop, pseudo){
            return ["scrollLeft", "scrollTop"].indexOf(prop) > -1 ? $(el)[prop]() : getComputedStyle(el, pseudo)[prop];
        }

        if (typeof name === 'string' && this.length === 0) {
            return undefined;
        }

        if (this.length === 0) {
            return this;
        }

        el = this[0];

        if (not(name) || name === "all") {
            return getComputedStyle(el, pseudo);
        } else {
            var result = {}, names = name.split(", ").map(function(el){
                return (""+el).trim();
            });
            if (names.length === 1)  {
                return _getStyle(el, names[0], pseudo);
            } else {
                $.each(names, function () {
                    var prop = this;
                    result[this] = _getStyle(el, prop, pseudo);
                });
                return result;
            }
        }
    },

    removeStyleProperty: function(name){
        if (not(name) || this.length === 0) return this;
        var names = name.split(", ").map(function(el){
            return (""+el).trim();
        });

        return this.each(function(){
            var el = this;
            $.each(names, function(){
                el.style.removeProperty(this);
            });
        });
    },

    css: function(key, val){
        key = key || 'all';

        if (typeof key === "string" && not(val)) {
            return  this.style(key);
        }

        return this.each(function(){
            var el = this;
            if (typeof key === "object") {
                $.each(key, function(key, val){
                    setStyleProp(el, key, val);
                });
            } else if (typeof key === "string") {
                setStyleProp(el, key, val);
            }
        });
    },

    scrollTop: function(val){
        if (not(val)) {
            
            return this.length === 0 ? undefined : this[0] === window ? pageYOffset : this[0].scrollTop;
        }
        return this.each(function(){
            this.scrollTop = val;
        });
    },

    scrollLeft: function(val){
        if (not(val)) {
            return this.length === 0 ? undefined : this[0] === window ? pageXOffset : this[0].scrollLeft;
        }
        return this.each(function(){
            this.scrollLeft = val;
        });
    }
});



// Source: src/classes.js

/* global $, not */

$.fn.extend({
    addClass: function(){},
    removeClass: function(){},
    toggleClass: function(){},

    containsClass: function(cls){
        return this.hasClass(cls);
    },

    hasClass: function(cls){
        var result = false;
        var classes = cls.split(" ").filter(function(v){
            return (""+v).trim() !== "";
        });

        if (not(cls)) {
            return false;
        }

        this.each(function(){
            var el = this;

            $.each(classes, function(){
                if (!result && el.classList && el.classList.contains(this)) {
                    result = true;
                }
            });
        });

        return result;
    },

    clearClasses: function(){
        return this.each(function(){
            this.className = "";
        });
    },

    cls: function(array){
        return this.length === 0 ? undefined : array ? this[0].className.split(" ") : this[0].className;
    },

    removeClassBy: function(mask){
        return this.each(function(){
            var el = $(this);
            var classes = el.cls(true);
            $.each(classes, function(){
                var elClass = this;
                if (elClass.indexOf(mask) > -1) {
                    el.removeClass(elClass);
                }
            });
        });
    }
});

['add', 'remove', 'toggle'].forEach(function (method) {
    $.fn[method + "Class"] = function(cls){
        if (not(cls) || (""+cls).trim() === "") return this;
        return this.each(function(){
            var el = this;
            var hasClassList = typeof el.classList !== "undefined";
            $.each(cls.split(" ").filter(function(v){
                return (""+v).trim() !== "";
            }), function(){
                if (hasClassList) el.classList[method](this);
            });
        });
    };
});


// Source: src/parser.js

/* global $ */

$.parseHTML = function(data){
    var base, singleTag, result = [], ctx, _context;
    var regexpSingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // eslint-disable-line

    if (typeof data !== "string") {
        return [];
    }

    data = data.trim();

    ctx = document.implementation.createHTMLDocument("");
    base = ctx.createElement( "base" );
    base.href = document.location.href;
    ctx.head.appendChild( base );
    _context = ctx.body;

    singleTag = regexpSingleTag.exec(data);

    if (singleTag) {
        result.push(document.createElement(singleTag[1]));
    } else {
        _context.innerHTML = data;
        for(var i = 0; i < _context.childNodes.length; i++) {
            result.push(_context.childNodes[i]);
        }
    }

    return result;
};


// Source: src/size.js

/* global $, not */

$.fn.extend({
    _size: function(prop, val){
        if (this.length === 0) return ;

        if (not(val)) {

            var el = this[0];

            if (prop === 'height') {
                return el === window ? window.innerHeight : el === document ? el.body.clientHeight : parseInt(getComputedStyle(el).height);
            }
            if (prop === 'width') {
                return el === window ? window.innerWidth : el === document ? el.body.clientWidth : parseInt(getComputedStyle(el).width);
            }
        }

        return this.each(function(){
            var el = this;
            if (el === window || el === document) {return ;}
            el.style[prop] = isNaN(val) ? val : val + 'px';
        });
    },

    height: function(val){
        return this._size('height', val);
    },

    width: function(val){
        return this._size('width', val);
    },

    _sizeOut: function(prop, val){
        var el, size, style, result;

        if (this.length === 0) {
            return ;
        }

        if (!not(val) && typeof val !== "boolean") {
            return this.each(function(){
                var el = this;
                if (el === window || el === document) {return ;}
                var h, style = getComputedStyle(el),
                    bs = prop === 'width' ? parseInt(style['border-left-width']) + parseInt(style['border-right-width']) : parseInt(style['border-top-width']) + parseInt(style['border-bottom-width']),
                    pa = prop === 'width' ? parseInt(style['padding-left']) + parseInt(style['padding-right']) : parseInt(style['padding-top']) + parseInt(style['padding-bottom']);

                h = $(this)[prop](val)[prop]() - bs - pa;
                el.style[prop] = h + 'px';
            });
        }

        el = this[0];
        size = el[prop === 'width' ? 'offsetWidth' : 'offsetHeight'];
        style = getComputedStyle(el);
        result = size + parseInt(style[prop === 'width' ? 'margin-left' : 'margin-top']) + parseInt(style[prop === 'width' ? 'margin-right' : 'margin-bottom']);
        return val === true ? result : size;
    },

    outerWidth: function(val){
        return this._sizeOut('width', val);
    },

    outerHeight: function(val){
        return this._sizeOut('height', val);
    },

    padding: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["padding-top"]),
            right: parseInt(s["padding-right"]),
            bottom: parseInt(s["padding-bottom"]),
            left: parseInt(s["padding-left"])
        };
    },

    margin: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["margin-top"]),
            right: parseInt(s["margin-right"]),
            bottom: parseInt(s["margin-bottom"]),
            left: parseInt(s["margin-left"])
        };
    },

    border: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["border-top-width"]),
            right: parseInt(s["border-right-width"]),
            bottom: parseInt(s["border-bottom-width"]),
            left: parseInt(s["border-left-width"])
        };
    }
});

// Source: src/position.js

/* global $, not */

$.fn.extend({
    offset: function(val){
        var rect;

        if (not(val)) {
            if (this.length === 0) return undefined;
            rect = this[0].getBoundingClientRect();
            return {
                top: rect.top + pageYOffset,
                left: rect.left + pageXOffset
            };
        }

        return this.each(function(){ //?
            var el = $(this),
                top = val.top,
                left = val.left,
                position = getComputedStyle(this).position,
                offset = el.offset();

            if (position === "static") {
                el.css("position", "relative");
            }

            if (["absolute", "fixed"].indexOf(position) === -1) {
                top = top - offset.top;
                left = left - offset.left;
            }

            el.css({
                top: top,
                left: left
            });
        });
    },

    position: function(margin){
        var ml = 0, mt = 0, el, style;

        if (not(margin) || typeof margin !== "boolean") {
            margin = false;
        }

        if (this.length === 0) {
            return undefined;
        }

        el = this[0];
        style = getComputedStyle(el);

        if (margin) {
            ml = parseInt(style['margin-left']);
            mt = parseInt(style['margin-top']);
        }

        return {
            left: el.offsetLeft - ml,
            top: el.offsetTop - mt
        };
    },

    left: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).left;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).left;
        }
        return this.each(function(){
            $(this).css({
                left: val
            });
        });
    },

    top: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).top;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).top;
        }
        return this.each(function(){
            $(this).css({
                top: val
            });
        });
    },

    coord: function(){
        return this.length === 0 ? undefined : this[0].getBoundingClientRect();
    },

    pos: function(){
        if (this.length === 0) return ;
        return {
            top: parseInt($(this[0]).style("top")),
            left: parseInt($(this[0]).style("left"))
        };
    }
});

// Source: src/attr.js

/* global $, not, isPlainObject */

$.fn.extend({
    attr: function(name, val){
        var attributes = {};

        if (this.length === 0 && arguments.length === 0) {
            return undefined;
        }

        if (this.length && arguments.length === 0) {
            $.each(this[0].attributes, function(){
                attributes[this.nodeName] = this.nodeValue;
            });
            return attributes;
        }

        if (typeof name === 'string' && val === undefined) {
            return this.length && this[0].nodeType === 1 && this[0].hasAttribute(name) ? this[0].getAttribute(name) : undefined;
        }

        return this.each(function(){
            var el = this;
            if (isPlainObject(name)) {
                $.each(name, function(k, v){
                    el.setAttribute(k, v);
                });
            } else {
                el.setAttribute(name, val);
                // 
            }
        });
    },

    removeAttr: function(name){
        var attributes;

        if (not(name)) {
            return this.each(function(){
                var el = this;
                $.each(this.attributes, function(){
                    el.removeAttribute(this);
                });
            });
        }

        attributes = typeof name === "string" ? name.split(",").map(function(el){
            return el.trim();
        }) : name;

        return this.each(function(){
            var el = this;
            $.each(attributes, function(){
                if (el.hasAttribute(this)) el.removeAttribute(this);
            });
        });
    },

    toggleAttr: function(name, val){
        return this.each(function(){
            var el = this;

            if (not(val)) {
                el.removeAttribute(name);
            } else {
                el.setAttribute(name, val);
            }

        });
    },

    id: function(val){
        return this.length ? $(this[0]).attr("id", val) : undefined;
    }
});

$.extend({
    meta: function(name){
        return not(name) ? $("meta") : $("meta[name='$name']".replace("$name", name));
    },

    metaBy: function(name){
        return not(name) ? $("meta") : $("meta[$name]".replace("$name", name));
    },

    doctype: function(){
        return $("doctype");
    },

    html: function(){
        return $("html");
    },

    head: function(){
        return $("html").find("head");
    },

    body: function(){
        return $("body");
    },

    document: function(){
        return $(document);
    },

    window: function(){
        return $(window);
    },

    charset: function(val){
        var meta = $("meta[charset]");
        if (val) {
            meta.attr("charset", val);
        }
        return meta.attr("charset");
    }
});

// Source: src/proxy.js

/* global $ */

$.extend({
    proxy: function(fn, ctx){
        return typeof fn !== "function" ? undefined : fn.bind(ctx);
    },

    bind: function(fn, ctx){
        return this.proxy(fn, ctx);
    }
});


// Source: src/manipulation.js

/* global $, isArrayLike, not, matches, hasProp */

(function (arr) {
    arr.forEach(function (item) {
        ['append', 'prepend'].forEach(function(where){
            if (hasProp(item, where)) {
                return;
            }
            Object.defineProperty(item, where, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: function prepend() {
                    var argArr = Array.prototype.slice.call(arguments),
                        docFrag = document.createDocumentFragment();

                    argArr.forEach(function (argItem) {
                        var isNode = argItem instanceof Node;
                        docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
                    });

                    if (where === 'prepend')
                        this.insertBefore(docFrag, this.firstChild);
                    else
                        this.appendChild(docFrag);
                }
            });
        });
    });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]);

var normalizeElements = function(s){
    var result;
    if (typeof s === "string") result = $.isSelector(s) ? $(s) : $.parseHTML(s);
    else if (s instanceof HTMLElement) result = [s];
    else if (isArrayLike(s)) result = s;
    return result;
};

$.fn.extend({
    append: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(elIndex, el){
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.append(child);
            });
        });
    },

    appendTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                parent.append(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    prepend: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function (elIndex, el) {
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.prepend(child);
            });
        });
    },

    prependTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                $(parent).prepend(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    insertBefore: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), this);
                }
            });
        });
    },

    insertAfter: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex, element){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), element.nextSibling);
                }
            });
        });
    },

    after: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('afterend', html);
            } else {
                $(html).insertAfter(el);
            }
        });
    },

    before: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('beforebegin', html);
            } else {
                $(html).insertBefore(el);
            }
        });
    },

    clone: function(deep, withData){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        if (not(withData)) {
            withData = false;
        }
        this.each(function(){
            var el = this.cloneNode(deep);
            var $el = $(el);
            var data;
            if (withData && $.hasData(this)) {
                data = $(this).data();
                $.each(data, function(k, v){
                    $el.data(k, v);
                });
            }
            res.push(el);
        });
        return $.merge($(), res);
    },

    import: function(deep){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        this.each(function(){
            res.push(document.importNode(this, deep));
        });
        return $.merge($(), res);
    },

    adopt: function(){
        var res = [];
        this.each(function(){
            res.push(document.adoptNode(this));
        });
        return $.merge($(), res);
    },

    remove: function(selector){
        var i = 0, node, out, res = [];

        if (this.length === 0) {
            return ;
        }

        out = selector ? this.filter(function(el){
            return matches.call(el, selector);
        }) : this.items();

        for ( ; ( node = out[ i ] ) != null; i++ ) {
            if (node.parentNode) {
                res.push(node.parentNode.removeChild(node));
                $.removeData(node);
            }
        }

        return $.merge($(), res);
    },

    wrap: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var _target, _wrapper;

            _wrapper = wrapper.clone(true, true);
            _wrapper.insertBefore(this);

            _target = _wrapper;
            while (_target.children().length) {
                _target = _target.children().eq(0);
            }
            _target.append(this);

            res.push(_wrapper);
        });

        return $(res);
    },

    wrapAll: function( el ){
        var wrapper, _wrapper, _target;

        if (this.length === 0) {
            return ;
        }

        wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        _wrapper = wrapper.clone(true, true);
        _wrapper.insertBefore(this[0]);

        _target = _wrapper;
        while (_target.children().length) {
            _target = _target.children().eq(0);
        }

        this.each(function(){
            _target.append(this);
        })

        return _wrapper;
    },

    wrapInner: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var elem = $(this);
            var html = elem.html();
            var wrp = wrapper.clone(true, true);
            elem.html(wrp.html(html));
            res.push(wrp);
        });

        return $(res);
    }
});

// Source: src/animation.js

/* global $, not, camelCase, parseUnit, Promise, getUnit */

$.extend({
    animation: {
        duration: 1000,
        ease: "linear",
        elements: {}
    }
});

if (typeof window["setupAnimation"] === 'object') {
    $.each(window["setupAnimation"], function(key, val){
        if (typeof $.animation[key] !== "undefined" && !not(val))
            $.animation[key] = val;
    });
}

var transformProps = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY'];
var numberProps = ['opacity', 'zIndex'];
var floatProps = ['opacity', 'volume'];
var scrollProps = ["scrollLeft", "scrollTop"];
var reverseProps = ["opacity", "volume"];

function _validElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
}

/**
 *
 * @param to
 * @param from
 * @returns {*}
 * @private
 */
function _getRelativeValue (to, from) {
    var operator = /^(\*=|\+=|-=)/.exec(to);
    if (!operator) return to;
    var u = getUnit(to) || 0;
    var x = parseFloat(from);
    var y = parseFloat(to.replace(operator[0], ''));
    switch (operator[0][0]) {
        case '+':
            return x + y + u;
        case '-':
            return x - y + u;
        case '*':
            return x * y + u;
        case '/':
            return x / y + u;
    }
}

/**
 *
 * @param el
 * @param prop
 * @param pseudo
 * @returns {*|number|string}
 * @private
 */
function _getStyle (el, prop, pseudo){
    if (typeof el[prop] !== "undefined") {
        if (scrollProps.indexOf(prop) > -1) {
            return prop === "scrollLeft" ? el === window ? pageXOffset : el.scrollLeft : el === window ? pageYOffset : el.scrollTop;
        } else {
            return el[prop] || 0;
        }
    }

    return el.style[prop] || getComputedStyle(el, pseudo)[prop];
}

/**
 *
 * @param el
 * @param key
 * @param val
 * @param unit
 * @param toInt
 * @private
 */
function _setStyle (el, key, val, unit, toInt) {

    if (not(toInt)) {
        toInt = false;
    }

    key = camelCase(key);

    if (toInt) {
        val  = parseInt(val);
    }

    if (_validElement(el)) {
        if (typeof el[key] !== "undefined") {
            el[key] = val;
        } else {
            el.style[key] = key === "transform" || key.toLowerCase().indexOf('color') > -1 ? val : val + unit;
        }
    } else {
        el[key] = val;
    }
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyStyles (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        _setStyle(el, key, val[0] + (val[2] * p), val[3], val[4]);
    });
}

/**
 *
 * @param el
 * @returns {{}}
 * @private
 */
function _getElementTransforms (el) {
    if (!_validElement(el)) return {};
    var str = el.style.transform || '';
    var reg = /(\w+)\(([^)]*)\)/g;
    var transforms = {};
    var m;

    /* jshint ignore:start */
    // eslint-disable-next-line
    while (m = reg.exec(str))
        transforms[m[1]] = m[2];
    /* jshint ignore:end */

    return transforms;
}

/**
 *
 * @param val
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromHex (val){
    var a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(val ? val : "#000000");
    return a.slice(1).map(function(v) {
            return parseInt(v, 16);
    });
}

/**
 *
 * @param el
 * @param key
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromElement (el, key) {
    return getComputedStyle(el)[key].replace(/[^\d.,]/g, '').split(',').map(function(v) {
        return parseInt(v);
    });
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyTransform (el, mapProps, p) {
    var t = [];
    var elTransforms = _getElementTransforms(el);

    $.each(mapProps, function(key, val) {
        var from = val[0], to = val[1], delta = val[2], unit = val[3];
        key = "" + key;

        if ( key.indexOf("rotate") > -1 || key.indexOf("skew") > -1) {
            if (unit === "") unit = "deg";
        }

        if (key.indexOf('scale') > -1) {
            unit = '';
        }

        if (key.indexOf('translate') > -1 && unit === '') {
            unit = 'px';
        }

        if (unit === "turn") {
            t.push(key+"(" + (to * p) + unit + ")");
        } else {
            t.push(key +"(" + (from + (delta * p)) + unit+")");
        }
    });

    $.each(elTransforms, function(key, val) {
        if (mapProps[key] === undefined) {
            t.push(key+"("+val+")");
        }
    });

    el.style.transform = t.join(" ");
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyColors (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        var i, result = [0, 0, 0], v;
        for (i = 0; i < 3; i++) {
            result[i] = Math.floor(val[0][i] + (val[2][i] * p));
        }
        v = "rgb("+(result.join(","))+")";
        el.style[key] = v;
    });
}

/**
 *
 * @param val
 * @returns {string|*}
 * @private
 */
function _expandColorValue (val) {
    var regExp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (val[0] === "#" && val.length === 4) {
        return "#" + val.replace(regExp, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }
    return val[0] === "#" ? val : "#"+val;
}

/**
 *
 * @param el
 * @param map
 * @param p
 */
function applyProps (el, map, p) {
    _applyStyles(el, map.props, p);
    _applyTransform(el, map.transform, p);
    _applyColors(el, map.color, p);
}

/**
 *
 * @param el
 * @param draw
 * @param dir
 * @returns {{transform: {}, color: {}, props: {}}}
 */
function createAnimationMap (el, draw, dir) {
    var map = {
        props: {},
        transform: {},
        color: {}
    };
    var i, from, to, delta, unit, temp;
    var elTransforms = _getElementTransforms(el);

    if (not(dir)) {
        dir = "normal";
    }

    $.each(draw, function(key, val) {

        var isTransformProp = transformProps.indexOf(""+key) > -1;
        var isNumProp = numberProps.indexOf(""+key) > -1;
        var isColorProp = (""+key).toLowerCase().indexOf("color") > -1;

        if (Array.isArray(val) && val.length === 1) {
            val = val[0];
        }

        if (!Array.isArray(val)) {
            if (isTransformProp) {
                from = elTransforms[key] || 0;
            } else if (isColorProp) {
                from = _getColorArrayFromElement(el, key);
            } else {
                from = _getStyle(el, key);
            }
            from = !isColorProp ? parseUnit(from) : from;
            to = !isColorProp ? parseUnit(_getRelativeValue(val, Array.isArray(from) ? from[0] : from)) : _getColorArrayFromHex(val);
        } else {
            from = !isColorProp ? parseUnit(val[0]) : _getColorArrayFromHex(_expandColorValue(val[0]));
            to = !isColorProp ? parseUnit(val[1]) : _getColorArrayFromHex(_expandColorValue(val[1]));
        }

        if (reverseProps.indexOf(""+key) > -1 && from[0] === to[0]) {
            from[0] = to[0] > 0 ? 0 : 1;
        }

        if (dir === "reverse") {
            temp = from;
            from = to;
            to = temp;
        }

        unit = el instanceof HTMLElement && to[1] === '' && !isNumProp && !isTransformProp ? 'px' : to[1];

        if (isColorProp) {
            delta = [0, 0, 0];
            for (i = 0; i < 3; i++) {
                delta[i] = to[i] - from[i];
            }
        } else {
            delta = to[0] - from[0];
        }

        if (isTransformProp) {
            map.transform[key] = [from[0], to[0], delta, unit];
        } else if (isColorProp) {
            map.color[key] = [from, to, delta, unit];
        } else {
            map.props[key] = [from[0], to[0], delta, unit, floatProps.indexOf(""+key) === -1];
        }
    });

    return map;
}

function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

var Easing = {
    linear: function(){return function(t) {return t;};}
};

Easing.default = Easing.linear;

var eases = {
    Sine: function(){
        return function(t){
            return 1 - Math.cos(t * Math.PI / 2);
        };
    },
    Circ: function(){
        return function(t){
            return 1 - Math.sqrt(1 - t * t);
        };
    },
    Back: function(){
        return function(t){
            return t * t * (3 * t - 2);
        };
    },
    Bounce: function(){
        return function(t){
            var pow2, b = 4;
            // eslint-disable-next-line
            while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2);
        };
    },
    Elastic: function(amplitude, period){
        if (not(amplitude)) {
            amplitude = 1;
        }

        if (not(period)) {
            period = 0.5;
        }
        var a = minMax(amplitude, 1, 10);
        var p = minMax(period, 0.1, 2);
        return function(t){
            return (t === 0 || t === 1) ? t :
                -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
        };
    }
};

['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'].forEach(function(name, i) {
    eases[name] = function(){
        return function(t){
            return Math.pow(t, i + 2);
        };
    };
});

Object.keys(eases).forEach(function(name) {
    var easeIn = eases[name];
    Easing['easeIn' + name] = easeIn;
    Easing['easeOut' + name] = function(a, b){
        return function(t){
            return 1 - easeIn(a, b)(1 - t);
        };
    };
    Easing['easeInOut' + name] = function(a, b){
        return function(t){
            return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
        };
    };
});

var defaultAnimationProps = {
    id: null,
    el: null,
    draw: {},
    dur: $.animation.duration,
    ease: $.animation.ease,
    loop: 0,
    pause: 0,
    dir: "normal",
    defer: 0,
    onFrame: function(){},
    onDone: function(){}
};

function animate(args){
    return new Promise(function(resolve){
        var that = this, start;
        var props = $.assign({}, defaultAnimationProps, {dur: $.animation.duration, ease: $.animation.ease}, args);
        var id = props.id, el = props.el, draw = props.draw, dur = props.dur, ease = props.ease, loop = props.loop, onFrame = props.onFrame, onDone = props.onDone, pause = props.pause, dir = props.dir, defer = props.defer;
        var map = {};
        var easeName = "linear", easeArgs = [], easeFn = Easing.linear, matchArgs;
        var direction = dir === "alternate" ? "normal" : dir;
        var replay = false;
        var animationID = id ? id : +(performance.now() * Math.pow(10, 14));

        if (not(el)) {
            throw new Error("Unknown element!");
        }

        if (typeof el === "string") {
            el = document.querySelector(el);
        }

        if (typeof draw !== "function" && typeof draw !== "object") {
            throw new Error("Unknown draw object. Must be a function or object!");
        }

        if (dur === 0) {
            dur = 1;
        }

        if (dir === "alternate" && typeof loop === "number") {
            loop *= 2;
        }

        if (typeof ease === "string") {
            matchArgs = /\(([^)]+)\)/.exec(ease);
            easeName = ease.split("(")[0];
            easeArgs = matchArgs ? matchArgs[1].split(',').map(function(p){return parseFloat(p);}) : [];
            easeFn = Easing[easeName] || Easing.linear;
        } else if (typeof ease === "function") {
            easeFn = ease;
        } else {
            easeFn = Easing.linear;
        }

        $.animation.elements[animationID] = {
            element: el,
            id: null,
            stop: 0,
            pause: 0,
            loop: 0
        };

        var play = function() {
            if (typeof draw === "object") {
                map = createAnimationMap(el, draw, direction);
            }
            start = performance.now();
            $.animation.elements[animationID].loop += 1;
            $.animation.elements[animationID].id = requestAnimationFrame(animate);
        };

        var done = function() {
            cancelAnimationFrame($.animation.elements[animationID].id);
            delete $.animation.elements[id];

            if (typeof onDone === "function") {
                onDone.apply(el);
            }

            resolve(that);
        };

        var animate = function(time) {
            var p, t;
            var stop = $.animation.elements[animationID].stop;

            if ( stop > 0) {
                if (stop === 2) {
                    if (typeof draw === "function") {

                        draw.bind(el)(1, 1);

                    } else {

                        applyProps(el, map, 1);

                    }
                }
                done();
                return;
            }

            t = (time - start) / dur;

            if (t > 1) t = 1;
            if (t < 0) t = 0;

            p = easeFn.apply(null, easeArgs)(t);

            if (typeof draw === "function") {

                draw.bind(el)(t, p);

            } else {

                applyProps(el, map, p);

            }

            if (typeof onFrame === 'function') {
                onFrame.apply(el, [t, p]);
            }

            if (t < 1) {
                $.animation.elements[animationID].id = requestAnimationFrame(animate);
            }

            if (parseInt(t) === 1) {
                if (loop) {
                    if (dir === "alternate") {
                        direction = direction === "normal" ? "reverse" : "normal";
                    }

                    if (typeof loop === "boolean") {
                        setTimeout(function () {
                            play();
                        }, pause);
                    } else {
                        if (loop > $.animation.elements[animationID].loop) {
                            setTimeout(function () {
                                play();
                            }, pause);
                        } else {
                            done();
                        }
                    }
                } else {
                    if (dir === "alternate" && !replay) {
                        direction = direction === "normal" ? "reverse" : "normal";
                        replay = true;
                        play();
                    } else {
                        done();
                    }
                }
            }
        };
        if (defer > 0) {
            setTimeout(function() {
                play();
            }, defer);
        } else {
            play();
        }
    });
}

/* eslint-disable */
function stop(id, done){
    if (not(done)) {
        done = true;
    }
    $.animation.elements[id].stop = done === true ? 2 : 1;
}
/* eslint-enable */

function chain(arr, loop){
    if (not(loop)) loop = false;
    if (!Array.isArray(arr)) {
        console.warn("Chain array is not defined!");
        return false;
    }

    var reducer = function(acc, item){
        return acc.then(function(){
            return animate(item);
        });
    };

    arr.reduce(reducer, Promise.resolve()).then(function(){
        if (loop) {
            if (typeof loop === "boolean") {
                chain(arr, loop);
            } else {
                loop--;
                chain(arr, loop);
            }
        }
    });
}

$.easing = {};

$.extend($.easing, Easing);

$.extend({
    animate: function(args){
        var el, draw, dur, ease, cb;

        if (arguments.length > 1) {
            el = $(arguments[0])[0];
            draw = arguments[1];
            dur = arguments[2] || $.animation.duration;
            ease = arguments[3] || $.animation.ease;
            cb = arguments[4];

            if (typeof dur === 'function') {
                cb = dur;
                ease = $.animation.ease;
                dur = $.animation.duration;
            }

            if (typeof ease === 'function') {
                cb = ease;
                ease = $.animation.ease;
            }

            return animate({
                el: el,
                draw: draw,
                dur: dur,
                ease: ease,
                onDone: cb
            });
        }

        return animate(args);
    },
    stop: stop,
    chain: chain
});

$.fn.extend({
    /**
     *

     args = {
         draw: {} | function,
         dur: 1000,
         ease: "linear",
         loop: 0,
         pause: 0,
         dir: "normal",
         defer: 0,
         onFrame: function,
         onDone: function
     }

     * @returns {this}
     */
    animate: function(args){
        var that = this;
        var draw, dur, easing, cb;
        var a = args;
        var compatibilityMode;

        compatibilityMode = !Array.isArray(args) && (arguments.length > 1 || (arguments.length === 1 && typeof arguments[0].draw === 'undefined'));

        if ( compatibilityMode ) {
            draw = arguments[0];
            dur = arguments[1] || $.animation.duration;
            easing = arguments[2] || $.animation.ease;
            cb = arguments[3];

            if (typeof dur === 'function') {
                cb = dur;
                dur = $.animation.duration;
                easing = $.animation.ease;
            }

            if (typeof easing === 'function') {
                cb = easing;
                easing = $.animation.ease;
            }

            return this.each(function(){
                return $.animate({
                    el: this,
                    draw: draw,
                    dur: dur,
                    ease: easing,
                    onDone: cb
                });
            });
        }

        if (Array.isArray(args)) {
            $.each(args, function(){
                var a = this;
                that.each(function(){
                    a.el = this;
                    $.animate(a);
                });
            });
            return this;
        }

        return this.each(function(){
            a.el = this;
            $.animate(a);
        });
    },

    chain: function(arr, loop){
        return this.each(function(){
            var el = this;
            $.each(arr, function(){
                this.el = el;
            });
            $.chain(arr, loop);
        });
    },

    /**
     *
     * @param done
     * @returns {this}
     */
    stop: function(done){
        var elements = $.animation.elements;
        return this.each(function(){
            var el = this;
            $.each(elements, function(k, o){
                if (o.element === el) {
                    stop(k, done);
                }
            });
        });
    }
});


// Source: src/visibility.js

/* global $ */

$.extend({
    hidden: function(el, val, cb){
        el = $(el)[0];

        if (typeof val === "string") {
            val = val.toLowerCase() === "true";
        }

        if (typeof val === "function") {
            cb = val;
            val = !el.hidden;
        }

        el.hidden = val;

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    hide: function(el, cb){
        var $el = $(el);

        $el.origin('display', (el.style.display ? el.style.display : getComputedStyle(el, null).display));
        el.style.display = 'none';

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    show: function(el, cb){
        var display = $(el).origin('display', undefined, "block");
        el.style.display = display ? display === 'none' ? 'block' : display : '';
        if (parseInt(el.style.opacity) === 0) {
            el.style.opacity = "1";
        }
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    visible: function(el, mode, cb){
        if (mode === undefined) {
            mode = true;
        }
        el.style.visibility = mode ? 'visible' : 'hidden';
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    toggle: function(el, cb){
        var func = getComputedStyle(el, null).display !== 'none' ? 'hide' : 'show';
        return $[func](el, cb);
    }
});

$.fn.extend({
    hide: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.hide(this, callback);
        });
    },

    show: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.show(this, callback);
        });
    },

    visible: function(mode, cb){
        return this.each(function(){
            $.visible(this, mode, cb);
        });
    },

    toggle: function(cb){
        return this.each(function(){
            $.toggle(this, cb);
        });
    },

    hidden: function(val, cb){
        return this.each(function(){
            $.hidden(this, val, cb);
        });
    }
});



// Source: src/effects.js

/* global $, not, isVisible */

$.extend({
    fx: {
        off: false
    }
});

$.fn.extend({
    fadeIn: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var visible = !(!isVisible(el) || (isVisible(el) && +($el.style('opacity')) === 0));

            if (visible) {
                return this;
            }

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }

            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            if ($.fx.off) {
                dur = 0;
            }

            var originDisplay = $el.origin("display", undefined, 'block');

            el.style.opacity = "0";
            el.style.display = originDisplay;

            return $.animate({
                el: el,
                draw: {
                    opacity: 1
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    fadeOut: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);

            if ( !isVisible(el) ) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.origin("display", $el.style('display'));

            return $.animate({
                el: el,
                draw: {
                    opacity: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    this.style.display = 'none';

                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideUp: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var currHeight;

            if ($el.height() === 0) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            currHeight = $el.height();
            $el.origin("height", currHeight);
            $el.origin("display", $(el).style('display'));

            $el.css({
                overflow: "hidden"
            });

            return $.animate({
                el: el,
                draw: {
                    height: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $el.hide().removeStyleProperty("overflow, height");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideDown: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var targetHeight, originDisplay;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.show().visible(false);
            targetHeight = +$el.origin("height", undefined, $el.height());
            if (parseInt(targetHeight) === 0) {
                targetHeight = el.scrollHeight;
            }
            originDisplay = $el.origin("display", $el.style('display'), "block");
            $el.height(0).visible(true);

            $el.css({
                overflow: "hidden",
                display: originDisplay === "none" ? "block" : originDisplay
            });

            return $.animate({
                el: el,
                draw: {
                    height: targetHeight
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $(el).removeStyleProperty("overflow, height, visibility");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    moveTo: function(x, y, dur, easing, cb){
        var draw = {
            top: y,
            left: x
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    centerTo: function(x, y, dur, easing, cb){
        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            var draw = {
                left: x - this.clientWidth / 2,
                top: y - this.clientHeight / 2
            };
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    colorTo: function(color, dur, easing, cb){
        var draw = {
            color: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    backgroundTo: function(color, dur, easing, cb){
        var draw = {
            backgroundColor: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    }
});

// Source: src/init.js

/* global $, isArrayLike, isPlainObject, hasProp, str2arr */

$.init = function(sel, ctx){
    var parsed;
    var that = this;

    if (typeof sel === "string") {
        sel = sel.trim();
    }

    this.uid = $.uniqueId();

    if (!sel) {
        return this;
    }

    if (typeof sel === "function") {
        return $.ready(sel);
    }

    if (sel instanceof Element) {
        this.push(sel);
        return this;
    }

    if (sel instanceof $) {
        $.each(sel, function(){
            that.push(this);
        });
        return this;
    }

    if (sel === "window") sel = window;
    if (sel === "document") sel = document;
    if (sel === "body") sel = document.body;
    if (sel === "html") sel = document.documentElement;
    if (sel === "doctype") sel = document.doctype;
    if (sel && (sel.nodeType || sel.self === window)) {
        this.push(sel);
        return this;
    }

    if (isArrayLike(sel)) {
        $.each(sel, function(){
            $(this).each(function(){
                that.push(this);
            });
        });
        return this;
    }

    if (typeof sel !== "string" && (sel.self && sel.self !== window)) {
        return this;
    }

    if (sel === "#" || sel === ".") {
        console.error("Selector can't be # or .") ;
        return this;
    }

    if (sel[0] === "@") {

        $("[data-role]").each(function(){
            var roles = str2arr($(this).attr("data-role"), ",");
            if (roles.indexOf(sel.slice(1)) > -1) {
                that.push(this);
            }
        });

    } else {

        parsed = $.parseHTML(sel);

        if (parsed.length === 1 && parsed[0].nodeType === 3) { // Must be a text node -> css sel
            try {
                [].push.apply(this, document.querySelectorAll(sel));
            } catch (e) {
                console.error(sel + " is not a valid selector");
            }
        } else {
            $.merge(this, parsed);
        }
    }

    if (ctx !== undefined) {
        if (ctx instanceof $) {
            this.each(function () {
                $(ctx).append(that);
            });
        } else if (ctx instanceof HTMLElement) {
            $(ctx).append(that);
        } else {
            if (isPlainObject(ctx)) {
                $.each(this,function(){
                    for(var name in ctx) {
                        if (hasProp(ctx, name))
                            this.setAttribute(name, ctx[name]);
                    }
                });
            }
        }
    }

    return this;
};

$.init.prototype = $.fn;


// Source: src/populate.js

/* global Promise, $ */

var _$ = window.$;

$.Promise = Promise;

window.m4q = $;

if (typeof window.$ === "undefined") {
    window.$ = $;
}

$.global = function(){
    _$ = window.$;
    window.$ = $;
};

$.noConflict = function() {
    if ( window.$ === $ ) {
        window.$ = _$;
    }

    return $;
};

}(window));


(function($) {
    'use strict';

    var meta_init = $.meta('metro4:init').attr("content");
    var meta_locale = $.meta('metro4:locale').attr("content");
    var meta_week_start = $.meta('metro4:week_start').attr("content");
    var meta_date_format = $.meta('metro4:date_format').attr("content");
    var meta_date_format_input = $.meta('metro4:date_format_input').attr("content");
    var meta_animation_duration = $.meta('metro4:animation_duration').attr("content");
    var meta_callback_timeout = $.meta('metro4:callback_timeout').attr("content");
    var meta_timeout = $.meta('metro4:timeout').attr("content");
    var meta_scroll_multiple = $.meta('metro4:scroll_multiple').attr("content");
    var meta_cloak = $.meta('metro4:cloak').attr("content");
    var meta_cloak_duration = $.meta('metro4:cloak_duration').attr("content");
    var meta_global_common = $.meta('metro4:global_common').attr("content");
    var meta_blur_image = $.meta('metro4:blur_image').attr("content");

    if (window.METRO_BLUR_IMAGE === undefined) {
        window.METRO_BLUR_IMAGE = meta_blur_image !== undefined ? JSON.parse(meta_global_common) : false;
    }

    if (window.METRO_GLOBAL_COMMON === undefined) {
        window.METRO_GLOBAL_COMMON = meta_global_common !== undefined ? JSON.parse(meta_global_common) : false;
    }

    var meta_jquery = $.meta('metro4:jquery').attr("content"); //undefined
    window.jquery_present = typeof jQuery !== "undefined";
    if (window.METRO_JQUERY === undefined) {
        window.METRO_JQUERY = meta_jquery !== undefined ? JSON.parse(meta_jquery) : true;
    }
    window.useJQuery = window.jquery_present && window.METRO_JQUERY;


    /* Added by Ken Kitay https://github.com/kens-code*/
    var meta_about = $.meta('metro4:about').attr("content");
    if (window.METRO_SHOW_ABOUT === undefined) {
        window.METRO_SHOW_ABOUT = meta_about !== undefined ? JSON.parse(meta_about) : true;
    }
    /* --- end ---*/

    var meta_compile = $.meta('metro4:compile').attr("content");
    if (window.METRO_SHOW_COMPILE_TIME === undefined) {
        window.METRO_SHOW_COMPILE_TIME = meta_compile !== undefined ? JSON.parse(meta_compile) : true;
    }

    if (window.METRO_INIT === undefined) {
        window.METRO_INIT = meta_init !== undefined ? JSON.parse(meta_init) : true;
    }

    if (window.METRO_DEBUG === undefined) {window.METRO_DEBUG = true;}

    if (window.METRO_WEEK_START === undefined) {
        window.METRO_WEEK_START = meta_week_start !== undefined ? parseInt(meta_week_start) : 0;
    }
    if (window.METRO_DATE_FORMAT === undefined) {
        window.METRO_DATE_FORMAT = meta_date_format !== undefined ? meta_date_format : "%Y-%m-%d";
    }
    if (window.METRO_DATE_FORMAT_INPUT === undefined) {
        window.METRO_DATE_FORMAT_INPUT = meta_date_format_input !== undefined ? meta_date_format_input : "%Y-%m-%d";
    }
    if (window.METRO_LOCALE === undefined) {
        window.METRO_LOCALE = meta_locale !== undefined ? meta_locale : 'en-US';
    }
    if (window.METRO_ANIMATION_DURATION === undefined) {
        window.METRO_ANIMATION_DURATION = meta_animation_duration !== undefined ? parseInt(meta_animation_duration) : 100;
    }
    if (window.METRO_CALLBACK_TIMEOUT === undefined) {
        window.METRO_CALLBACK_TIMEOUT = meta_callback_timeout !== undefined ? parseInt(meta_callback_timeout) : 500;
    }
    if (window.METRO_TIMEOUT === undefined) {
        window.METRO_TIMEOUT = meta_timeout !== undefined ? parseInt(meta_timeout) : 2000;
    }
    if (window.METRO_SCROLL_MULTIPLE === undefined) {
        window.METRO_SCROLL_MULTIPLE = meta_scroll_multiple !== undefined ? parseInt(meta_scroll_multiple) : 20;
    }
    if (window.METRO_CLOAK_REMOVE === undefined) {
        window.METRO_CLOAK_REMOVE = meta_cloak !== undefined ? (""+meta_cloak).toLowerCase() : "fade";
    }
    if (window.METRO_CLOAK_DURATION === undefined) {
        window.METRO_CLOAK_DURATION = meta_cloak_duration !== undefined ? parseInt(meta_cloak_duration) : 300;
    }

    if (window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE === undefined) {window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE = true;}
    if (window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS === undefined) {window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS = true;}
    if (window.METRO_HOTKEYS_FILTER_TEXT_INPUTS === undefined) {window.METRO_HOTKEYS_FILTER_TEXT_INPUTS = true;}
    if (window.METRO_HOTKEYS_BUBBLE_UP === undefined) {window.METRO_HOTKEYS_BUBBLE_UP = false;}
    if (window.METRO_THROWS === undefined) {window.METRO_THROWS = true;}

    window.METRO_MEDIA = [];

}(m4q));

/* Metro 4 Core */
(function( factory ) {
    if ( typeof define === 'function' && define.amd ) {
        define('metro4', factory );
    } else {
        factory( );
    }
}(function( ) {
    'use strict';

    var $ = m4q; // eslint-disable-line

    if (typeof m4q === 'undefined') {
        throw new Error('Metro 4 requires m4q helper!');
    }

    if (!('MutationObserver' in window)) {
        throw new Error('Metro 4 requires MutationObserver!');
    }

    var isTouch = (('ontouchstart' in window) || (navigator["MaxTouchPoints"] > 0) || (navigator["msMaxTouchPoints"] > 0));

    var normalizeComponentName = function(name){
        return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
    };

    var Metro = {

        version: "4.4.0",
        compileTime: "27/09/2020 19:46:11",
        buildNumber: "750",
        isTouchable: isTouch,
        fullScreenEnabled: document.fullscreenEnabled,
        sheet: null,

        controlsPosition: {
            INSIDE: "inside",
            OUTSIDE: "outside"
        },

        groupMode: {
            ONE: "one",
            MULTI: "multi"
        },

        aspectRatio: {
            HD: "hd",
            SD: "sd",
            CINEMA: "cinema"
        },

        fullScreenMode: {
            WINDOW: "window",
            DESKTOP: "desktop"
        },

        position: {
            TOP: "top",
            BOTTOM: "bottom",
            LEFT: "left",
            RIGHT: "right",
            TOP_RIGHT: "top-right",
            TOP_LEFT: "top-left",
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_RIGHT: "bottom-right",
            LEFT_BOTTOM: "left-bottom",
            LEFT_TOP: "left-top",
            RIGHT_TOP: "right-top",
            RIGHT_BOTTOM: "right-bottom"
        },

        popoverEvents: {
            CLICK: "click",
            HOVER: "hover",
            FOCUS: "focus"
        },

        stepperView: {
            SQUARE: "square",
            CYCLE: "cycle",
            DIAMOND: "diamond"
        },

        listView: {
            LIST: "list",
            CONTENT: "content",
            ICONS: "icons",
            ICONS_MEDIUM: "icons-medium",
            ICONS_LARGE: "icons-large",
            TILES: "tiles",
            TABLE: "table"
        },

        events: {
            click: 'click',
            start: isTouch ? 'touchstart' : 'mousedown',
            stop: isTouch ? 'touchend' : 'mouseup',
            move: isTouch ? 'touchmove' : 'mousemove',
            enter: isTouch ? 'touchstart' : 'mouseenter',

            startAll: 'mousedown touchstart',
            stopAll: 'mouseup touchend',
            moveAll: 'mousemove touchmove',

            leave: 'mouseleave',
            focus: 'focus',
            blur: 'blur',
            resize: 'resize',
            keyup: 'keyup',
            keydown: 'keydown',
            keypress: 'keypress',
            dblclick: 'dblclick',
            input: 'input',
            change: 'change',
            cut: 'cut',
            paste: 'paste',
            scroll: 'scroll',
            mousewheel: 'mousewheel',
            inputchange: "change input propertychange cut paste copy drop",
            dragstart: "dragstart",
            dragend: "dragend",
            dragenter: "dragenter",
            dragover: "dragover",
            dragleave: "dragleave",
            drop: 'drop',
            drag: 'drag'
        },

        keyCode: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            BREAK: 19,
            CAPS: 20,
            ESCAPE: 27,
            SPACE: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            END: 35,
            HOME: 36,
            LEFT_ARROW: 37,
            UP_ARROW: 38,
            RIGHT_ARROW: 39,
            DOWN_ARROW: 40,
            COMMA: 188
        },

        media_queries: {
            FS: "(min-width: 0px)",
            XS: "(min-width: 360px)",
            SM: "(min-width: 576px)",
            MD: "(min-width: 768px)",
            LG: "(min-width: 992px)",
            XL: "(min-width: 1200px)",
            XXL: "(min-width: 1452px)"
        },

        media_sizes: {
            FS: 0,
            XS: 360,
            SM: 576,
            LD: 640,
            MD: 768,
            LG: 992,
            XL: 1200,
            XXL: 1452
        },

        media_mode: {
            FS: "fs",
            XS: "xs",
            SM: "sm",
            MD: "md",
            LG: "lg",
            XL: "xl",
            XXL: "xxl"
        },

        media_modes: ["fs","xs","sm","md","lg","xl","xxl"],

        actions: {
            REMOVE: 1,
            HIDE: 2
        },

        hotkeys: {},
        locales: {},
        utils: {},
        colors: {},
        dialog: null,
        pagination: null,
        md5: null,
        storage: null,
        export: null,
        animations: null,
        cookie: null,
        template: null,

        about: function(){
            var content =
                "<h3>About</h3>" +
                "<hr>" +
                "<div><b>Metro 4</b> - v" + Metro.version +". "+ Metro.showCompileTime() + "</div>" +
                "<div><b>M4Q</b> - " + m4q.version + "</div>";
            Metro.infobox.create(content)
        },

        info: function(){
            console.info("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
            console.info("m4q - " + m4q.version);
        },

        showCompileTime: function(){
            return "Built at: " + Metro.compileTime;
        },

        aboutDlg: function(){
            alert("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
        },

        ver: function(){
            return Metro.version;
        },

        build: function(){
            return Metro.build;
        },

        compile: function(){
            return Metro.compileTime;
        },

        observe: function(){
            var observer, observerCallback;
            var observerConfig = {
                childList: true,
                attributes: true,
                subtree: true
            };
            observerCallback = function(mutations){
                mutations.map(function(mutation){
                    if (mutation.type === 'attributes' && mutation.attributeName !== "data-role") {
                        if (mutation.attributeName === 'data-hotkey') {
                            Metro.initHotkeys([mutation.target], true);
                        } else {
                            var element = $(mutation.target);
                            var mc = element.data('metroComponent');
                            var attr = mutation.attributeName, newValue = element.attr(attr), oldValue = mutation.oldValue;

                            if (mc !== undefined) {
                                element.fire("attr-change", {
                                    attr: attr,
                                    newValue: newValue,
                                    oldValue: oldValue,
                                    __this: element[0]
                                });

                                $.each(mc, function(){
                                    var plug = Metro.getPlugin(element, this);
                                    if (plug && typeof plug.changeAttribute === "function") {
                                        plug.changeAttribute(attr, newValue, oldValue);
                                    }
                                });
                            }
                        }
                    } else

                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        var i, widgets = [];
                        var $node, node, nodes = mutation.addedNodes;

                        if (nodes.length) {
                            for(i = 0; i < nodes.length; i++) {
                                node = nodes[i];
                                $node = $(node);

                                if ($node.attr("data-role") !== undefined) {
                                    widgets.push(node);
                                }

                                $.each($node.find("[data-role]"), function(){
                                    var o = this;
                                    if (widgets.indexOf(o) !== -1) {
                                        return;
                                    }
                                    widgets.push(o);
                                });
                            }

                            if (widgets.length) Metro.initWidgets(widgets, "observe");
                        }

                    } else  {
                        //
                    }
                });
            };
            observer = new MutationObserver(observerCallback);
            observer.observe($("html")[0], observerConfig);
        },

        init: function(){
            var widgets = $("[data-role]");
            var hotkeys = $("[data-hotkey]");
            var html = $("html");
            var that = this;

            if (window.METRO_BLUR_IMAGE) {
                html.addClass("use-blur-image");
            }

            if (window.METRO_SHOW_ABOUT) Metro.info(true);

            if (isTouch === true) {
                html.addClass("metro-touch-device");
            } else {
                html.addClass("metro-no-touch-device");
            }

            Metro.sheet = this.utils.newCssSheet();

            this.utils.addCssRule(Metro.sheet, "*, *::before, *::after", "box-sizing: border-box;");

            window.METRO_MEDIA = [];
            $.each(Metro.media_queries, function(key, query){
                if (that.utils.media(query)) {
                    window.METRO_MEDIA.push(Metro.media_mode[key]);
                }
            });

            Metro.observe();

            Metro.initHotkeys(hotkeys);
            Metro.initWidgets(widgets, "init");

            if (window.METRO_CLOAK_REMOVE !== "fade") {
                $(".m4-cloak").removeClass("m4-cloak");
                $(window).fire("metro-initiated");
            } else {
                $(".m4-cloak").animate({
                    draw: {
                        opacity: 1
                    },
                    dur: 300,
                    onDone: function(){
                        $(".m4-cloak").removeClass("m4-cloak");
                        $(window).fire("metro-initiated");
                    }
                });
            }
        },

        initHotkeys: function(hotkeys, redefine){
            $.each(hotkeys, function(){
                var element = $(this);
                var hotkey = element.attr('data-hotkey') ? element.attr('data-hotkey').toLowerCase() : false;
                var fn = element.attr('data-hotkey-func') ? element.attr('data-hotkey-func') : false;

                if (hotkey === false) {
                    return;
                }

                if (element.data('hotKeyBonded') === true && redefine !== true) {
                    return;
                }

                Metro.hotkeys[hotkey] = [this, fn];
                element.data('hotKeyBonded', true);
                element.fire("hot-key-bonded", {
                    __this: element[0],
                    hotkey: hotkey,
                    fn: fn
                });
            });
        },

        initWidgets: function(widgets) {
            var that = this;

            $.each(widgets, function () {
                var $this = $(this), roles;

                if (!this.hasAttribute("data-role")) {
                    return ;
                }

                roles = $this.attr('data-role').split(/\s*,\s*/);

                roles.map(function (func) {

                    var $$ = that.utils.$();
                    var _func = normalizeComponentName(func);

                    if ($$.fn[_func] !== undefined && $this.attr("data-role-"+_func) === undefined) {
                        try {
                            $$.fn[_func].call($this);
                            $this.attr("data-role-"+_func, true);

                            var mc = $this.data('metroComponent');

                            if (mc === undefined) {
                                mc = [_func];
                            } else {
                                mc.push(_func);
                            }
                            $this.data('metroComponent', mc);

                            $this.fire("create", {
                                __this: $this[0],
                                name: _func
                            });
                            $(document).fire("component-create", {
                                element: $this[0],
                                name: _func
                            });
                        } catch (e) {
                            console.error("Error creating component " + func + " for ", $this[0]);
                            throw e;
                        }
                    }
                });
            });
        },

        plugin: function(name, object){
            var _name = normalizeComponentName(name);

            var register = function($){
                $.fn[_name] = function( options ) {
                    return this.each(function() {
                        $.data( this, _name, Object.create(object).init(options, this ));
                    });
                };
            }

            register(m4q);

            if (window.useJQuery) {
                register(jQuery);
            }
        },

        destroyPlugin: function(element, name){
            var p, mc;
            var el = $(element);
            var _name = normalizeComponentName(name);

            p = Metro.getPlugin(el, _name);

            if (typeof p === 'undefined') {
                console.warn("Component "+name+" can not be destroyed: the element is not a Metro 4 component.");
                return ;
            }

            if (typeof p['destroy'] !== 'function') {
                console.warn("Component "+name+" can not be destroyed: method destroy not found.");
                return ;
            }

            p['destroy']();
            mc = el.data("metroComponent");
            this.utils.arrayDelete(mc, _name);
            el.data("metroComponent", mc);
            $.removeData(el[0], _name);
            el.removeAttr("data-role-"+_name);
        },

        destroyPluginAll: function(element){
            var el = $(element);
            var mc = el.data("metroComponent");

            if (mc !== undefined && mc.length > 0) $.each(mc, function(){
                Metro.destroyPlugin(el[0], this);
            });
        },

        noop: function(){},
        noop_true: function(){return true;},
        noop_false: function(){return false;},

        requestFullScreen: function(element){
            if (element["mozRequestFullScreen"]) {
                element["mozRequestFullScreen"]();
            } else if (element["webkitRequestFullScreen"]) {
                element["webkitRequestFullScreen"]();
            } else if (element["msRequestFullscreen"]) {
                element["msRequestFullscreen"]();
            } else {
                element.requestFullscreen().catch( function(err){
                    console.warn("Error attempting to enable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        exitFullScreen: function(){
            if (document["mozCancelFullScreen"]) {
                document["mozCancelFullScreen"]();
            }
            else if (document["webkitCancelFullScreen"]) {
                document["webkitCancelFullScreen"]();
            }
            else if (document["msExitFullscreen"]) {
                document["msExitFullscreen"]();
            } else {
                document.exitFullscreen().catch( function(err){
                    console.warn("Error attempting to disable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        inFullScreen: function(){
            var fsm = (document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"]);
            return fsm !== undefined;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        get$el: function(el){
            return Metro.$()($(el)[0]);
        },

        getPlugin: function(el, name){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$el(el);
            return $el.length ? $el.data(_name) : undefined;
        },

        makePlugin: function(el, name, options){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$el(el);
            return $el.length && typeof $el[_name] === "function" ? $el[_name](options) : undefined;
        },

        Component: function(nameName, compObj){
            var name = normalizeComponentName(nameName);
            var Utils = Metro.utils;
            var component = $.extend({name: name}, {
                _super: function(el, options, defaults, setup){
                    var self = this;

                    this.elem = el;
                    this.element = $(el);
                    this.options = $.extend( {}, defaults, options );
                    this.component = this.elem;

                    this._setOptionsFromDOM();
                    this._runtime();

                    if (setup && typeof setup === 'object') {
                        $.each(setup, function(key, val){
                            self[key] = val;
                        })
                    }

                    this._createExec();
                },

                _setOptionsFromDOM: function(){
                    var element = this.element, o = this.options;

                    $.each(element.data(), function(key, value){
                        if (key in o) {
                            try {
                                o[key] = JSON.parse(value);
                            } catch (e) {
                                o[key] = value;
                            }
                        }
                    });
                },

                _runtime: function(){
                    var element = this.element, mc;
                    var roles = (element.attr("data-role") || "").toArray(",").map(function(v){
                        return normalizeComponentName(v);
                    });

                    if (!element.attr('data-role-'+this.name)) {
                        element.attr("data-role-"+this.name, true);
                        if (roles.indexOf(this.name) === -1) {
                            roles.push(this.name);
                            element.attr("data-role", roles.join(","));
                        }

                        mc = element.data('metroComponent');
                        if (mc === undefined) {
                            mc = [this.name];
                        } else {
                            mc.push(this.name);
                        }
                        element.data('metroComponent', mc);
                    }
                },

                _createExec: function(){
                    var that = this, timeout = this.options[this.name+'Deferred'];

                    if (timeout) {
                        setTimeout(function(){
                            that._create();
                        }, timeout)
                    } else {
                        that._create();
                    }
                },

                _fireEvent: function(eventName, data, log, noFire){
                    var element = this.element, o = this.options;
                    var _data;
                    var event = eventName.camelCase().capitalize();

                    data = $.extend({}, data, {__this: element[0]});

                    _data = data ? Object.values(data) : {};

                    if (log) {
                        console.warn(log);
                        console.warn("Event: " + "on"+eventName.camelCase().capitalize());
                        console.warn("Data: ", data);
                        console.warn("Element: ", element[0]);
                    }

                    if (noFire !== true)
                        element.fire(event.toLowerCase(), data);

                    return Utils.exec(o["on"+event], _data, element[0]);
                },

                getComponent: function(){
                    return this.component;
                },

                getComponentName: function(){
                    return this.name;
                }
            }, compObj);

            Metro.plugin(name, component);

            return component;
        }
    };

    $(window).on(Metro.events.resize, function(){
        window.METRO_MEDIA = [];
        $.each(Metro.media_queries, function(key, query){
            if (Metro.utils.media(query)) {
                window.METRO_MEDIA.push(Metro.media_mode[key]);
            }
        });
    });

    window.Metro = Metro;

    if (window.METRO_INIT ===  true) {
        $(function(){
            Metro.init()
        });
    }

    return Metro;

}));


(function(Metro, $) {
    $.extend(Metro.locales, {
        'cn-ZH': {
            "calendar": {
                "months": [
                    "", "", "", "", "", "", "", "", "", "", "", "",
                    "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
                ],
                "days": [
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", ""
                ],
                "time": {
                    "days": "",
                    "hours": "",
                    "minutes": "",
                    "seconds": "",
                    "month": "",
                    "day": "",
                    "year": ""
                }
            },
            "buttons": {
                "ok": "",
                "cancel": "",
                "done": "",
                "today": "",
                "now": "",
                "clear": "",
                "help": "",
                "yes": "",
                "no": "",
                "random": "",
                "save": "",
                "reset": ""
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro['locales'], {
        'da-DK': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
                ],
                "days": [
                    "Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag",
                    "S", "Ma", "Ti", "On", "To", "Fr", "L",
                    "Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"
                ],
                "time": {
                    "days": "DAGE",
                    "hours": "TIMER",
                    "minutes": "MIN",
                    "seconds": "SEK",
                    "month": "MON",
                    "day": "DAG",
                    "year": "R"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annuller",
                "done": "Frdig",
                "today": "Idag",
                "now": "Nu",
                "clear": "Ryd",
                "help": "Hjlp",
                "yes": "Ja",
                "no": "Nej",
                "random": "Tilfldig",
                "save": "Gem",
                "reset": "Nulstil"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'de-DE': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember",
                    "Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"
                ],
                "days": [
                    "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag",
                    "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa",
                    "Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam"
                ],
                "time": {
                    "days": "TAGE",
                    "hours": "STD",
                    "minutes": "MIN",
                    "seconds": "SEK"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Abbrechen",
                "done": "Fertig",
                "today": "Heute",
                "now": "Jetzt",
                "clear": "Lschen",
                "help": "Hilfe",
                "yes": "Ja",
                "no": "Nein",
                "random": "Zufllig",
                "save": "Speichern",
                "reset": "Zurcksetzen"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'en-US': {
            "calendar": {
                "months": [
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                ],
                "days": [
                    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday",
                    "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa",
                    "Sun", "Mon", "Tus", "Wen", "Thu", "Fri", "Sat"
                ],
                "time": {
                    "days": "DAYS",
                    "hours": "HOURS",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MON",
                    "day": "DAY",
                    "year": "YEAR"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancel",
                "done": "Done",
                "today": "Today",
                "now": "Now",
                "clear": "Clear",
                "help": "Help",
                "yes": "Yes",
                "no": "No",
                "random": "Random",
                "save": "Save",
                "reset": "Reset"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'es-MX': {
            "calendar": {
                "months": [
                    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre",
                    "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
                ],
                "days": [
                    "Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado",
                    "Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa",
                    "Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"
                ],
                "time": {
                    "days": "DAS",
                    "hours": "HORAS",
                    "minutes": "MINS",
                    "seconds": "SEGS",
                    "month": "MES",
                    "day": "DA",
                    "year": "AO"
                }
            },
            "buttons": {
                "ok": "Aceptar",
                "cancel": "Cancelar",
                "done": "Hecho",
                "today": "Hoy",
                "now": "Ahora",
                "clear": "Limpiar",
                "help": "Ayuda",
                "yes": "Si",
                "no": "No",
                "random": "Aleatorio",
                "save": "Salvar",
                "reset": "Reiniciar"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'fr-FR': {
            "calendar": {
                "months": [
                    "Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre",
                    "Janv", "Fvr", "Mars", "Avr", "Mai", "Juin", "Juil", "Aot", "Sept", "Oct", "Nov", "Dc"
                ],
                "days": [
                    "Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi",
                    "Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa",
                    "Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
                ],
                "time": {
                    "days": "JOURS",
                    "hours": "HEURES",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MOIS",
                    "day": "JOUR",
                    "year": "ANNEE"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annul",
                "done": "Fait",
                "today": "Aujourd'hui",
                "now": "Maintenant",
                "clear": "Effac",
                "help": "Aide",
                "yes": "Oui",
                "no": "Non",
                "random": "Alatoire",
                "save": "Sauvegarder",
                "reset": "Rinitialiser"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'hu-HU': {
            "calendar": {
                "months": [
                    'Janur', 'Februr', 'Mrcius', 'prilis', 'Mjus', 'Jnius', 'Jlius', 'Augusztus', 'Szeptember', 'Oktber', 'November', 'December',
                    'Jan', 'Feb', 'Mr', 'pr', 'Mj', 'Jn', 'Jl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'
                ],
                "days": [
                    'Vasrnap', 'Htf', 'Kedd', 'Szerda', 'Cstrtk', 'Pntek', 'Szombat',
                    'V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz',
                    'Vas', 'Ht', 'Ke', 'Sze', 'Cs', 'Pn', 'Szom'
                ],
                "time": {
                    "days": "NAP",
                    "hours": "RA",
                    "minutes": "PERC",
                    "seconds": "MP"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Mgse",
                "done": "Ksz",
                "today": "Ma",
                "now": "Most",
                "clear": "Trls",
                "help": "Segtsg",
                "yes": "Igen",
                "no": "Nem",
                "random": "Vletlen",
                "save": "Ments",
                "reset": "Visszallts"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'it-IT': {
            "calendar": {
                "months": [
                    "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre",
                    "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"
                ],
                "days": [
                    "Domenica", "Luned", "Marted", "Mercoled", "Gioved", "Venerd", "Sabato",
                    "Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa",
                    "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
                ],
                "time": {
                    "days": "GIORNI",
                    "hours": "ORE",
                    "minutes": "MIN",
                    "seconds": "SEC",
                    "month": "MESE",
                    "day": "GIORNO",
                    "year": "ANNO"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annulla",
                "done": "Fatto",
                "today": "Oggi",
                "now": "Adesso",
                "clear": "Cancella",
                "help": "Aiuto",
                "yes": "S",
                "no": "No",
                "random": "Random",
                "save": "Salvare",
                "reset": "Reset"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'pt-BR': {
            "calendar": {
                "months": [
                    "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro",
                    "Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"
                ],
                "days": [
                    "Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado",
                    "Do", "Se", "Te", "Qa", "Qi", "Se", "Sa",
                    "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
                ],
                "time": {
                    "days": "DIAS",
                    "hours": "HORAS",
                    "minutes": "MINUTOS",
                    "seconds": "SEGUNDOS",
                    "month": "MS",
                    "day": "DIA",
                    "year": "ANO"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancelar",
                "done": "Feito",
                "today": "Hoje",
                "now": "Agora",
                "clear": "Limpar",
                "help": "Ajuda",
                "yes": "Sim",
                "no": "No",
                "random": "Aleatrio",
                "save": "Salvar",
                "reset": "Restaurar"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'ru-RU': {
            "calendar": {
                "months": [
                    "", "", "", "", "", "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "", "", "", "", "", ""
                ],
                "days": [
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", ""
                ],
                "time": {
                    "days": "",
                    "hours": "",
                    "minutes": "",
                    "seconds": ""
                }
            },
            "buttons": {
                "ok": "",
                "cancel": "",
                "done": "",
                "today": "",
                "now": "",
                "clear": "",
                "help": "",
                "yes": "",
                "no": "",
                "random": "",
                "save": "",
                "reset": ""
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'tw-ZH': {
            "calendar": {
                "months": [
                    "", "", "", "", "", "", "", "", "", "", "", "",
                    "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
                ],
                "days": [
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", ""
                ],
                "time": {
                    "days": "",
                    "hours": "",
                    "minutes": "",
                    "seconds": "",
                    "month": "",
                    "day": "",
                    "year": ""
                }
            },
            "buttons": {
                "ok": "",
                "cancel": "",
                "done": "",
                "today": "",
                "now": "",
                "clear": "",
                "help": "",
                "yes": "",
                "no": "",
                "random": "",
                "save": "",
                "reset": ""
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'uk-UA': {
            "calendar": {
                "months": [
                    "", "", "", "", "", "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "", "", "", "", "", ""
                ],
                "days": [
                    "", "", "", "", "", "", "",
                    "", "", "", "", "", "", "",
                    "", "", "i", "", "", "", ""
                ],
                "time": {
                    "days": "",
                    "hours": "",
                    "minutes": "",
                    "seconds": ""
                }
            },
            "buttons": {
                "ok": "",
                "cancel": "",
                "done": "",
                "today": "",
                "now": "",
                "clear": "",
                "help": "",
                "yes": "",
                "no": "",
                "random": "",
                "save": "",
                "reset": ""
            }
        }
    });
}(Metro, m4q));

(function() {
    'use strict';

    if (typeof Array.shuffle !== "function") {
        Array.prototype.shuffle = function () {
            var currentIndex = this.length, temporaryValue, randomIndex;

            while (0 !== currentIndex) {

                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                temporaryValue = this[currentIndex];
                this[currentIndex] = this[randomIndex];
                this[randomIndex] = temporaryValue;
            }

            return this;
        };
    }

    if (typeof Array.clone !== "function") {
        Array.prototype.clone = function () {
            return this.slice(0);
        };
    }

    if (typeof Array.unique !== "function") {
        Array.prototype.unique = function () {
            var a = this.concat();
            for (var i = 0; i < a.length; ++i) {
                for (var j = i + 1; j < a.length; ++j) {
                    if (a[i] === a[j])
                        a.splice(j--, 1);
                }
            }

            return a;
        };
    }

    if (typeof Array.from !== "function") {
        Array.prototype.from = function(val) {
            var i, a = [];

            if (val.length === undefined && typeof val === "object") {
                return Object.values(val);
            }

            if (val.length !== undefined) {
                for(i = 0; i < val.length; i++) {
                    a.push(val[i]);
                }
                return a;
            }

            throw new Error("Value can not be converted to array");
        };
    }

    if (typeof Array.contains !== "function") {
        Array.prototype.contains = function(val, from){
            return this.indexOf(val, from) > -1;
        }
    }

    if (typeof Array.includes !== "function") {
        Array.prototype.includes = function(val, from){
            return this.indexOf(val, from) > -1;
        }
    }
}());

(function(Metro) {
    'use strict';
    Date.prototype.getWeek = function (dowOffset) {
        var nYear, nday, newYear, day, daynum, weeknum;

        dowOffset = !Utils.isValue(dowOffset) ? METRO_WEEK_START : typeof dowOffset === 'number' ? parseInt(dowOffset) : 0;
        newYear = new Date(this.getFullYear(),0,1);
        day = newYear.getDay() - dowOffset;
        day = (day >= 0 ? day : day + 7);
        daynum = Math.floor((this.getTime() - newYear.getTime() -
            (this.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/86400000) + 1;

        if(day < 4) {
            weeknum = Math.floor((daynum+day-1)/7) + 1;
            if(weeknum > 52) {
                nYear = new Date(this.getFullYear() + 1,0,1);
                nday = nYear.getDay() - dowOffset;
                nday = nday >= 0 ? nday : nday + 7;
                weeknum = nday < 4 ? 1 : 53;
            }
        }
        else {
            weeknum = Math.floor((daynum+day-1)/7);
        }
        return weeknum;
    };

    Date.prototype.getYear = function(){
        return this.getFullYear().toString().substr(-2);
    };

    Date.prototype.format = function(format, locale){

        if (locale === undefined) {
            locale = "en-US";
        }

        var cal = (Metro.locales !== undefined && Metro.locales[locale] !== undefined ? Metro.locales[locale] : Metro.locales["en-US"])['calendar'];

        var date = this;
        var nDay = date.getDay(),
            nDate = date.getDate(),
            nMonth = date.getMonth(),
            nYear = date.getFullYear(),
            nHour = date.getHours(),
            aDays = cal['days'],
            aMonths = cal['months'],
            aDayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
            isLeapYear = function() {
                return (nYear%4===0 && nYear%100!==0) || nYear%400===0;
            },
            getThursday = function() {
                var target = new Date(date);
                target.setDate(nDate - ((nDay+6)%7) + 3);
                return target;
            },
            zeroPad = function(nNum, nPad) {
                return ('' + (Math.pow(10, nPad) + nNum)).slice(1);
            };
        return format.replace(/(%[a-z])/gi, function(sMatch) {
            return {
                '%a': aDays[nDay].slice(0,3),
                '%A': aDays[nDay],
                '%b': aMonths[nMonth].slice(0,3),
                '%B': aMonths[nMonth],
                '%c': date.toUTCString(),
                '%C': Math.floor(nYear/100),
                '%d': zeroPad(nDate, 2),
                'dd': zeroPad(nDate, 2),
                '%e': nDate,
                '%F': date.toISOString().slice(0,10),
                '%G': getThursday().getFullYear(),
                '%g': ('' + getThursday().getFullYear()).slice(2),
                '%H': zeroPad(nHour, 2),
                // 'HH': zeroPad(nHour, 2),
                '%I': zeroPad((nHour+11)%12 + 1, 2),
                '%j': zeroPad(aDayCount[nMonth] + nDate + ((nMonth>1 && isLeapYear()) ? 1 : 0), 3),
                '%k': '' + nHour,
                '%l': (nHour+11)%12 + 1,
                '%m': zeroPad(nMonth + 1, 2),
                // 'mm': zeroPad(nMonth + 1, 2),
                '%M': zeroPad(date.getMinutes(), 2),
                // 'MM': zeroPad(date.getMinutes(), 2),
                '%p': (nHour<12) ? 'AM' : 'PM',
                '%P': (nHour<12) ? 'am' : 'pm',
                '%s': Math.round(date.getTime()/1000),
                // 'ss': Math.round(date.getTime()/1000),
                '%S': zeroPad(date.getSeconds(), 2),
                // 'SS': zeroPad(date.getSeconds(), 2),
                '%u': nDay || 7,
                '%V': (function() {
                    var target = getThursday(),
                        n1stThu = target.valueOf();
                    target.setMonth(0, 1);
                    var nJan1 = target.getDay();
                    if (nJan1!==4) target.setMonth(0, 1 + ((4-nJan1)+7)%7);
                    return zeroPad(1 + Math.ceil((n1stThu-target)/604800000), 2);
                })(),
                '%w': '' + nDay,
                '%x': date.toLocaleDateString(),
                '%X': date.toLocaleTimeString(),
                '%y': ('' + nYear).slice(2),
                // 'yy': ('' + nYear).slice(2),
                '%Y': nYear,
                // 'YYYY': nYear,
                '%z': date.toTimeString().replace(/.+GMT([+-]\d+).+/, '$1'),
                '%Z': date.toTimeString().replace(/.+\((.+?)\)$/, '$1')
            }[sMatch] || sMatch;
        });
    };

    Date.prototype.addHours = function(n) {
        this.setTime(this.getTime() + (n*60*60*1000));
        return this;
    };

    Date.prototype.addDays = function(n) {
        this.setDate(this.getDate() + (n));
        return this;
    };

    Date.prototype.addMonths = function(n) {
        this.setMonth(this.getMonth() + (n));
        return this;
    };

    Date.prototype.addYears = function(n) {
        this.setFullYear(this.getFullYear() + (n));
        return this;
    };
}(Metro));

(function() {
    'use strict';

    /**
     * Number.prototype.format(n, x, s, c)
     *
     * @param  n: length of decimal
     * @param  x: length of whole part
     * @param  s: sections delimiter
     * @param  c: decimal delimiter
     */
    Number.prototype.format = function(n, x, s, c) {
        var re = '\\d(?=(\\d{' + (x || 3) + '})+' + (n > 0 ? '\\D' : '$') + ')',
            num = this.toFixed(Math.max(0, ~~n));

        return (c ? num.replace('.', c) : num).replace(new RegExp(re, 'g'), '$&' + (s || ','));
    };
}());

(function() {
    'use strict';

    if ( typeof Object.create !== 'function' ) {
        Object.create = function (o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
    }

    if (typeof Object.values !== 'function') {
        Object.values = function(obj) {
            return Object.keys(obj).map(function(e) {
                return obj[e]
            });
        }
    }
}());

(function(Metro, $) {
    'use strict';

    String.prototype.camelCase = function(){
        return $.camelCase(this);
    };

    String.prototype.dashedName = function(){
        return $.dashedName(this);
    };

    String.prototype.shuffle = function(){
        var _shuffle = function (a) {
            var currentIndex = a.length, temporaryValue, randomIndex;

            while (0 !== currentIndex) {

                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                temporaryValue = a[currentIndex];
                a[currentIndex] = a[randomIndex];
                a[randomIndex] = temporaryValue;
            }

            return a;
        };

        return _shuffle(this.split("")).join("");
    }

    String.prototype.capitalize = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };

    String.prototype.contains = function() {
        return !!~String.prototype.indexOf.apply(this, arguments);
    };

    if (typeof String.includes !== "function") {
        String.prototype.includes = function(){
            return !!~String.prototype.indexOf.apply(this, arguments);
        }
    }

    String.prototype.toDate = function(format, locale) {
        var result;
        var normalized, normalizedFormat, formatItems, dateItems, checkValue;
        var monthIndex, dayIndex, yearIndex, hourIndex, minutesIndex, secondsIndex;
        var year, month, day, hour, minute, second;
        var parsedMonth;

        locale = locale || "en-US";

        var monthNameToNumber = function(month){
            var d, months, index, i;
            var Locales = Metro.locales;

            if (typeof month === "undefined" || month === null) {
                return -1;
            }

            month = month.substr(0, 3);

            if (
                locale !== undefined
                && locale !== "en-US"
                && Locales !== undefined
                && Locales[locale] !== undefined
                && Locales[locale]['calendar'] !== undefined
                && Locales[locale]['calendar']['months'] !== undefined
            ) {
                months = Locales[locale]['calendar']['months'];
                for(i = 12; i < months.length; i++) {
                    if (months[i].toLowerCase() === month.toLowerCase()) {
                        index = i - 12;
                        break;
                    }
                }
                month = Locales["en-US"]['calendar']['months'][index];
            }

            d = Date.parse(month + " 1, 1972");
            if(!isNaN(d)){
                return new Date(d).getMonth() + 1;
            }
            return -1;
        };

        if (format === undefined || format === null || format === "") {
            return new Date(this);
        }

        /* eslint-disable-next-line */
        normalized      = this.replace(/[\/,.:\s]/g, '-');
        /* eslint-disable-next-line */
        normalizedFormat= format.toLowerCase().replace(/[^a-zA-Z0-9%]/g, '-');
        formatItems     = normalizedFormat.split('-');
        dateItems       = normalized.split('-');
        checkValue      = normalized.replace(/-/g,"");

        if (checkValue.trim() === "") {
            return "Invalid Date";
        }

        monthIndex  = formatItems.indexOf("mm") > -1 ? formatItems.indexOf("mm") : formatItems.indexOf("%m");
        dayIndex    = formatItems.indexOf("dd") > -1 ? formatItems.indexOf("dd") : formatItems.indexOf("%d");
        yearIndex   = formatItems.indexOf("yyyy") > -1 ? formatItems.indexOf("yyyy") : formatItems.indexOf("yy") > -1 ? formatItems.indexOf("yy") : formatItems.indexOf("%y");
        hourIndex     = formatItems.indexOf("hh") > -1 ? formatItems.indexOf("hh") : formatItems.indexOf("%h");
        minutesIndex  = formatItems.indexOf("ii") > -1 ? formatItems.indexOf("ii") : formatItems.indexOf("mi") > -1 ? formatItems.indexOf("mi") : formatItems.indexOf("%i");
        secondsIndex  = formatItems.indexOf("ss") > -1 ? formatItems.indexOf("ss") : formatItems.indexOf("%s");

        if (monthIndex > -1 && dateItems[monthIndex] !== "") {
            if (isNaN(parseInt(dateItems[monthIndex]))) {
                dateItems[monthIndex] = monthNameToNumber(dateItems[monthIndex]);
                if (dateItems[monthIndex] === -1) {
                    return "Invalid Date";
                }
            } else {
                parsedMonth = parseInt(dateItems[monthIndex]);
                if (parsedMonth < 1 || parsedMonth > 12) {
                    return "Invalid Date";
                }
            }
        } else {
            return "Invalid Date";
        }

        year  = yearIndex >-1 && dateItems[yearIndex] !== "" ? dateItems[yearIndex] : null;
        month = monthIndex >-1 && dateItems[monthIndex] !== "" ? dateItems[monthIndex] : null;
        day   = dayIndex >-1 && dateItems[dayIndex] !== "" ? dateItems[dayIndex] : null;

        hour    = hourIndex >-1 && dateItems[hourIndex] !== "" ? dateItems[hourIndex] : null;
        minute  = minutesIndex>-1 && dateItems[minutesIndex] !== "" ? dateItems[minutesIndex] : null;
        second  = secondsIndex>-1 && dateItems[secondsIndex] !== "" ? dateItems[secondsIndex] : null;

        result = new Date(year,month-1,day,hour,minute,second);

        return result;
    };

    String.prototype.toArray = function(delimiter, type, format){
        var str = this;
        var a;

        type = type || "string";
        delimiter = delimiter || ",";
        format = format === undefined || format === null ? false : format;

        a = (""+str).split(delimiter);

        return a.map(function(s){
            var result;

            switch (type) {
                case "int":
                case "integer": result = isNaN(s) ? s.trim() : parseInt(s); break;
                case "number":
                case "float": result = isNaN(s) ? s : parseFloat(s); break;
                case "date": result = !format ? new Date(s) : s.toDate(format); break;
                default: result = s.trim();
            }

            return result;
        });
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    Metro.utils = {
        isVisible: function(element){
            var el = $(element)[0];
            return this.getStyleOne(el, "display") !== "none"
                && this.getStyleOne(el, "visibility") !== "hidden"
                && el.offsetParent !== null;
        },

        isUrl: function (val) {
            /* eslint-disable-next-line */
            return /^(\.\/|\.\.\/|ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@\-\/]))?/.test(val);
        },

        isTag: function(val){
            /* eslint-disable-next-line */
            return /^<\/?[\w\s="/.':;#-\/\?]+>/gi.test(val);
        },

        isColor: function (val) {
            /* eslint-disable-next-line */
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
        },

        isEmbedObject: function(val){
            var embed = ["iframe", "object", "embed", "video"];
            var result = false;
            $.each(embed, function(){
                if (typeof val === "string" && val.toLowerCase() === this) {
                    result = true;
                } else if (val.nodeType !== undefined && val.tagName.toLowerCase() === this) {
                    result = true;
                }
            });
            return result;
        },

        isVideoUrl: function(val){
            return /youtu\.be|youtube|vimeo/gi.test(val);
        },

        isDate: function(val, format){
            var result;

            if (this.isDateObject(val)) {
                return true;
            }

            if (this.isValue(format)) {
                result = String(val).toDate(format);
            } else {
                result = String(new Date(val));
            }

            return result !== "Invalid Date";
        },

        isDateObject: function(v){
            return typeof v === 'object' && v.getMonth !== undefined;
        },

        isInt: function(n){
            return !isNaN(n) && +n % 1 === 0;
        },

        isFloat: function(n){
            return (!isNaN(n) && +n % 1 !== 0) || /^\d*\.\d+$/.test(n);
        },

        isTouchDevice: function() {
            return (('ontouchstart' in window)
                || (navigator.MaxTouchPoints > 0)
                || (navigator.msMaxTouchPoints > 0));
        },

        isFunc: function(f){
            return this.isType(f, 'function');
        },

        isObject: function(o){
            return this.isType(o, 'object');
        },

        isArray: function(a){
            return Array.isArray(a);
        },

        isType: function(o, t){
            if (!this.isValue(o)) {
                return false;
            }

            if (typeof o === t) {
                return o;
            }

            if ((""+t).toLowerCase() === 'tag' && this.isTag(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'url' && this.isUrl(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'array' && this.isArray(o)) {
                return o;
            }

            if (this.isTag(o) || this.isUrl(o)) {
                return false;
            }

            if (typeof window[o] === t) {
                return window[o];
            }

            if (typeof o === 'string' && o.indexOf(".") === -1) {
                return false;
            }

            if (typeof o === 'string' && /[/\s([]+/gm.test(o)) {
                return false;
            }

            if (typeof o === "number" && t.toLowerCase() !== "number") {
                return false;
            }

            var ns = o.split(".");
            var i, context = window;

            for(i = 0; i < ns.length; i++) {
                context = context[ns[i]];
            }

            return typeof context === t ? context : false;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        isMetroObject: function(el, type){
            var $el = $(el), el_obj = Metro.getPlugin(el, type);

            if ($el.length === 0) {
                console.warn(type + ' ' + el + ' not found!');
                return false;
            }

            if (el_obj === undefined) {
                console.warn('Element not contain role '+ type +'! Please add attribute data-role="'+type+'" to element ' + el);
                return false;
            }

            return true;
        },

        isJQuery: function(el){
            return (typeof jQuery !== "undefined" && el instanceof jQuery);
        },

        isM4Q: function(el){
            return (typeof m4q !== "undefined" && el instanceof m4q);
        },

        isQ: function(el){
            return this.isJQuery(el) || this.isM4Q(el);
        },

        isIE11: function(){
            return !!window.MSInputMethodContext && !!document["documentMode"];
        },

        embedObject: function(val){
            return "<div class='embed-container'>" + $(val)[0].outerHTML + "</div>";
        },

        embedUrl: function(val){
            if (val.indexOf("youtu.be") !== -1) {
                val = "https://www.youtube.com/embed/" + val.split("/").pop();
            }
            return "<div class='embed-container'><iframe src='"+val+"'></iframe></div>";
        },

        secondsToTime: function(secs) {
            var hours = Math.floor(secs / (60 * 60));

            var divisor_for_minutes = secs % (60 * 60);
            var minutes = Math.floor(divisor_for_minutes / 60);

            var divisor_for_seconds = divisor_for_minutes % 60;
            var seconds = Math.ceil(divisor_for_seconds);

            return {
                "h": hours,
                "m": minutes,
                "s": seconds
            };
        },

        hex2rgba: function(hex, alpha){
            var c;
            alpha = isNaN(alpha) ? 1 : alpha;
            if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length=== 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
            }
            throw new Error('Hex2rgba error. Bad Hex value');
        },

        elementId: function(prefix){
            return prefix+"-"+(new Date()).getTime()+$.random(1, 1000);
        },

        secondsToFormattedString: function(time){
            var sec_num = parseInt(time, 10);
            var hours   = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            if (hours   < 10) {hours   = "0"+hours;}
            if (minutes < 10) {minutes = "0"+minutes;}
            if (seconds < 10) {seconds = "0"+seconds;}

            return [hours, minutes, seconds].join(":");
        },

        func: function(f){
            /* jshint -W054 */
            return new Function("a", f);
        },

        exec: function(f, args, context){
            var result;
            if (f === undefined || f === null) {return false;}
            var func = this.isFunc(f);

            if (func === false) {
                func = this.func(f);
            }

            try {
                result = func.apply(context, args);
            } catch (err) {
                result = null;
                if (METRO_THROWS === true) {
                    throw err;
                }
            }
            return result;
        },

        isOutsider: function(element) {
            var el = $(element);
            var inViewport;
            var clone = el.clone();

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            el.parent().append(clone);

            inViewport = this.inViewport(clone[0]);

            clone.remove();

            return !inViewport;
        },

        inViewport: function(el){
            var rect = this.rect(el);

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        },

        rect: function(el){
            return el.getBoundingClientRect();
        },

        getCursorPosition: function(el, e){
            var a = this.rect(el);
            return {
                x: this.pageXY(e).x - a.left - window.pageXOffset,
                y: this.pageXY(e).y - a.top - window.pageYOffset
            };
        },

        getCursorPositionX: function(el, e){
            return this.getCursorPosition(el, e).x;
        },

        getCursorPositionY: function(el, e){
            return this.getCursorPosition(el, e).y;
        },

        objectLength: function(obj){
            return Object.keys(obj).length;
        },

        percent: function(total, part, round_value){
            if (total === 0) {
                return 0;
            }
            var result = part * 100 / total;
            return round_value === true ? Math.round(result) : Math.round(result * 100) / 100;
        },

        objectShift: function(obj){
            var min = 0;
            $.each(obj, function(i){
                if (min === 0) {
                    min = i;
                } else {
                    if (min > i) {
                        min = i;
                    }
                }
            });
            delete obj[min];

            return obj;
        },

        objectDelete: function(obj, key){
            if (obj[key] !== undefined) delete obj[key];
        },

        arrayDeleteByMultipleKeys: function(arr, keys){
            keys.forEach(function(ind){
                delete arr[ind];
            });
            return arr.filter(function(item){
                return item !== undefined;
            });
        },

        arrayDelete: function(arr, val){
            if (arr.indexOf(val) > -1) arr.splice(arr.indexOf(val), 1);
        },

        arrayDeleteByKey: function(arr, key){
            arr.splice(key, 1);
        },

        nvl: function(data, other){
            return data === undefined || data === null ? other : data;
        },

        objectClone: function(obj){
            var copy = {};
            for(var key in obj) {
                if ($.hasProp(obj, key)) {
                    copy[key] = obj[key];
                }
            }
            return copy;
        },

        github: function(repo, callback){
            var that = this;
            $.json('https://api.github.com/repos/' + repo).then(function(data){
                that.exec(callback, [data]);
            });
        },

        detectIE: function() {
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },

        detectChrome: function(){
            return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        },

        encodeURI: function(str){
            return encodeURI(str).replace(/%5B/g, '[').replace(/%5D/g, ']');
        },

        pageHeight: function(){
            var body = document.body,
                html = document.documentElement;

            return Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
        },

        cleanPreCode: function(selector){
            var els = Array.prototype.slice.call(document.querySelectorAll(selector), 0);

            els.forEach(function(el){
                var txt = el.textContent
                    .replace(/^[\r\n]+/, "")	// strip leading newline
                    .replace(/\s+$/g, "");

                if (/^\S/gm.test(txt)) {
                    el.textContent = txt;
                    return;
                }

                var mat, str, re = /^[\t ]+/gm, len, min = 1e3;

                /* jshint -W084 */
                /* eslint-disable-next-line */
                while (mat = re.exec(txt)) {
                    len = mat[0].length;

                    if (len < min) {
                        min = len;
                        str = mat[0];
                    }
                }

                if (min === 1e3)
                    return;

                el.textContent = txt.replace(new RegExp("^" + str, 'gm'), "").trim();
            });
        },

        coords: function(element){
            var el = $(element)[0];
            var box = el.getBoundingClientRect();

            return {
                top: box.top + window.pageYOffset,
                left: box.left + window.pageXOffset
            };
        },

        positionXY: function(e, t){
            switch (t) {
                case 'client': return this.clientXY(e);
                case 'screen': return this.screenXY(e);
                case 'page': return this.pageXY(e);
                default: return {x: 0, y: 0};
            }
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        clientXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
                y: e.changedTouches ? e.changedTouches[0].clientY : e.clientY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        screenXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].screenX : e.screenX,
                y: e.changedTouches ? e.changedTouches[0].screenY : e.screenY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        pageXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].pageX : e.pageX,
                y: e.changedTouches ? e.changedTouches[0].pageY : e.pageY
            };
        },

        isRightMouse: function(e){
            return "which" in e ? e.which === 3 : "button" in e ? e.button === 2 : undefined;
        },

        hiddenElementSize: function(el, includeMargin){
            var width, height, clone = $(el).clone(true);

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            $("body").append(clone);

            if (!this.isValue(includeMargin)) {
                includeMargin = false;
            }

            width = clone.outerWidth(includeMargin);
            height = clone.outerHeight(includeMargin);
            clone.remove();
            return {
                width: width,
                height: height
            };
        },

        getStyle: function(element, pseudo){
            var el = $(element)[0];
            return window.getComputedStyle(el, pseudo);
        },

        getStyleOne: function(el, property){
            return this.getStyle(el).getPropertyValue(property);
        },

        getTransformMatrix: function(el, returnArray){
            var computedMatrix = this.getStyleOne(el, "transform");
            var a = computedMatrix
                .replace("matrix(", '')
                .slice(0, -1)
                .split(',');
            return returnArray !== true ? {
                a: a[0],
                b: a[1],
                c: a[2],
                d: a[3],
                tx: a[4],
                ty: a[5]
            } : a;
        },

        computedRgbToHex: function(rgb){
            var a = rgb.replace(/[^\d,]/g, '').split(',');
            var result = "#", i;

            for(i = 0; i < 3; i++) {
                var h = parseInt(a[i]).toString(16);
                result += h.length === 1 ? "0" + h : h;
            }

            return result;
        },

        computedRgbToRgba: function(rgb, alpha){
            var a = rgb.replace(/[^\d,]/g, '').split(',');
            if (alpha === undefined) {
                alpha = 1;
            }
            a.push(alpha);
            return "rgba("+a.join(",")+")";
        },

        computedRgbToArray: function(rgb){
            return rgb.replace(/[^\d,]/g, '').split(',');
        },

        hexColorToArray: function(hex){
            var c;
            if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length === 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return [(c>>16)&255, (c>>8)&255, c&255];
            }
            return [0,0,0];
        },

        hexColorToRgbA: function(hex, alpha){
            var c;
            if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length === 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255, alpha ? alpha : 1].join(',')+')';
            }
            return 'rgba(0,0,0,1)';
        },

        getInlineStyles: function(element){
            var i, l, styles = {}, el = $(element)[0];
            for (i = 0, l = el.style.length; i < l; i++) {
                var s = el.style[i];
                styles[s] = el.style[s];
            }

            return styles;
        },

        updateURIParameter: function(uri, key, value) {
            var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
            var separator = uri.indexOf('?') !== -1 ? "&" : "?";
            if (uri.match(re)) {
                return uri.replace(re, '$1' + key + "=" + value + '$2');
            }
            else {
                return uri + separator + key + "=" + value;
            }
        },

        getURIParameter: function(url, name){
            if (!url) url = window.location.href;
            /* eslint-disable-next-line */
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        },

        getLocales: function(){
            return Object.keys(Metro.locales);
        },

        addLocale: function(locale){
            Metro.locales = $.extend( {}, Metro.locales, locale );
        },

        aspectRatioH: function(width, a){
            if (a === "16/9") return width * 9 / 16;
            if (a === "21/9") return width * 9 / 21;
            if (a === "4/3") return width * 3 / 4;
        },

        aspectRatioW: function(height, a){
            if (a === "16/9") return height * 16 / 9;
            if (a === "21/9") return height * 21 / 9;
            if (a === "4/3") return height * 4 / 3;
        },

        valueInObject: function(obj, value){
            return Object.values(obj).indexOf(value) > -1;
        },

        keyInObject: function(obj, key){
            return Object.keys(obj).indexOf(key) > -1;
        },

        inObject: function(obj, key, val){
            return obj[key] !== undefined && obj[key] === val;
        },

        newCssSheet: function(media){
            var style = document.createElement("style");

            if (media !== undefined) {
                style.setAttribute("media", media);
            }

            style.appendChild(document.createTextNode(""));

            document.head.appendChild(style);

            return style.sheet;
        },

        addCssRule: function(sheet, selector, rules, index){
            if("insertRule" in sheet) {
                sheet.insertRule(selector + "{" + rules + "}", index);
            }
            else if("addRule" in sheet) {
                sheet.addRule(selector, rules, index);
            }
        },

        media: function(query){
            return window.matchMedia(query).matches;
        },

        mediaModes: function(){
            return METRO_MEDIA;
        },

        mediaExist: function(media){
            return METRO_MEDIA.indexOf(media) > -1;
        },

        inMedia: function(media){
            return METRO_MEDIA.indexOf(media) > -1 && METRO_MEDIA.indexOf(media) === METRO_MEDIA.length - 1;
        },

        isValue: function(val){
            return val !== undefined && val !== null && val !== "";
        },

        isNull: function(val){
            return val === undefined || val === null;
        },

        isNegative: function(val){
            return parseFloat(val) < 0;
        },

        isPositive: function(val){
            return parseFloat(val) > 0;
        },

        isZero: function(val){
            return (parseFloat(val.toFixed(2))) === 0.00;
        },

        between: function(val, bottom, top, equals){
            return equals === true ? val >= bottom && val <= top : val > bottom && val < top;
        },

        parseMoney: function(val){
            return Number(parseFloat(val.replace(/[^0-9-.]/g, '')));
        },

        parseCard: function(val){
            return val.replace(/[^0-9]/g, '');
        },

        parsePhone: function(val){
            return this.parseCard(val);
        },

        parseNumber: function(val, thousand, decimal){
            return val.replace(new RegExp('\\'+thousand, "g"), "").replace(new RegExp('\\'+decimal, 'g'), ".");
        },

        nearest: function(val, precision, down){
            val /= precision;
            val = Math[down === true ? 'floor' : 'ceil'](val) * precision;
            return val;
        },

        bool: function(value){
            switch(value){
                case true:
                case "true":
                case 1:
                case "1":
                case "on":
                case "yes":
                    return true;
                default:
                    return false;
            }
        },

        copy: function(element){
            var body = document.body, range, sel;
            var el = $(element)[0];

            if (document.createRange && window.getSelection) {
                range = document.createRange();
                sel = window.getSelection();
                sel.removeAllRanges();
                try {
                    range.selectNodeContents(el);
                    sel.addRange(range);
                } catch (e) {
                    range.selectNode(el);
                    sel.addRange(range);
                }
            } else if (body["createTextRange"]) {
                range = body["createTextRange"]();
                range["moveToElementText"](el);
                range.select();
            }

            document.execCommand("Copy");

            if (window.getSelection) {
                if (window.getSelection().empty) {  // Chrome
                    window.getSelection().empty();
                } else if (window.getSelection().removeAllRanges) {  // Firefox
                    window.getSelection().removeAllRanges();
                }
            } else if (document["selection"]) {  // IE?
                document["selection"].empty();
            }
        },

        isLocalhost: function(pattern){
            pattern = pattern || ".local";
            return (
                location.hostname === "localhost" ||
                location.hostname === "127.0.0.1" ||
                location.hostname === "[::1]" ||
                location.hostname === "" ||
                window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/ ) ||
                location.hostname.indexOf(pattern) !== -1
            );
        },

        decCount: function(v){
            return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
        },

        randomColor: function(){
            var r, g, b;

            r = $.random(0, 255);
            g = $.random(0, 255);
            b = $.random(0, 255);

            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Utils = Metro.utils;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var AnimationDefaultConfig = {
        duration: METRO_ANIMATION_DURATION,
        ease: "linear"
    }

    Metro.animations = {

        switchIn: function(el){
            $(el)
                .hide()
                .css({
                    left: 0,
                    top: 0
                })
                .show();
        },

        switchOut: function(el){
            $(el).hide();
        },

        switch: function(current, next){
            this.switchOut(current);
            this.switchIn(next);
        },

        slideUpIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    top: h,
                    left: 0,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUpOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: -h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUp: function(current, next, o){
            this.slideUpOut(current, o);
            this.slideUpIn(next, o);
        },

        slideDownIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: 0,
                    top: -h,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDownOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDown: function(current, next, o){
            this.slideDownOut(current, o);
            this.slideDownIn(next, o);
        },

        slideLeftIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeftOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left: -w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeft: function(current, next, o){
            this.slideLeftOut(current, o);
            this.slideLeftIn(next, o);
        },

        slideRightIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: -w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRightOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left:  w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRight: function(current, next, o){
            this.slideRightOut(current, o);
            this.slideRightIn(next, o);
        },

        fadeIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0
                })
                .animate({
                    draw: {
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fadeOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .animate({
                    draw: {
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fade: function(current, next, o){
            this.fadeOut(current, o);
            this.fadeIn(next, o);
        },

        zoomIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoomOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoom: function(current, next, o){
            this.zoomOut(current, o);
            this.zoomIn(next, o);
        },

        swirlIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3) rotate(180deg)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        rotate: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirlOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        rotate: "180deg",
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirl: function(current, next, o){
            this.swirlOut(current, o);
            this.swirlIn(next, o);
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Animations = Metro.animations;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Types = {
        HEX: "hex",
        HEXA: "hexa",
        RGB: "rgb",
        RGBA: "rgba",
        HSV: "hsv",
        HSL: "hsl",
        HSLA: "hsla",
        CMYK: "cmyk",
        UNKNOWN: "unknown"
    };

    Metro.colorsSetup = function (options) {
        ColorsDefaultConfig = $.extend({}, ColorsDefaultConfig, options);
    };

    if (typeof window["metroColorsSetup"] !== undefined) {
        Metro.colorsSetup(window["metroColorsSetup"]);
    }

    var ColorsDefaultConfig = {
        angle: 30,
        algorithm: 1,
        step: 0.1,
        distance: 5,
        tint1: 0.8,
        tint2: 0.4,
        shade1: 0.6,
        shade2: 0.3,
        alpha: 1
    };

    // function HEX(r, g, b) {
    //     this.r = r || "00";
    //     this.g = g || "00";
    //     this.b = b || "00";
    // }
    //
    // HEX.prototype.toString = function(){
    //     return "#" + [this.r, this.g, this.b].join("");
    // }

    function RGB(r, g, b){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
    }

    RGB.prototype.toString = function(){
        return "rgb(" + [this.r, this.g, this.b].join(",") + ")";
    }

    function RGBA(r, g, b, a){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
        this.a = typeof a !== "undefined" ? a ? a : 1 : 1;
    }

    RGBA.prototype.toString = function(){
        return "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")";
    }

    function HSV(h, s, v){
        this.h = h || 0;
        this.s = s || 0;
        this.v = v || 0;
    }

    HSV.prototype.toString = function(){
        return "hsv(" + [this.h, this.s, this.v].join(",") + ")";
    }

    function HSL(h, s, l){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
    }

    HSL.prototype.toString = function(){
        return "hsl(" + [this.h, this.s, this.l].join(",") + ")";
    }

    function HSLA(h, s, l, a){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
        this.a = typeof a !== "undefined" ? a ? a : 1 : 1;
    }

    HSLA.prototype.toString = function(){
        return "hsla(" + [this.h, this.s, this.l, this.a].join(",") + ")";
    }

    function CMYK(c, m, y, k){
        this.c = c || 0;
        this.m = m || 0;
        this.y = y || 0;
        this.k = k || 0;
    }

    CMYK.prototype.toString = function(){
        return "cmyk(" + [this.c, this.m, this.y, this.k].join(",") + ")";
    }

    var Colors = {

        PALETTES: {
            ALL: "all",
            METRO: "metro",
            STANDARD: "standard"
        },

        metro: {
            lime: '#a4c400',
            green: '#60a917',
            emerald: '#008a00',
            blue: '#00AFF0',
            teal: '#00aba9',
            cyan: '#1ba1e2',
            cobalt: '#0050ef',
            indigo: '#6a00ff',
            violet: '#aa00ff',
            pink: '#dc4fad',
            magenta: '#d80073',
            crimson: '#a20025',
            red: '#CE352C',
            orange: '#fa6800',
            amber: '#f0a30a',
            yellow: '#fff000',
            brown: '#825a2c',
            olive: '#6d8764',
            steel: '#647687',
            mauve: '#76608a',
            taupe: '#87794e'
        },

        standard: {
            aliceBlue: "#f0f8ff",
            antiqueWhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedAlmond: "#ffebcd",
            blue: "#0000ff",
            blueViolet: "#8a2be2",
            brown: "#a52a2a",
            burlyWood: "#deb887",
            cadetBlue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerBlue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkBlue: "#00008b",
            darkCyan: "#008b8b",
            darkGoldenRod: "#b8860b",
            darkGray: "#a9a9a9",
            darkGreen: "#006400",
            darkKhaki: "#bdb76b",
            darkMagenta: "#8b008b",
            darkOliveGreen: "#556b2f",
            darkOrange: "#ff8c00",
            darkOrchid: "#9932cc",
            darkRed: "#8b0000",
            darkSalmon: "#e9967a",
            darkSeaGreen: "#8fbc8f",
            darkSlateBlue: "#483d8b",
            darkSlateGray: "#2f4f4f",
            darkTurquoise: "#00ced1",
            darkViolet: "#9400d3",
            deepPink: "#ff1493",
            deepSkyBlue: "#00bfff",
            dimGray: "#696969",
            dodgerBlue: "#1e90ff",
            fireBrick: "#b22222",
            floralWhite: "#fffaf0",
            forestGreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#DCDCDC",
            ghostWhite: "#F8F8FF",
            gold: "#ffd700",
            goldenRod: "#daa520",
            gray: "#808080",
            green: "#008000",
            greenYellow: "#adff2f",
            honeyDew: "#f0fff0",
            hotPink: "#ff69b4",
            indianRed: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavender: "#e6e6fa",
            lavenderBlush: "#fff0f5",
            lawnGreen: "#7cfc00",
            lemonChiffon: "#fffacd",
            lightBlue: "#add8e6",
            lightCoral: "#f08080",
            lightCyan: "#e0ffff",
            lightGoldenRodYellow: "#fafad2",
            lightGray: "#d3d3d3",
            lightGreen: "#90ee90",
            lightPink: "#ffb6c1",
            lightSalmon: "#ffa07a",
            lightSeaGreen: "#20b2aa",
            lightSkyBlue: "#87cefa",
            lightSlateGray: "#778899",
            lightSteelBlue: "#b0c4de",
            lightYellow: "#ffffe0",
            lime: "#00ff00",
            limeGreen: "#32dc32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumAquaMarine: "#66cdaa",
            mediumBlue: "#0000cd",
            mediumOrchid: "#ba55d3",
            mediumPurple: "#9370db",
            mediumSeaGreen: "#3cb371",
            mediumSlateBlue: "#7b68ee",
            mediumSpringGreen: "#00fa9a",
            mediumTurquoise: "#48d1cc",
            mediumVioletRed: "#c71585",
            midnightBlue: "#191970",
            mintCream: "#f5fffa",
            mistyRose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajoWhite: "#ffdead",
            navy: "#000080",
            oldLace: "#fdd5e6",
            olive: "#808000",
            oliveDrab: "#6b8e23",
            orange: "#ffa500",
            orangeRed: "#ff4500",
            orchid: "#da70d6",
            paleGoldenRod: "#eee8aa",
            paleGreen: "#98fb98",
            paleTurquoise: "#afeeee",
            paleVioletRed: "#db7093",
            papayaWhip: "#ffefd5",
            peachPuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderBlue: "#b0e0e6",
            purple: "#800080",
            rebeccaPurple: "#663399",
            red: "#ff0000",
            rosyBrown: "#bc8f8f",
            royalBlue: "#4169e1",
            saddleBrown: "#8b4513",
            salmon: "#fa8072",
            sandyBrown: "#f4a460",
            seaGreen: "#2e8b57",
            seaShell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            slyBlue: "#87ceeb",
            slateBlue: "#6a5acd",
            slateGray: "#708090",
            snow: "#fffafa",
            springGreen: "#00ff7f",
            steelBlue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whiteSmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowGreen: "#9acd32"
        },

        all: {},

        init: function(){
            this.all = $.extend( {}, this.standard, this.metro );
            return this;
        },

        color: function(name, palette){
            palette = palette || this.PALETTES.ALL;
            return this[palette][name] !== undefined ? this[palette][name] : false;
        },

        palette: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.keys(this[palette]);
        },

        expandHexColor: function(hex){
            if (typeof hex !== "string") {
                throw new Error("Value is not a string!");
            }
            if (hex[0] === "#" && hex.length === 4) {
                var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                return (
                    "#" +
                    hex.replace(shorthandRegex, function(m, r, g, b) {
                        return r + r + g + g + b + b;
                    })
                );
            }
            return hex[0] === "#" ? hex : "#" + hex;
        },

        colors: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.values(this[palette]);
        },

        random: function(colorType, alpha){
            colorType = colorType || Types.HEX;
            alpha = typeof alpha !== "undefined" ? alpha : 1;

            var hex, r, g, b;

            r = $.random(0, 255);
            g = $.random(0, 255);
            b = $.random(0, 255);

            hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

            return colorType === "hex" ? hex : this.toColor(hex, colorType, alpha);
        },

        parse: function(color){
            var _color = color.toLowerCase();

            var a = _color
                .replace(/[^\d.,]/g, "")
                .split(",")
                .map(function(v) {
                    return v.indexOf(".") > -1 ? parseFloat(v) : parseInt(v);
                });

            if (_color[0] === "#") {
                return this.expandHexColor(_color);
            }

            if (_color.indexOf("rgba") > -1) {
                return new RGBA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("rgb") > -1) {
                return new RGB(a[0], a[1], a[2]);
            }
            if (_color.indexOf("cmyk") > -1) {
                return new CMYK(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsv") > -1) {
                return new HSV(a[0], a[1], a[2]);
            }
            if (_color.indexOf("hsla") > -1) {
                return new HSLA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsl") > -1) {
                return new HSL(a[0], a[1], a[2]);
            }
            return _color;
        },

        createColor: function(colorType, from){
            colorType = colorType || "hex";
            from = from || "#000000";

            var baseColor;

            if (typeof from === "string") {
                baseColor = this.parse(from);
            }

            if (!this.isColor(baseColor)) {
                baseColor = "#000000";
            }

            return this.toColor(baseColor, colorType.toLowerCase());
        },

        isDark: function(color){
            if (!this.isColor(color)) return;
            var rgb = this.toRGB(color);
            var YIQ = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            return YIQ < 128;
        },

        isLight: function(color){
            return !this.isDark(color);
        },

        isHSV: function(color){
            return color instanceof HSV;
        },

        isHSL: function(color){
            return color instanceof HSL;
        },

        isHSLA: function(color){
            return color instanceof HSLA;
        },

        isRGB: function(color){
            return color instanceof RGB;
        },

        isRGBA: function(color){
            return color instanceof RGBA;
        },

        isCMYK: function(color){
            return color instanceof CMYK;
        },

        isHEX: function(color){
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
        },

        isColor: function(color){
            return !color
                ? false
                : this.isHEX(color) ||
                  this.isRGB(color) ||
                  this.isRGBA(color) ||
                  this.isHSV(color) ||
                  this.isHSL(color) ||
                  this.isHSLA(color) ||
                  this.isCMYK(color);
        },

        check: function(color, type){
            if (!this["is"+type.toUpperCase()](color)) {
                throw new Error("Value is not a " + type + " color type!");
            }
        },

        colorType: function(color){
            if (this.isHEX(color)) return Types.HEX;
            if (this.isRGB(color)) return Types.RGB;
            if (this.isRGBA(color)) return Types.RGBA;
            if (this.isHSV(color)) return Types.HSV;
            if (this.isHSL(color)) return Types.HSL;
            if (this.isHSLA(color)) return Types.HSLA;
            if (this.isCMYK(color)) return Types.CMYK;

            return Types.UNKNOWN;
        },

        equal: function(color1, color2){
            if (!this.isColor(color1) || !this.isColor(color2)) {
                return false;
            }

            return this.toHEX(color1) === this.toHEX(color2);
        },

        colorToString: function(color){
            return color.toString();
        },

        hex2rgb: function(color){
            if (typeof color !== "string") {
                throw new Error("Value is not a string!")
            }
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                this.expandHexColor(color)
            );
            var rgb = [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ];
            return result ? new RGB(rgb[0], rgb[1], rgb[2]) : null;
        },

        rgb2hex: function(color){
            this.check(color, "rgb");
            return (
                "#" +
                ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1)
            );
        },

        rgb2hsv: function(color){
            this.check(color, "rgb");
            var hsv = new HSV();
            var h, s, v;
            var r = color.r / 255,
                g = color.g / 255,
                b = color.b / 255;

            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = max - min;

            v = max;

            if (max === 0) {
                s = 0;
            } else {
                s = 1 - min / max;
            }

            if (max === min) {
                h = 0;
            } else if (max === r && g >= b) {
                h = 60 * ((g - b) / delta);
            } else if (max === r && g < b) {
                h = 60 * ((g - b) / delta) + 360;
            } else if (max === g) {
                h = 60 * ((b - r) / delta) + 120;
            } else if (max === b) {
                h = 60 * ((r - g) / delta) + 240;
            } else {
                h = 0;
            }

            hsv.h = h;
            hsv.s = s;
            hsv.v = v;

            return hsv;
        },

        hsv2rgb: function(color){
            this.check(color, "hsv");
            var r, g, b;
            var h = color.h,
                s = color.s * 100,
                v = color.v * 100;
            var Hi = Math.floor(h / 60);
            var Vmin = ((100 - s) * v) / 100;
            var alpha = (v - Vmin) * ((h % 60) / 60);
            var Vinc = Vmin + alpha;
            var Vdec = v - alpha;

            switch (Hi) {
                case 0:
                    r = v;
                    g = Vinc;
                    b = Vmin;
                    break;
                case 1:
                    r = Vdec;
                    g = v;
                    b = Vmin;
                    break;
                case 2:
                    r = Vmin;
                    g = v;
                    b = Vinc;
                    break;
                case 3:
                    r = Vmin;
                    g = Vdec;
                    b = v;
                    break;
                case 4:
                    r = Vinc;
                    g = Vmin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = Vmin;
                    b = Vdec;
                    break;
            }

            return new RGB(
                Math.round((r * 255) / 100),
                Math.round((g * 255) / 100),
                Math.round((b * 255) / 100)
            );
        },

        hsv2hex: function(color){
            this.check(color, "hsv");
            return this.rgb2hex(this.hsv2rgb(color));
        },

        hex2hsv: function(color){
            this.check(color, "hex");
            return this.rgb2hsv(this.hex2rgb(color));
        },

        rgb2cmyk: function(color){
            this.check(color, "rgb");
            var cmyk = new CMYK();

            var r = color.r / 255;
            var g = color.g / 255;
            var b = color.b / 255;

            cmyk.k = Math.min(1 - r, 1 - g, 1 - b);

            cmyk.c = 1 - cmyk.k === 0 ? 0 : (1 - r - cmyk.k) / (1 - cmyk.k);
            cmyk.m = 1 - cmyk.k === 0 ? 0 : (1 - g - cmyk.k) / (1 - cmyk.k);
            cmyk.y = 1 - cmyk.k === 0 ? 0 : (1 - b - cmyk.k) / (1 - cmyk.k);

            cmyk.c = Math.round(cmyk.c * 100);
            cmyk.m = Math.round(cmyk.m * 100);
            cmyk.y = Math.round(cmyk.y * 100);
            cmyk.k = Math.round(cmyk.k * 100);

            return cmyk;
        },

        cmyk2rgb: function(color){
            this.check(color, "cmyk");
            var r = Math.floor(255 * (1 - color.c / 100) * (1 - color.k / 100));
            var g = Math.ceil(255 * (1 - color.m / 100) * (1 - color.k / 100));
            var b = Math.ceil(255 * (1 - color.y / 100) * (1 - color.k / 100));

            return new RGB(r, g, b);
        },

        hsv2hsl: function(color){
            this.check(color, "hsv");
            var h, s, l, d;
            h = color.h;
            l = (2 - color.s) * color.v;
            s = color.s * color.v;
            if (l === 0) {
                s = 0;
            } else {
                d = l <= 1 ? l : 2 - l;
                if (d === 0) {
                    s = 0;
                } else {
                    s /= d;
                }
            }
            l /= 2;
            return new HSL(h, s, l);
        },

        hsl2hsv: function(color){
            this.check(color, "hsl");
            var h, s, v, l;
            h = color.h;
            l = color.l * 2;
            s = color.s * (l <= 1 ? l : 2 - l);

            v = (l + s) / 2;

            if (l + s === 0) {
                s = 0;
            } else {
                s = (2 * s) / (l + s);
            }

            return new HSV(h, s, v);
        },

        rgb2websafe: function(color){
            this.check(color, "rgb");
            return new RGB(
                Math.round(color.r / 51) * 51,
                Math.round(color.g / 51) * 51,
                Math.round(color.b / 51) * 51
            );
        },

        rgba2websafe: function(color){
            this.check(color, "rgba");
            var rgbWebSafe = this.rgb2websafe(color);
            return new RGBA(rgbWebSafe.r, rgbWebSafe.g, rgbWebSafe.b, color.a);
        },

        hex2websafe: function(color){
            this.check(color, "hex");
            return this.rgb2hex(this.rgb2websafe(this.hex2rgb(color)));
        },

        hsv2websafe: function(color){
            this.check(color, "hsv");
            return this.rgb2hsv(this.rgb2websafe(this.toRGB(color)));
        },

        hsl2websafe: function(color){
           this.check(color, "hsl");
            return this.hsv2hsl(this.rgb2hsv(this.rgb2websafe(this.toRGB(color))));
        },

        cmyk2websafe: function(color){
            this.check(color, "cmyk");
            return this.rgb2cmyk(this.rgb2websafe(this.cmyk2rgb(color)));
        },

        websafe: function(color){
            if (this.isHEX(color)) return this.hex2websafe(color);
            if (this.isRGB(color)) return this.rgb2websafe(color);
            if (this.isRGBA(color)) return this.rgba2websafe(color);
            if (this.isHSV(color)) return this.hsv2websafe(color);
            if (this.isHSL(color)) return this.hsl2websafe(color);
            if (this.isCMYK(color)) return this.cmyk2websafe(color);

            return color;
        },

        toColor: function(color, type, alpha){
            var result;
            switch (type.toLowerCase()) {
                case "hex":
                    result = this.toHEX(color);
                    break;
                case "rgb":
                    result = this.toRGB(color);
                    break;
                case "rgba":
                    result = this.toRGBA(color, alpha);
                    break;
                case "hsl":
                    result = this.toHSL(color);
                    break;
                case "hsla":
                    result = this.toHSLA(color, alpha);
                    break;
                case "hsv":
                    result = this.toHSV(color);
                    break;
                case "cmyk":
                    result = this.toCMYK(color);
                    break;
                default:
                    result = color;
            }
            return result;
        },

        toHEX: function(color){
            return typeof color === "string"
                ? this.expandHexColor(color)
                : this.rgb2hex(this.toRGB(color));
        },

        toRGB: function(color){
            if (this.isRGB(color)) return color;
            if (this.isRGBA(color)) return new RGB(color.r, color.g, color.b);
            if (this.isHSV(color)) return this.hsv2rgb(color);
            if (this.isHSL(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHSLA(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHEX(color)) return this.hex2rgb(color);
            if (this.isCMYK(color)) return this.cmyk2rgb(color);

            throw new Error("Unknown color format!");
        },

        toRGBA: function(color, alpha){
            if (this.isRGBA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var rgb = this.toRGB(color);
            return new RGBA(rgb.r, rgb.g, rgb.b, alpha);
        },

        toHSV: function(color){
            return this.rgb2hsv(this.toRGB(color));
        },

        toHSL: function(color){
            return this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
        },

        toHSLA: function(color, alpha){
            if (this.isHSLA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var hsla = this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
            hsla.a = alpha;
            return new HSLA(hsla.h, hsla.s, hsla.l, hsla.a);
        },

        toCMYK: function(color){
            return this.rgb2cmyk(this.toRGB(color));
        },

        grayscale: function(color){
            var rgb = this.toRGB(color);
            var type = this.colorType(color).toLowerCase();
            var gray = Math.round(rgb.r * 0.2125 + rgb.g * 0.7154 + rgb.b * 0.0721);
            var mono = new RGB(gray, gray, gray);

            return this.toColor(mono, type);
        },

        darken: function(color, amount){
            amount = amount || 10;
            return this.lighten(color, -1 * Math.abs(amount));
        },

        lighten: function(color, amount){
            var type, res, alpha, ring;

            amount = amount || 10;

            var calc = function (_color, _amount) {
                var r, g, b;
                var col = _color.slice(1);

                var num = parseInt(col, 16);
                r = (num >> 16) + _amount;

                if (r > 255) r = 255;
                else if (r < 0) r = 0;

                b = ((num >> 8) & 0x00ff) + _amount;

                if (b > 255) b = 255;
                else if (b < 0) b = 0;

                g = (num & 0x0000ff) + _amount;

                if (g > 255) g = 255;
                else if (g < 0) g = 0;

                return "#" + (g | (b << 8) | (r << 16)).toString(16);
            };

            ring = amount > 0;

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            do {
                res = calc(this.toHEX(color), amount);
                ring ? amount-- : amount++;
            } while (res.length < 7);

            return this.toColor(res, type, alpha);
        },

        hueShift: function(color, hue, saturation, value){
            var hsv = this.toHSV(color);
            var type = this.colorType(color).toLowerCase();
            var h = hsv.h;
            var alpha;
            var _h = hue || 0;
            var _s = saturation || 0;
            var _v = value || 0;

            h += _h;
            while (h >= 360.0) h -= 360.0;
            while (h < 0.0) h += 360.0;
            hsv.h = h;

            hsv.s += _s;
            if (hsv.s > 1) {hsv.s = 1;}
            if (hsv.s < 0) {hsv.s = 0;}

            hsv.v += _v;
            if (hsv.v > 1) {hsv.v = 1;}
            if (hsv.v < 0) {hsv.v = 0;}

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsv, type, alpha);
        },

        createScheme: function(color, name, format, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var i, scheme = [], hsv, rgb, h, s, v;
            var self = this;

            hsv = this.toHSV(color);
            h = hsv.h;
            s = hsv.s;
            v = hsv.v;

            if (this.isHSV(hsv) === false) {
                console.warn("The value is a not supported color format!");
                return false;
            }

            function convert(source, format) {
                var result;
                switch (format) {
                    case "hex":
                        result = source.map(function (v) {
                            return self.toHEX(v);
                        });
                        break;
                    case "rgb":
                        result = source.map(function (v) {
                            return self.toRGB(v);
                        });
                        break;
                    case "rgba":
                        result = source.map(function (v) {
                            return self.toRGBA(v, opt.alpha);
                        });
                        break;
                    case "hsl":
                        result = source.map(function (v) {
                            return self.toHSL(v);
                        });
                        break;
                    case "hsla":
                        result = source.map(function (v) {
                            return self.toHSLA(v, opt.alpha);
                        });
                        break;
                    case "cmyk":
                        result = source.map(function (v) {
                            return self.toCMYK(v);
                        });
                        break;
                    default:
                        result = source;
                }

                return result;
            }

            function clamp(num, min, max) {
                return Math.max(min, Math.min(num, max));
            }

            function toRange(a, b, c) {
                return a < b ? b : a > c ? c : a;
            }

            function shift(h, s) {
                h += s;
                while (h >= 360.0) h -= 360.0;
                while (h < 0.0) h += 360.0;
                return h;
            }

            switch (name) {
                case "monochromatic":
                case "mono":
                    if (opt.algorithm === 1) {
                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(
                            Math.round(rgb.r + (255 - rgb.r) * opt.tint1),
                            0,
                            255
                        );
                        rgb.g = toRange(
                            Math.round(rgb.g + (255 - rgb.g) * opt.tint1),
                            0,
                            255
                        );
                        rgb.b = toRange(
                            Math.round(rgb.b + (255 - rgb.b) * opt.tint1),
                            0,
                            255
                        );
                        scheme.push(this.rgb2hsv(rgb));

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(
                            Math.round(rgb.r + (255 - rgb.r) * opt.tint2),
                            0,
                            255
                        );
                        rgb.g = toRange(
                            Math.round(rgb.g + (255 - rgb.g) * opt.tint2),
                            0,
                            255
                        );
                        rgb.b = toRange(
                            Math.round(rgb.b + (255 - rgb.b) * opt.tint2),
                            0,
                            255
                        );
                        scheme.push(this.rgb2hsv(rgb));

                        scheme.push(hsv);

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(Math.round(rgb.r * opt.shade1), 0, 255);
                        rgb.g = toRange(Math.round(rgb.g * opt.shade1), 0, 255);
                        rgb.b = toRange(Math.round(rgb.b * opt.shade1), 0, 255);
                        scheme.push(this.rgb2hsv(rgb));

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(Math.round(rgb.r * opt.shade2), 0, 255);
                        rgb.g = toRange(Math.round(rgb.g * opt.shade2), 0, 255);
                        rgb.b = toRange(Math.round(rgb.b * opt.shade2), 0, 255);
                        scheme.push(this.rgb2hsv(rgb));

                    } else if (opt.algorithm === 2) {

                        scheme.push(hsv);
                        for (i = 1; i <= opt.distance; i++) {
                            v = clamp(v - opt.step, 0, 1);
                            s = clamp(s - opt.step, 0, 1);
                            scheme.push(new HSV(h, s, v));
                        }

                    } else if (opt.algorithm === 3) {

                        scheme.push(hsv);
                        for (i = 1; i <= opt.distance; i++) {
                            v = clamp(v - opt.step, 0, 1);
                            scheme.push(new HSV(h, s, v));
                        }

                    } else {

                        v = clamp(hsv.v + opt.step * 2, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        v = clamp(hsv.v + opt.step, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        scheme.push(hsv);
                        s = hsv.s;
                        v = hsv.v;

                        v = clamp(hsv.v - opt.step, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        v = clamp(hsv.v - opt.step * 2, 0, 1);
                        scheme.push(new HSV(h, s, v));

                    }
                    break;

                case "complementary":
                case "complement":
                case "comp":
                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0);
                    scheme.push(new HSV(h, s, v));
                    break;

                case "double-complementary":
                case "double-complement":
                case "double":
                    scheme.push(hsv);

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, opt.angle);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "analogous":
                case "analog":
                    h = shift(h, opt.angle);
                    scheme.push(new HSV(h, s, v));

                    scheme.push(hsv);

                    h = shift(hsv.h, 0.0 - opt.angle);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "triadic":
                case "triad":
                    scheme.push(hsv);
                    for (i = 1; i < 3; i++) {
                        h = shift(h, 120.0);
                        scheme.push(new HSV(h, s, v));
                    }
                    break;

                case "tetradic":
                case "tetra":
                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    h = shift(hsv.h, -1 * opt.angle);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "square":
                    scheme.push(hsv);
                    for (i = 1; i < 4; i++) {
                        h = shift(h, 90.0);
                        scheme.push(new HSV(h, s, v));
                    }
                    break;

                case "split-complementary":
                case "split-complement":
                case "split":
                    h = shift(h, 180.0 - opt.angle);
                    scheme.push(new HSV(h, s, v));

                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0 + opt.angle);
                    scheme.push(new HSV(h, s, v));
                    break;

                default:
                    console.warn("Unknown scheme name");
            }

            return convert(scheme, format);
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments)
        },

        mix: function(color1, color2, returnAs){
            var c1 = this.toRGBA(color1);
            var c2 = this.toRGBA(color2);
            var result = new RGBA();
            var to = (""+returnAs).toLowerCase() || "hex";

            result.r = Math.round((c1.r + c2.r) / 2);
            result.g = Math.round((c1.g + c2.g) / 2);
            result.b = Math.round((c1.b + c2.b) / 2);
            result.a = Math.round((c1.a + c2.a) / 2);

            return this["to"+to.toUpperCase()](result);
        }
    };

    var Color = function(color, options){
        this._setValue(color);
        this._setOptions(options);
    }

    Color.prototype = {
        _setValue: function(color){
            var _color;

            if (typeof color === "string") {
                _color = Colors.parse(color);
            } else {
                _color = color;
            }

            if (!Colors.isColor(_color)) {
                _color = "#000000";
            }

            this._value = _color;
            this._type = Colors.colorType(this._value);
        },

        _setOptions: function(options){
            options = typeof options === "object" ? options : {};
            this._options = $.extend({}, ColorsDefaultConfig, options);
        },

        getOptions: function(){
            return this._options;
        },

        setOptions: function(options){
            this._setOptions(options);
        },

        setValue: function(color){
            this._setValue(color);
        },

        getValue: function(){
            return this._value;
        },

        channel: function(ch, val){
            var currentType = this._type.toUpperCase();

            if (["red", "green", "blue"].indexOf(ch) > -1) {
                this.toRGB();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (ch === "alpha" && this._value.a) {
                this._value.a = val;
            }
            if (["hue", "saturation", "value"].indexOf(ch) > -1) {
                this.toHSV();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["lightness"].indexOf(ch) > -1) {
                this.toHSL();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["cyan", "magenta", "yellow", "black"].indexOf(ch) > -1) {
                this.toCMYK();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }

            return this;
        },

        channels: function(obj){
            var that = this;

            $.each(obj, function(key, val){
                that.channel(key, val);
            });

            return this;
        },

        toRGB: function() {
            this._value = Colors.toRGB(this._value);
            this._type = Types.RGB;
            return this;
        },

        rgb: function(){
            return this._value ? new Color(Colors.toRGB(this._value)) : undefined;
        },

        toRGBA: function(alpha) {
            if (Colors.isRGBA(this._value)) {
                if (alpha) {
                    this._value = Colors.toRGBA(this._value, alpha);
                }
            } else {
                this._value = Colors.toRGBA(this._value, alpha);
            }
            this._type = Types.RGBA;
            return this;
        },

        rgba: function(alpha) {
            return this._value ? new Color(Colors.toRGBA(this._value, alpha)) : undefined;
        },

        toHEX: function() {
            this._value = Colors.toHEX(this._value);
            this._type = Types.HEX;
            return this;
        },

        hex: function() {
            return this._value ? new Color(Colors.toHEX(this._value)) : undefined;
        },

        toHSV: function() {
            this._value = Colors.toHSV(this._value);
            this._type = Types.HSV;
            return this;
        },

        hsv: function() {
            return this._value ? new Color(Colors.toHSV(this._value)) : undefined;
        },

        toHSL: function() {
            this._value = Colors.toHSL(this._value);
            this._type = Types.HSL;
            return this;
        },

        hsl: function() {
            return this._value ? new Color(Colors.toHSL(this._value)) : undefined;
        },

        toHSLA: function(alpha) {
            if (Colors.isHSLA(this._value)) {
                if (alpha) {
                    this._value = Colors.toHSLA(this._value, alpha);
                }
            } else {
                this._value = Colors.toHSLA(this._value, alpha);
            }
            this._type = Types.HSLA;
            return this;
        },

        hsla: function(alpha) {
            return this._value ? new Color(Colors.toHSLA(this._value, alpha)) : undefined;
        },

        toCMYK: function() {
            this._value = Colors.toCMYK(this._value);
            this._type = Types.CMYK;
            return this;
        },

        cmyk: function() {
            return this._value ? new Color(Colors.toCMYK(this._value)) : undefined;
        },

        toWebsafe: function() {
            this._value = Colors.websafe(this._value);
            this._type = Colors.colorType(this._value);
            return this;
        },

        websafe: function() {
            return this._value ? new Color(Colors.websafe(this._value)) : undefined;
        },

        toString: function() {
            return this._value ? Colors.colorToString(this._value) : "undefined";
        },

        toDarken: function(amount) {
            this._value = Colors.darken(this._value, amount);
            return this;
        },

        darken: function(amount){
            return new Color(Colors.darken(this._value, amount));
        },

        toLighten: function(amount) {
            this._value = Colors.lighten(this._value, amount);
            return this;
        },

        lighten: function(amount){
            return new Color(Colors.lighten(this._value, amount))
        },

        isDark: function() {
            return this._value ? Colors.isDark(this._value) : undefined;
        },

        isLight: function() {
            return this._value ? Colors.isLight(this._value) : undefined;
        },

        toHueShift: function(hue, saturation, value) {
            this._value = Colors.hueShift(this._value, hue, saturation, value);
            return this;
        },

        hueShift: function (hue, saturation, value) {
            return new Color(Colors.hueShift(this._value, hue, saturation, value));
        },

        toGrayscale: function() {
            this._value = Colors.grayscale(this._value, this._type);
            return this;
        },

        grayscale: function(){
            return new Color(Colors.grayscale(this._value, this._type));
        },

        type: function() {
            return Colors.colorType(this._value);
        },

        createScheme: function(name, format, options) {
            return this._value
                ? Colors.createScheme(this._value, name, format, options)
                : undefined;
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments);
        },

        equal: function(color) {
            return Colors.equal(this._value, color);
        },

        toMix: function(color){
            this._value = Colors.mix(this._value, color, this._type);
            return this;
        },

        mix: function(color){
            return new Color(Colors.mix(this._value, color, this._type));
        }
    }

    Metro.colors = Colors.init();
    window.Color = Metro.Color = Color;
    window.ColorPrimitive = Metro.colorPrimitive = {
        RGB: RGB,
        RGBA: RGBA,
        HSV: HSV,
        HSL: HSL,
        HSLA: HSLA,
        CMYK: CMYK
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Colors = Metro.colors;
    }

}(Metro, m4q));

(function(Metro, $) {
   'use strict';
   var Utils = Metro.utils;
   var Export = {

        init: function(){
            return this;
        },

        options: {
            csvDelimiter: "\t",
            csvNewLine: "\r\n",
            includeHeader: true
        },

        setup: function(options){
            this.options = $.extend({}, this.options, options);
            return this;
        },

        base64: function(data){
            return window.btoa(unescape(encodeURIComponent(data)));
        },

        b64toBlob: function (b64Data, contentType, sliceSize) {
            contentType = contentType || '';
            sliceSize = sliceSize || 512;

            var byteCharacters = window.atob(b64Data);
            var byteArrays = [];

            var offset;
            for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                var i;
                for (i = 0; i < slice.length; i = i + 1) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new window.Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, {
                type: contentType
            });
        },

        tableToCSV: function(table, filename, options){
            var o = this.options;
            var body, head, data = "";
            var i, j, row, cell;

            o = $.extend({}, o, options);

            table = $(table)[0];

            if (Utils.bool(o.includeHeader)) {

                head = table.querySelectorAll("thead")[0];

                for(i = 0; i < head.rows.length; i++) {
                    row = head.rows[i];
                    for(j = 0; j < row.cells.length; j++){
                        cell = row.cells[j];
                        data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                    }
                    data += o.csvNewLine;
                }
            }

            body = table.querySelectorAll("tbody")[0];

            for(i = 0; i < body.rows.length; i++) {
                row = body.rows[i];
                for(j = 0; j < row.cells.length; j++){
                    cell = row.cells[j];
                    data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                }
                data += o.csvNewLine;
            }

            if (Utils.isValue(filename)) {
                return this.createDownload(this.base64("\uFEFF" + data), 'application/csv', filename);
            }

            return data;
        },

        createDownload: function (data, contentType, filename) {
            var blob, anchor, url;

            anchor = document.createElement('a');
            anchor.style.display = "none";
            document.body.appendChild(anchor);

            blob = this.b64toBlob(data, contentType);

            url = window.URL.createObjectURL(blob);
            anchor.href = url;
            anchor.download = filename || Utils.elementId("download");
            anchor.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(anchor);
            return true;
        }
    };

    Metro.export = Export.init();

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Export = Metro.export;
    }
}(Metro, m4q));

(function(Metro) {
    'use strict';
    Metro.md5 = function (string) {
        function RotateLeft(lValue, iShiftBits) {
            return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
        }

        function AddUnsigned(lX,lY) {
            var lX4,lY4,lX8,lY8,lResult;
            lX8 = (lX & 0x80000000);
            lY8 = (lY & 0x80000000);
            lX4 = (lX & 0x40000000);
            lY4 = (lY & 0x40000000);
            lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
            if (lX4 & lY4) {
                return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
            }
            if (lX4 | lY4) {
                if (lResult & 0x40000000) {
                    return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                } else {
                    return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                }
            } else {
                return (lResult ^ lX8 ^ lY8);
            }
        }

        function F(x,y,z) { return (x & y) | ((~x) & z); }
        function G(x,y,z) { return (x & z) | (y & (~z)); }
        function H(x,y,z) { return (x ^ y ^ z); }
        function I(x,y,z) { return (y ^ (x | (~z))); }

        function FF(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function GG(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function HH(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function II(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function ConvertToWordArray(string) {
            var lWordCount;
            var lMessageLength = string.length;
            var lNumberOfWords_temp1=lMessageLength + 8;
            var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
            var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
            var lWordArray=Array(lNumberOfWords-1);
            var lBytePosition = 0;
            var lByteCount = 0;
            while ( lByteCount < lMessageLength ) {
                lWordCount = (lByteCount-(lByteCount % 4))/4;
                lBytePosition = (lByteCount % 4)*8;
                lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
                lByteCount++;
            }
            lWordCount = (lByteCount-(lByteCount % 4))/4;
            lBytePosition = (lByteCount % 4)*8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
            lWordArray[lNumberOfWords-2] = lMessageLength<<3;
            lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
            return lWordArray;
        }

        function WordToHex(lValue) {
            var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
            for (lCount = 0;lCount<=3;lCount++) {
                lByte = (lValue>>>(lCount*8)) & 255;
                WordToHexValue_temp = "0" + lByte.toString(16);
                WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
            }
            return WordToHexValue;
        }

        function Utf8Encode(string) {
            string = string.replace(/\r\n/g,"\n");
            var utftext = "";

            for (var n = 0; n < string.length; n++) {

                var c = string.charCodeAt(n);

                if (c < 128) {
                    utftext += String.fromCharCode(c);
                }
                else if((c > 127) && (c < 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c & 63) | 128);
                }
                else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                    utftext += String.fromCharCode((c & 63) | 128);
                }

            }

            return utftext;
        }

        var x=[];
        var k,AA,BB,CC,DD,a,b,c,d;
        var S11=7, S12=12, S13=17, S14=22;
        var S21=5, S22=9 , S23=14, S24=20;
        var S31=4, S32=11, S33=16, S34=23;
        var S41=6, S42=10, S43=15, S44=21;

        string = Utf8Encode(string);

        x = ConvertToWordArray(string);

        a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

        for (k=0;k<x.length;k+=16) {
            AA=a; BB=b; CC=c; DD=d;
            a=FF(a,b,c,d,x[k], S11,0xD76AA478);
            d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
            c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
            b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
            a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
            d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
            c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
            b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
            a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
            d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
            c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
            b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
            a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
            d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
            c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
            b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
            a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
            d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
            c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
            b=GG(b,c,d,a,x[k], S24,0xE9B6C7AA);
            a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
            d=GG(d,a,b,c,x[k+10],S22,0x2441453);
            c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
            b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
            a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
            d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
            c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
            b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
            a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
            d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
            c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
            b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
            a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
            d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
            c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
            b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
            a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
            d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
            c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
            b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
            a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
            d=HH(d,a,b,c,x[k], S32,0xEAA127FA);
            c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
            b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
            a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
            d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
            c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
            b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
            a=II(a,b,c,d,x[k], S41,0xF4292244);
            d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
            c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
            b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
            a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
            d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
            c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
            b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
            a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
            d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
            c=II(c,d,a,b,x[k+6], S43,0xA3014314);
            b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
            a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
            d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
            c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
            b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
            a=AddUnsigned(a,AA);
            b=AddUnsigned(b,BB);
            c=AddUnsigned(c,CC);
            d=AddUnsigned(d,DD);
        }

        var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

        return temp.toLowerCase();
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.md5 = Metro.md5;
    }
}(Metro, m4q));

(function(Metro, $){
    'use strict';
    var Utils = Metro.utils;
    var AccordionDefaultConfig = {
        accordionDeferred: 0,
        showMarker: true,
        material: false,
        duration: METRO_ANIMATION_DURATION,
        oneFrame: true,
        showActive: true,
        activeFrameClass: "",
        activeHeadingClass: "",
        activeContentClass: "",
        onFrameOpen: Metro.noop,
        onFrameBeforeOpen: Metro.noop_true,
        onFrameClose: Metro.noop,
        onFrameBeforeClose: Metro.noop_true,
        onAccordionCreate: Metro.noop
    };

    Metro.accordionSetup = function(options){
        AccordionDefaultConfig = $.extend({}, AccordionDefaultConfig, options);
    };

    if (typeof window["metroAccordionSetup"] !== undefined) {
        Metro.accordionSetup(window["metroAccordionSetup"]);
    }

    Metro.Component('accordion', {
        init: function( options, elem ) {
            this._super(elem, options, AccordionDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent('accordionCreate', {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var frames = element.children(".frame");
            var active = element.children(".frame.active");
            var frame_to_open;

            element.addClass("accordion");

            if (o.showMarker === true) {
                element.addClass("marker-on");
            }

            if (o.material === true) {
                element.addClass("material");
            }

            if (active.length === 0) {
                frame_to_open = frames[0];
            } else {
                frame_to_open = active[0];
            }

            this._hideAll();

            if (o.showActive === true) {
                if (o.oneFrame === true) {
                    this._openFrame(frame_to_open);
                } else {
                    $.each(active, function(){
                        that._openFrame(this);
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var active = element.children(".frame.active");

            element.on(Metro.events.click, ".heading", function(){
                var heading = $(this);
                var frame = heading.parent();

                if (heading.closest(".accordion")[0] !== element[0]) {
                    return false;
                }

                if (frame.hasClass("active")) {
                    if (active.length === 1 && o.oneFrame) {
                        /* eslint-disable-next-line */

                    } else {
                        that._closeFrame(frame);
                    }
                } else {
                    that._openFrame(frame);
                }
            });
        },

        _openFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (Utils.exec(o.onFrameBeforeOpen, [frame[0]], element[0]) === false) {
                return false;
            }

            if (o.oneFrame === true) {
                this._closeAll(frame[0]);
            }

            frame.addClass("active " + o.activeFrameClass);
            frame.children(".heading").addClass(o.activeHeadingClass);
            frame.children(".content").addClass(o.activeContentClass).slideDown(o.duration);

            this._fireEvent("frameOpen", {
                frame: frame[0]
            });
        },

        _closeFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (!frame.hasClass("active")) {
                return ;
            }

            if (Utils.exec(o.onFrameBeforeClose, [frame[0]], element[0]) === false) {
                return ;
            }

            frame.removeClass("active " + o.activeFrameClass);
            frame.children(".heading").removeClass(o.activeHeadingClass);
            frame.children(".content").removeClass(o.activeContentClass).slideUp(o.duration);

            this._fireEvent("frameClose", {
                frame: frame[0]
            });
        },

        _closeAll: function(skip){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                if (skip === this) return;
                that._closeFrame(this);
            });
        },

        _hideAll: function(){
            var element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                $(this).children(".content").hide();
            });
        },

        _openAll: function(){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                that._openFrame(this);
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".heading");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ActivityDefaultConfig = {
        activityDeferred: 0,
        type: "ring",
        style: "light",
        size: 64,
        radius: 20,
        onActivityCreate: Metro.noop
    };

    Metro.activitySetup = function(options){
        ActivityDefaultConfig = $.extend({}, ActivityDefaultConfig, options);
    };

    if (typeof window["metroActivitySetup"] !== undefined) {
        Metro.activitySetup(window["metroActivitySetup"]);
    }

    Metro.Component('activity', {
        init: function( options, elem ) {
            this._super(elem, options, ActivityDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i, wrap;

            element
                .html('')
                .addClass(o.style + "-style")
                .addClass("activity-" + o.type);

            function _metro(){
                for(i = 0; i < 5 ; i++) {
                    $("<div/>").addClass('circle').appendTo(element);
                }
            }

            function _square(){
                for(i = 0; i < 4 ; i++) {
                    $("<div/>").addClass('square').appendTo(element);
                }
            }

            function _cycle(){
                $("<div/>").addClass('cycle').appendTo(element);
            }

            function _ring(){
                for(i = 0; i < 5 ; i++) {
                    wrap = $("<div/>").addClass('wrap').appendTo(element);
                    $("<div/>").addClass('circle').appendTo(wrap);
                }
            }

            function _simple(){
                $('<svg class="circular"><circle class="path" cx="'+o.size/2+'" cy="'+o.size/2+'" r="'+o.radius+'" fill="none" stroke-width="2" stroke-miterlimit="10"/></svg>').appendTo(element);
            }

            switch (o.type) {
                case 'metro': _metro(); break;
                case 'square': _square(); break;
                case 'cycle': _cycle(); break;
                case 'simple': _simple(); break;
                default: _ring();
            }

            this._fireEvent("activity-create", {
                element: element
            })
        },

        /*eslint-disable-next-line*/
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.activity = {
        open: function(options){
            var o = options || {};
            var activity = '<div data-role="activity" data-type="'+( o.type ? o.type : 'cycle' )+'" data-style="'+( o.style ? o.style : 'color' )+'"></div>';
            var text = o.text ? '<div class="text-center">'+o.text+'</div>' : '';

            return Metro.dialog.create({
                content: activity + text,
                defaultAction: false,
                clsContent: "d-flex flex-column flex-justify-center flex-align-center bg-transparent no-shadow w-auto",
                clsDialog: "no-border no-shadow bg-transparent global-dialog",
                autoHide: o.autoHide ? o.autoHide : 0,
                overlayClickClose: o.overlayClickClose === true,
                overlayColor: o.overlayColor ? o.overlayColor : '#000000',
                overlayAlpha: o.overlayAlpha ? o.overlayAlpha : 0.5,
                clsOverlay: "global-overlay"
            });
        },

        close: function(a){
            Metro.dialog.close(a);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AdblockDefaultConfig = {
        adblockDeferred: 0,
        checkInterval: 1000,
        fireOnce: true,
        checkStop: 10,
        localhost: false,
        localhostPattern: null,
        onAlert: Metro.noop,
        onFishingStart: Metro.noop,
        onFishingDone: Metro.noop
    };

    Metro.adblockSetup = function(options){
        AdblockDefaultConfig = $.extend({}, AdblockDefaultConfig, options);
    };

    if (typeof window["metroAdblockSetup"] !== undefined) {
        Metro.adblockSetup(window["metroAdblockSetup"]);
    }

    var Adblock = {
        bite: function(){
            var classes = "adblock-bite adsense google-adsense dblclick advert topad top_ads topAds textads sponsoredtextlink_container show_ads right-banner rekl mpu module-ad mid_ad mediaget horizontal_ad headerAd contentAd brand-link bottombanner bottom_ad_block block_ad bannertop banner-right banner-body b-banner b-article-aside__banner b-advert adwrapper adverts advertisment advertisement:not(body) advertise advert_list adtable adsense adpic adlist adleft adinfo adi adholder adframe addiv ad_text ad_space ad_right ad_links ad_body ad_block ad_Right adTitle adText";
            $("<div>")
                .addClass(classes.split(" ").shuffle().join(" "))
                .css({
                    position: "fixed",
                    height: 1,
                    width: 1,
                    overflow: "hidden",
                    visibility: "visible",
                    top: 0,
                    left: 0
                })
                .append($("<a href='https://dblclick.net'>").html('dblclick.net'))
                .appendTo('body');

            if (Adblock.options.adblockDeferred) {
                setTimeout(function () {
                    Adblock.fishing();
                }, Adblock.options.adblockDeferred);
            } else this.fishing();
        },

        fishing: function(){
            var o = Adblock.options;
            var checks = typeof o.fireOnce === "number" ? o.fireOnce : 0;
            var checkStop = o.checkStop;
            var interval = false;
            var run = function(){
                var a = $(".adsense.google-adsense.dblclick.advert.adblock-bite");
                var b = a.find("a");
                var done = function(){
                    clearInterval(interval);

                    Utils.exec(o.onFishingDone);
                    $(window).fire("fishing-done");

                    a.remove();
                };

                if (!o.localhost && Utils.isLocalhost(o.localhostPattern)) {
                    done();
                    return ;
                }

                if (   !a.length
                    || !b.length
                    || a.css("display").indexOf('none') > -1
                    || b.css("display").indexOf('none') > -1
                ) {

                    Utils.exec(Adblock.options.onAlert);
                    $(window).fire("adblock-alert");

                    if (Adblock.options.fireOnce === true) {
                        done();
                    } else {
                        checks--;
                        if (checks === 0) {
                            done();
                        }
                    }
                } else {
                    if (checkStop !== false) {
                        checkStop--;
                        if (checkStop === 0) {
                            done();
                        }
                    }
                }
            };

            Utils.exec(o.onFishingStart);
            $(window).fire("fishing-start");

            interval = setInterval(function(){
                run();
            }, Adblock.options.checkInterval);

            run();
        }
    };

    Metro.Adblock = Adblock;

    $(function(){
        Adblock.options = $.extend({}, AdblockDefaultConfig);
        $(window).on("metro-initiated", function(){
            Adblock.bite();
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Colors = Metro.colors;
    var Utils = Metro.utils;
    var AppBarDefaultConfig = {
        appbarDeferred: 0,
        expand: false,
        expandPoint: null,
        duration: 100,
        onMenuOpen: Metro.noop,
        onMenuClose: Metro.noop,
        onMenuCollapse: Metro.noop,
        onMenuExpand: Metro.noop,
        onAppBarCreate: Metro.noop
    };

    Metro.appBarSetup = function (options) {
        AppBarDefaultConfig = $.extend({}, AppBarDefaultConfig, options);
    };

    if (typeof window["metroAppBarSetup"] !== undefined) {
        Metro.appBarSetup(window["metroAppBarSetup"]);
    }

    Metro.Component('app-bar', {
        init: function (options, elem) {
            this._super(elem, options, AppBarDefaultConfig, {
                id: Utils.elementId('app-bar')
            });

            return this;
        },

        _create: function () {
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("app-bar-create", {
                element: element
            })
        },

        _createStructure: function () {
            var element = this.element, o = this.options;
            var hamburger, menu;

            element.addClass("app-bar");

            hamburger = element.find(".hamburger");
            if (hamburger.length === 0) {
                hamburger = $("<button>").attr("type", "button").addClass("hamburger menu-down");
                for (var i = 0; i < 3; i++) {
                    $("<span>").addClass("line").appendTo(hamburger);
                }

                if (Colors.isLight(Utils.computedRgbToHex(Utils.getStyleOne(element, "background-color"))) === true) {
                    hamburger.addClass("dark");
                }
            }

            element.prepend(hamburger);
            menu = element.find(".app-bar-menu");

            if (menu.length === 0) {
                hamburger.css("display", "none");
            } else {
                Utils.addCssRule(Metro.sheet, ".app-bar-menu li", "list-style: none!important;"); // This special for IE11 and Edge
            }

            if (hamburger.css('display') === 'block') {
                menu.hide().addClass("collapsed");
                hamburger.removeClass("hidden");
            } else {
                hamburger.addClass("hidden");
            }

            if (o.expand === true) {
                element.addClass("app-bar-expand");
                hamburger.addClass("hidden");
            } else {
                if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint)) {
                    element.addClass("app-bar-expand");
                    hamburger.addClass("hidden");
                }
            }
        },

        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            element.on(Metro.events.click, ".hamburger", function () {
                if (menu.length === 0) return;
                var collapsed = menu.hasClass("collapsed");
                if (collapsed) {
                    that.open();
                } else {
                    that.close();
                }
            });

            $(window).on(Metro.events.resize, function () {

                if (o.expand !== true) {
                    if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint)) {
                        element.addClass("app-bar-expand");
                        that._fireEvent("menu-expand");
                    } else {
                        element.removeClass("app-bar-expand");
                        that._fireEvent("menu-collapse");
                    }
                }

                if (menu.length === 0) return;

                if (hamburger.css('display') !== 'block') {
                    menu.show(function () {
                        $(this).removeStyleProperty("display");
                    });
                    hamburger.addClass("hidden");
                } else {
                    hamburger.removeClass("hidden");
                    if (hamburger.hasClass("active")) {
                        menu.show().removeClass("collapsed");
                    } else {
                        menu.hide().addClass("collapsed");
                    }
                }
            }, {ns: this.id});
        },

        close: function () {
            var element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            menu.slideUp(o.duration, function () {
                menu.addClass("collapsed").removeClass("opened");
                hamburger.removeClass("active");
            });

            this._fireEvent("menu-close", {
                menu: menu[0]
            });
        },

        open: function () {
            var element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            menu.slideDown(o.duration, function () {
                menu.removeClass("collapsed").addClass("opened");
                hamburger.addClass("active");
            });

            this._fireEvent("menu-open", {
                menu: menu[0]
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function (attributeName) {
        },

        destroy: function () {
            var element = this.element;
            element.off(Metro.events.click, ".hamburger");
            $(window).off(Metro.events.resize, {ns: this.id});
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AudioButtonDefaultConfig = {
        audioVolume: 0.5,
        audioSrc: "",
        onAudioStart: Metro.noop,
        onAudioEnd: Metro.noop,
        onAudioButtonCreate: Metro.noop
    };

    Metro.audioButtonSetup = function (options) {
        AudioButtonDefaultConfig = $.extend({}, AudioButtonDefaultConfig, options);
    };

    if (typeof window["metroAudioButtonSetup"] !== undefined) {
        Metro.audioButtonSetup(window["metroAudioButtonSetup"]);
    }

    Metro.Component('audio-button', {
        init: function( options, elem ) {

            this._super(elem, options, AudioButtonDefaultConfig, {
                audio: null,
                canPlay: null,
                id: Utils.elementId("audioButton")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent('audioButtonCreate', {
                element: element
            });
        },

        _createStructure: function(){
            var o = this.options;
            this.audio = new Audio(o.audioSrc);
            this.audio.volume = o.audioVolume;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var audio = this.audio;

            audio.addEventListener('loadeddata', function(){
                that.canPlay = true;
            });

            audio.addEventListener('ended', function(){
                that._fireEvent("audioEnd", {
                    src: o.audioSrc,
                    audio: audio
                });
            })

            element.on(Metro.events.click, function(){
                that.play();
            }, {ns: this.id});
        },

        play: function(cb){
            var element = this.element, o = this.options;
            var audio = this.audio;

            if (o.audioSrc !== "" && this.audio.duration && this.canPlay) {

                this._fireEvent("audioStart", {
                    src: o.audioSrc,
                    audio: audio
                });

                audio.pause();
                audio.currentTime = 0;
                audio.play();

                Utils.exec(cb, [audio], element[0]);
            }
        },

        stop: function(cb){
            var element = this.element, o = this.options;
            var audio = this.audio;

            audio.pause();
            audio.currentTime = 0;

            this._fireEvent("audioEnd", {
                src: o.audioSrc,
                audio: audio
            });

            Utils.exec(cb, [audio], element[0]);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var audio = this.audio;

            var changeSrc = function(){
                var src = element.attr('data-audio-src');
                if (src && src.trim() !== "") {
                    o.audioSrc = src;
                    audio.src = src;
                }
            }

            var changeVolume = function(){
                var volume = parseFloat(element.attr('data-audio-volume'));
                if (isNaN(volume)) {
                    return ;
                }
                o.audioVolume = volume;
                audio.volume = volume;
            }

            if (attributeName === 'data-audio-src') {
                changeSrc();
            }

            if (attributeName === 'data-audio-volume') {
                changeVolume();
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, {ns: this.id});
        }
    });

    Metro["playSound"] = function(data){
        var audio;
        var src = typeof data === "string" ? data : data.audioSrc;
        var volume = data && data.audioVolume ? data.audioVolume : 0.5;

        if (!src) {
            return;
        }

        audio = new Audio(src);
        audio.volume = parseFloat(volume);

        audio.addEventListener('loadeddata', function(){
            if (data && data.onAudioStart)
                Utils.exec(data.onAudioStart, [src], this);
            this.play();
        });

        audio.addEventListener('ended', function(){
            if (data && data.onAudioEnd)
                Utils.exec(data.onAudioEnd, [null], this);
        });
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AudioPlayerDefaultConfig = {
        audioDeferred: 0,
        playlist: null,
        src: null,

        volume: .5,
        loop: false,
        autoplay: false,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        showPlaylist: true,
        showNext: true,
        showPrev: true,
        showFirst: true,
        showLast: true,
        showForward: true,
        showBackward: true,
        showShuffle: true,
        showRandom: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",

        playlistIcon: "<span class='default-icon-playlist'></span>",
        nextIcon: "<span class='default-icon-next'></span>",
        prevIcon: "<span class='default-icon-prev'></span>",
        firstIcon: "<span class='default-icon-first'></span>",
        lastIcon: "<span class='default-icon-last'></span>",
        forwardIcon: "<span class='default-icon-forward'></span>",
        backwardIcon: "<span class='default-icon-backward'></span>",
        shuffleIcon: "<span class='default-icon-shuffle'></span>",
        randomIcon: "<span class='default-icon-random'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onAudioPlayerCreate: Metro.noop
    };

    Metro.audioPlayerSetup = function(options){
        AudioPlayerDefaultConfig = $.extend({}, AudioPlayerDefaultConfig, options);
    };

    if (typeof window["metroAudioPlayerSetup"] !== undefined) {
        Metro.audioPlayerSetup(window["metroAudioPlayerSetup"]);
    }

    Metro.Component('audio-player', {
        init: function( options, elem ) {
            this._super(elem, options, AudioPlayerDefaultConfig, {
                preloader: null,
                player: null,
                audio: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createPlayer();
            this._createControls();
            this._createEvents();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("audio-player-create", {
                element: element,
                player: this.player
            })
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, audio = this.audio;

            var prev = element.prev();
            var parent = element.parent();
            var player = $("<div>").addClass("media-player audio-player " + element[0].className);

            if (prev.length === 0) {
                parent.prepend(player);
            } else {
                player.insertAfter(prev);
            }

            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            audio.volume = o.volume;

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);


            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
            var preloader = $("<div>").addClass("load-audio").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            preloader.activity({
                type: "metro",
                style: "color"
            });

            preloader.hide(0);

            this.preloader = preloader;

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!audio.paused) audio.pause();
                },
                onStop: function(val){
                    if (audio.seekable.length > 0) {
                        audio.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (audio.paused && audio.currentTime > 0) {
                        audio.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    audio.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = audio.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                audio.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.fadeIn();
            });

            element.on("loadedmetadata", function(){
                that.duration = audio.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [audio, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.fadeOut();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(audio.currentTime * 100 / that.duration);
                that._setInfo(audio.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [audio.currentTime, that.duration, audio, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.fadeIn();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [audio, player], element[0]);
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [audio, player], element[0]);
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [audio, player], element[0]);
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [audio, player], element[0]);
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (audio.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.audio.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.audio.volume;
                this.audio.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.audio.buffered.length ? Math.round(Math.floor(this.audio.buffered.end(0)) / Math.floor(this.audio.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var audio = this.audio, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = audio.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.audio.play();
        },

        pause: function(){
            this.audio.pause();
        },

        resume: function(){
            if (this.audio.paused) {
                this.play();
            }
        },

        stop: function(){
            this.audio.pause();
            this.audio.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.audio.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.audio.volume = v;
            Metro.getPlugin(this.volume, 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            element.off("all");
            player.off("all");

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var BottomSheetDefaultConfig = {
        bottomsheetDeferred: 0,
        mode: "list",
        toggle: null,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onBottomSheetCreate: Metro.noop
    };

    Metro.bottomSheetSetup = function(options){
        BottomSheetDefaultConfig = $.extend({}, BottomSheetDefaultConfig, options);
    };

    if (typeof window["metroBottomSheetSetup"] !== undefined) {
        Metro.bottomSheetSetup(window["metroBottomSheetSetup"]);
    }

    Metro.Component('bottom-sheet', {
        init: function( options, elem ) {
            this._super(elem, options, BottomSheetDefaultConfig, {
                toggle: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("bottom-sheet-create", {
                element: element
            })
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element
                .addClass("bottom-sheet")
                .addClass(o.mode+"-list");

            if (Utils.isValue(o.toggle) && $(o.toggle).length > 0) {
                this.toggle = $(o.toggle);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element;

            if (Utils.isValue(this.toggle)) {
                this.toggle.on(Metro.events.click, function(){
                    that.toggle();
                });
            }

            element.on(Metro.events.click, "li", function(){
                that.close();
            });
        },

        isOpen: function(){
            return this.element.hasClass("opened");
        },

        open: function(mode){
            var element = this.element;

            if (Utils.isValue(mode)) {
                element.removeClass("list-style grid-style").addClass(mode+"-style");
            }

            this.element.addClass("opened");

            this._fireEvent("open", {
                element: element
            })
        },

        close: function(){
            var element = this.element;

            element.removeClass("opened");

            this._fireEvent("close", {
                element: element
            })
        },

        toggle: function(mode){
            if (this.isOpen()) {
                this.close();
            } else {
                this.open(mode);
            }
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            if (Utils.isValue(this.toggle)) {
                this.toggle.off(Metro.events.click);
            }

            element.off(Metro.events.click, "li");
            return element;
        }
    });

    Metro['bottomsheet'] = {
        isBottomSheet: function(el){
            return Utils.isMetroObject(el, "bottom-sheet");
        },

        open: function(el, as){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            Metro.getPlugin(el, "bottom-sheet").open(as);
        },

        close: function(el){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            Metro.getPlugin(el, "bottom-sheet").close();
        },

        toggle: function(el, as){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            if (this.isOpen(el)) {
                this.close(el);
            } else {
                this.open(el, as);
            }
        },

        isOpen: function(el){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            return Metro.getPlugin(el, "bottom-sheet").isOpen();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ButtonGroupDefaultConfig = {
        buttongroupDeferred: 0,
        targets: "button",
        clsActive: "",
        requiredButton: false,
        mode: Metro.groupMode.ONE,
        onButtonClick: Metro.noop,
        onButtonGroupCreate: Metro.noop
    };

    Metro.buttonGroupSetup = function(options){
        ButtonGroupDefaultConfig = $.extend({}, ButtonGroupDefaultConfig, options);
    };

    if (typeof window["metroButtonGroupSetup"] !== undefined) {
        Metro.buttonGroupSetup(window["metroButtonGroupSetup"]);
    }

    Metro.Component('button-group', {
        init: function( options, elem ) {
            this._super(elem, options, ButtonGroupDefaultConfig, {
                active: null,
                id: Utils.elementId("button-group")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createGroup();
            this._createEvents();

            this._fireEvent("button-group-create", {
                element: element
            })
        },

        _createGroup: function(){
            var element = this.element, o = this.options;
            var buttons, buttons_active;

            element.addClass("button-group");

            buttons = element.find( o.targets );
            buttons_active = element.find( ".active" );

            if (o.mode === Metro.groupMode.ONE && buttons_active.length === 0 && o.requiredButton === true) {
                $(buttons[0]).addClass("active");
            }

            if (o.mode === Metro.groupMode.ONE && buttons_active.length > 1) {
                buttons.removeClass("active").removeClass(o.clsActive);
                $(buttons[0]).addClass("active");
            }

            element
                .find( ".active" )
                .addClass("js-active")
                .addClass(o.clsActive);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, o.targets, function(){
                var el = $(this);

                that._fireEvent("button-click", {
                    button: this
                })

                if (o.mode === Metro.groupMode.ONE && el.hasClass("active")) {
                    return ;
                }

                if (o.mode === Metro.groupMode.ONE) {
                    element.find(o.targets).removeClass(o.clsActive).removeClass("active js-active");
                    el.addClass("active").addClass(o.clsActive).addClass("js-active");
                } else {
                    el.toggleClass("active").toggleClass(o.clsActive).toggleClass("js-active");
                }

            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.click, o.targets);
            return element;
        }

    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarDefaultConfig = {
        calendarDeferred: 0,
        dayBorder: false,
        excludeDay: null,
        prevMonthIcon: "<span class='default-icon-chevron-left'></span>",
        nextMonthIcon: "<span class='default-icon-chevron-right'></span>",
        prevYearIcon: "<span class='default-icon-chevron-left'></span>",
        nextYearIcon: "<span class='default-icon-chevron-right'></span>",
        compact: false,
        wide: false,
        widePoint: null,
        pickerMode: false,
        show: null,
        locale: METRO_LOCALE,
        weekStart: METRO_WEEK_START,
        outside: true,
        buttons: 'cancel, today, clear, done',
        yearsBefore: 100,
        yearsAfter: 100,
        headerFormat: "%A, %b %e",
        showHeader: true,
        showFooter: true,
        showTimeField: true,
        showWeekNumber: false,
        clsCalendar: "",
        clsCalendarHeader: "",
        clsCalendarContent: "",
        clsCalendarFooter: "",
        clsCalendarMonths: "",
        clsCalendarYears: "",
        clsToday: "",
        clsSelected: "",
        clsExcluded: "",
        clsCancelButton: "",
        clsTodayButton: "",
        clsClearButton: "",
        clsDoneButton: "",
        isDialog: false,
        ripple: false,
        rippleColor: "#cccccc",
        exclude: null,
        preset: null,
        minDate: null,
        maxDate: null,
        weekDayClick: false,
        weekNumberClick: false,
        multiSelect: false,
        special: null,
        format: METRO_DATE_FORMAT,
        inputFormat: null,
        onCancel: Metro.noop,
        onToday: Metro.noop,
        onClear: Metro.noop,
        onDone: Metro.noop,
        onDayClick: Metro.noop,
        onDayDraw: Metro.noop,
        onWeekDayClick: Metro.noop,
        onWeekNumberClick: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop,
        onCalendarCreate: Metro.noop
    };

    Metro.calendarSetup = function (options) {
        CalendarDefaultConfig = $.extend({}, CalendarDefaultConfig, options);
    };

    if (typeof window["metroCalendarSetup"] !== undefined) {
        Metro.calendarSetup(window["metroCalendarSetup"]);
    }

    Metro.Component('calendar', {
        init: function( options, elem ) {

            var now = new Date();
            now.setHours(0,0,0,0);

            this._super(elem, options, CalendarDefaultConfig, {
                today: now,
                show: now,
                current: {
                    year: now.getFullYear(),
                    month: now.getMonth(),
                    day: now.getDate()
                },
                preset: [],
                selected: [],
                exclude: [],
                special: [],
                excludeDay: [],
                min: null,
                max: null,
                locale: null,
                minYear: null,
                maxYear: null,
                offset: null,
                id: Utils.elementId("calendar")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.minYear = this.current.year - this.options.yearsBefore;
            this.maxYear = this.current.year + this.options.yearsAfter;
            this.offset = (new Date()).getTimezoneOffset() / 60 + 1;

            element.html("").addClass("calendar " + (o.compact === true ? "compact" : "")).addClass(o.clsCalendar);

            if (o.dayBorder === true) {
                element.addClass("day-border");
            }

            if (Utils.isValue(o.excludeDay)) {
                this.excludeDay = (""+o.excludeDay).toArray(",", "int");
            }

            if (Utils.isValue(o.preset)) {
                this._dates2array(o.preset, 'selected');
            }

            if (Utils.isValue(o.exclude)) {
                this._dates2array(o.exclude, 'exclude');
            }

            if (Utils.isValue(o.special)) {
                this._dates2array(o.special, 'special');
            }

            if (o.buttons !== false) {
                if (Array.isArray(o.buttons) === false) {
                    o.buttons = o.buttons.split(",").map(function(item){
                        return item.trim();
                    });
                }
            }

            if (o.minDate !== null && Utils.isDate(o.minDate, o.inputFormat)) {
                this.min = Utils.isValue(o.inputFormat) ? o.minDate.toDate(o.inputFormat) : (new Date(o.minDate));
            }

            if (o.maxDate !== null && Utils.isDate(o.maxDate, o.inputFormat)) {
                this.max = Utils.isValue(o.inputFormat) ? o.maxDate.toDate(o.inputFormat) : (new Date(o.maxDate));
            }

            if (o.show !== null && Utils.isDate(o.show, o.inputFormat)) {
                this.show = Utils.isValue(o.inputFormat) ? o.show.toDate(o.inputFormat) : (new Date(o.show));
                this.show.setHours(0,0,0,0);
                this.current = {
                    year: this.show.getFullYear(),
                    month: this.show.getMonth(),
                    day: this.show.getDate()
                }
            }

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this._drawCalendar();
            this._createEvents();

            if (o.wide === true) {
                element.addClass("calendar-wide");
            } else {
                if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                    element.addClass("calendar-wide");
                }
            }


            if (o.ripple === true && Utils.isFunc(element.ripple) !== false) {
                element.ripple({
                    rippleTarget: ".button, .prev-month, .next-month, .prev-year, .next-year, .day",
                    rippleColor: this.options.rippleColor
                });
            }

            this._fireEvent("calendar-create");
        },

        _dates2array: function(val, category){
            var that = this, o = this.options;
            var dates;

            if (Utils.isNull(val)) {
                return ;
            }

            dates = typeof val === 'string' ? val.toArray() : val;

            $.each(dates, function(){
                var _d;

                if (!Utils.isDateObject(this)) {
                    _d = Utils.isValue(o.inputFormat) ? this.toDate(o.inputFormat) : new Date(this);
                    if (Utils.isDate(_d) === false) {
                        return ;
                    }
                    _d.setHours(0,0,0,0);
                } else {
                    _d = this;
                }

                that[category].push(_d.getTime());
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $(window).on(Metro.events.resize, function(){
                if (o.wide !== true) {
                    if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                        element.addClass("calendar-wide");
                    } else {
                        element.removeClass("calendar-wide");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, function(){
                var months = element.find(".calendar-months");
                var years = element.find(".calendar-years");
                if (months.hasClass("open")) {
                    months.removeClass("open");
                }
                if (years.hasClass("open")) {
                    years.removeClass("open");
                }
            });

            element.on(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year", function(){
                var new_date, el = $(this);

                if (el.hasClass("prev-month")) {
                    new_date = new Date(that.current.year, that.current.month - 1, 1);
                    if (new_date.getFullYear() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-month")) {
                    new_date = new Date(that.current.year, that.current.month + 1, 1);
                    if (new_date.getFullYear() > that.maxYear) {
                        return ;
                    }
                }
                if (el.hasClass("prev-year")) {
                    new_date = new Date(that.current.year - 1, that.current.month, 1);
                    if (new_date.getFullYear() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-year")) {
                    new_date = new Date(that.current.year + 1, that.current.month, 1);
                    if (new_date.getFullYear() > that.maxYear) {
                        return ;
                    }
                }

                that.current = {
                    year: new_date.getFullYear(),
                    month: new_date.getMonth(),
                    day: new_date.getDate()
                };
                setTimeout(function(){
                    that._drawContent();
                    if (el.hasClass("prev-month") || el.hasClass("next-month")) {
                        that._fireEvent("month-change", {
                            current: that.current
                        });
                    }
                    if (el.hasClass("prev-year") || el.hasClass("next-year")) {
                        that._fireEvent("year-change", {
                            current: that.current
                        });
                    }
                }, o.ripple ? 300 : 1);
            });

            element.on(Metro.events.click, ".button.today", function(){
                that.toDay();
                that._fireEvent("today", {
                    today: that.today
                });
            });

            element.on(Metro.events.click, ".button.clear", function(){
                that.selected = [];
                that._drawContent();
                that._fireEvent("clear");
            });

            element.on(Metro.events.click, ".button.cancel", function(){
                that._drawContent();
                that._fireEvent("cancel");
            });

            element.on(Metro.events.click, ".button.done", function(){
                that._drawContent();
                that._fireEvent("done");
            });

            if (o.weekDayClick === true) {
                element.on(Metro.events.click, ".week-days .day", function (e) {
                    var day, index, days;

                    day = $(this);
                    index = day.index();

                    if (o.multiSelect === true) {
                        days = o.outside === true ? element.find(".days-row .day:nth-child(" + (index + 1) + ")") : element.find(".days-row .day:not(.outside):nth-child(" + (index + 1) + ")");
                        $.each(days, function () {
                            var d = $(this);
                            var dd = d.data('day');

                            if (d.hasClass("disabled") || d.hasClass("excluded")) return;

                            if (!that.selected.contains(dd))
                                that.selected.push(dd);
                            d.addClass("selected").addClass(o.clsSelected);
                        });
                    }

                    that._fireEvent("week-day-click", {
                        selected: that.selected,
                        day: day
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            if (o.weekNumberClick) {
                element.on(Metro.events.click, ".days-row .week-number", function (e) {
                    var weekNumElement, weekNumber, days;

                    weekNumElement = $(this);
                    weekNumber = weekNumElement.text();

                    if (o.multiSelect === true) {
                        days = $(this).siblings(".day");
                        $.each(days, function () {
                            var d = $(this);
                            var dd = d.data('day');

                            if (d.hasClass("disabled") || d.hasClass("excluded")) return;

                            if (!that.selected.contains(dd))
                                that.selected.push(dd);
                            d.addClass("selected").addClass(o.clsSelected);
                        });
                    }

                    that._fireEvent("week-number-click", {
                        selected: that.selected,
                        num: weekNumber,
                        numElement: weekNumElement
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            element.on(Metro.events.click, ".days-row .day", function(e){
                var day = $(this);
                var index, date;

                date = day.data('day');
                index = that.selected.indexOf(date);

                if (day.hasClass("outside")) {
                    date = new Date(date);
                    that.current = {
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        day: date.getDate()
                    };
                    that._drawContent();

                    that._fireEvent("month-change", {
                        current: that.current
                    });

                    return ;
                }

                if (!day.hasClass("disabled")) {

                    if (o.pickerMode === true) {
                        that.selected = [date];
                        that.today = new Date(date);
                        that.current.year = that.today.getFullYear();
                        that.current.month = that.today.getMonth();
                        that.current.day = that.today.getDate();
                        that._drawHeader();
                        that._drawContent();
                    } else {
                        if (index === -1) {
                            if (o.multiSelect === false) {
                                element.find(".days-row .day").removeClass("selected").removeClass(o.clsSelected);
                                that.selected = [];
                            }
                            that.selected.push(date);
                            day.addClass("selected").addClass(o.clsSelected);
                        } else {
                            day.removeClass("selected").removeClass(o.clsSelected);
                            Utils.arrayDelete(that.selected, date);
                        }
                    }

                }

                that._fireEvent("day-click", {
                    selected: that.selected,
                    day: day
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-month", function(e){
                var target;
                var list = element.find(".months-list");

                list.find(".active").removeClass("active");
                list.scrollTop(0);
                element.find(".calendar-months").addClass("open");

                target = list.find(".js-month-"+that.current.month).addClass("active");

                setTimeout(function(){
                    list.animate({
                        draw: {
                            scrollTop: target.position().top - ( (list.height() - target.height() )/ 2)
                        },
                        dur: 200
                    })
                }, 300);

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".calendar-months li", function(e){
                that.current.month = $(this).index();
                that._drawContent();
                element.find(".calendar-months").removeClass("open");

                that._fireEvent("month-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-year", function(e){
                var target;
                var list = element.find(".years-list");

                list.find(".active").removeClass("active");
                list.scrollTop(0);
                element.find(".calendar-years").addClass("open");

                target = list.find(".js-year-"+that.current.year).addClass("active");

                setTimeout(function(){
                    list.animate({
                        draw: {
                            scrollTop: target.position().top - ( (list.height() - target.height() )/ 2)
                        },
                        dur: 200
                    })
                }, 300);

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".calendar-years li", function(e){
                that.current.year = $(this).text();
                that._drawContent();
                element.find(".calendar-years").removeClass("open");

                that._fireEvent("year-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });
        },

        _drawHeader: function(){
            var element = this.element, o = this.options;
            var header = element.find(".calendar-header");

            if (header.length === 0) {
                header = $("<div>").addClass("calendar-header").addClass(o.clsCalendarHeader).appendTo(element);
            }

            header.html("");

            $("<div>").addClass("header-year").html(this.today.getFullYear()).appendTo(header);
            $("<div>").addClass("header-day").html(this.today.format(o.headerFormat, o.locale)).appendTo(header);

            if (o.showHeader === false) {
                header.hide();
            }
        },

        _drawFooter: function(){
            var element = this.element, o = this.options;
            var buttons_locale = this.locale['buttons'];
            var footer = element.find(".calendar-footer");

            if (o.buttons === false) {
                return ;
            }

            if (footer.length === 0) {
                footer = $("<div>").addClass("calendar-footer").addClass(o.clsCalendarFooter).appendTo(element);
            }

            footer.html("");

            $.each(o.buttons, function(){
                var button = $("<button>").attr("type", "button").addClass("button " + this + " " + o['cls'+this.capitalize()+'Button']).html(buttons_locale[this]).appendTo(footer);
                if (this === 'cancel' || this === 'done') {
                    button.addClass("js-dialog-close");
                }
            });

            if (o.showFooter === false) {
                footer.hide();
            }
        },

        _drawMonths: function(){
            var element = this.element, o = this.options;
            var months = $("<div>").addClass("calendar-months").addClass(o.clsCalendarMonths).appendTo(element);
            var list = $("<ul>").addClass("months-list").appendTo(months);
            var calendar_locale = this.locale['calendar'];
            var i;
            for(i = 0; i < 12; i++) {
                $("<li>").addClass("js-month-"+i).html(calendar_locale['months'][i]).appendTo(list);
            }
        },

        _drawYears: function(){
            var element = this.element, o = this.options;
            var years = $("<div>").addClass("calendar-years").addClass(o.clsCalendarYears).appendTo(element);
            var list = $("<ul>").addClass("years-list").appendTo(years);
            var i;
            for(i = this.minYear; i <= this.maxYear; i++) {
                $("<li>").addClass("js-year-"+i).html(i).appendTo(list);
            }
        },

        _drawContent: function(){
            var element = this.element, o = this.options;
            var content = element.find(".calendar-content"), toolbar;
            var calendar_locale = this.locale['calendar'];
            var i, j, d, s, counter = 0;
            var first = new Date(this.current.year, this.current.month, 1);
            var first_day;
            var prev_month_days = (new Date(this.current.year, this.current.month, 0)).getDate();
            var year, month;

            if (content.length === 0) {
                content = $("<div>").addClass("calendar-content").addClass(o.clsCalendarContent).appendTo(element);
            }

            content.html("");

            toolbar = $("<div>").addClass("calendar-toolbar").appendTo(content);

            /**
             * Calendar toolbar
             */
            $("<span>").addClass("prev-month").html(o.prevMonthIcon).appendTo(toolbar);
            $("<span>").addClass("curr-month").html(calendar_locale['months'][this.current.month]).appendTo(toolbar);
            $("<span>").addClass("next-month").html(o.nextMonthIcon).appendTo(toolbar);

            $("<span>").addClass("prev-year").html(o.prevYearIcon).appendTo(toolbar);
            $("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
            $("<span>").addClass("next-year").html(o.nextYearIcon).appendTo(toolbar);

            /**
             * Week days
             */
            var week_days = $("<div>").addClass("week-days").appendTo(content);
            var day_class = "day";

            if (o.showWeekNumber === true) {
                $("<span>").addClass("week-number").html("#").appendTo(week_days);
                day_class += " and-week-number";
            }

            for (i = 0; i < 7; i++) {
                if (o.weekStart === 0) {
                    j = i;
                } else {
                    j = i + 1;
                    if (j === 7) j = 0;
                }
                $("<span>").addClass(day_class).html(calendar_locale["days"][j + 7]).appendTo(week_days);
            }

            /**
             * Calendar days
             */
            var days = $("<div>").addClass("days").appendTo(content);
            var days_row = $("<div>").addClass("days-row").appendTo(days);

            first_day = o.weekStart === 0 ? first.getDay() : (first.getDay() === 0 ? 6 : first.getDay() - 1);

            if (this.current.month - 1 < 0) {
                month = 11;
                year = this.current.year - 1;
            } else {
                month = this.current.month - 1;
                year = this.current.year;
            }

            if (o.showWeekNumber === true) {
                $("<div>").addClass("week-number").html((new Date(year, month, prev_month_days - first_day + 1)).getWeek(o.weekStart)).appendTo(days_row);
            }

            for(i = 0; i < first_day; i++) {
                var v = prev_month_days - first_day + i + 1;
                d = $("<div>").addClass(day_class+" outside").appendTo(days_row);

                s = new Date(year, month, v);
                s.setHours(0,0,0,0);

                d.data('day', s.getTime());

                if (o.outside === true) {
                    d.html(v);

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(s.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }

                    this._fireEvent("day-draw", {
                        date: s,
                        cell: d[0]
                    });
                }

                counter++;
            }

            first.setHours(0,0,0,0);
            while(first.getMonth() === this.current.month) {

                d = $("<div>").addClass(day_class).html(first.getDate()).appendTo(days_row);

                d.data('day', first.getTime());

                if (this.show.getTime() === first.getTime()) {
                    d.addClass("showed");
                }

                if (this.today.getTime() === first.getTime()) {
                    d.addClass("today").addClass(o.clsToday);
                }

                if (this.special.length === 0) {

                    if (this.selected.indexOf(first.getTime()) !== -1) {
                        d.addClass("selected").addClass(o.clsSelected);
                    }
                    if (this.exclude.indexOf(first.getTime()) !== -1) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                    if (this.min !== null && first.getTime() < this.min.getTime()) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }
                    if (this.max !== null && first.getTime() > this.max.getTime()) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(first.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }
                } else {

                    if (this.special.indexOf(first.getTime()) === -1) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                }

                this._fireEvent("day-draw", {
                    date: first,
                    cell: d[0]
                });

                counter++;
                if (counter % 7 === 0) {
                    days_row = $("<div>").addClass("days-row").appendTo(days);
                    if (o.showWeekNumber === true) {
                        $("<div>").addClass("week-number").html((new Date(first.getFullYear(), first.getMonth(), first.getDate() + 1)).getWeek(o.weekStart)).appendTo(days_row);
                    }
                }
                first.setDate(first.getDate() + 1);
                first.setHours(0,0,0,0);
            }

            first_day = o.weekStart === 0 ? first.getDay() : (first.getDay() === 0 ? 6 : first.getDay() - 1);

            if (this.current.month + 1 > 11) {
                month = 0;
                year = this.current.year + 1;
            } else {
                month = this.current.month + 1;
                year = this.current.year;
            }

            if (first_day > 0) for(i = 0; i < 7 - first_day; i++) {
                d = $("<div>").addClass(day_class+" outside").appendTo(days_row);
                s = new Date(year, month, i + 1);
                s.setHours(0,0,0,0);
                d.data('day', s.getTime());
                if (o.outside === true) {
                    d.html(i + 1);

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(s.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }

                    this._fireEvent("day-draw", {
                        date: s,
                        cell: d[0]
                    });

                }
            }
        },

        _drawCalendar: function(){
            var that = this;
            setTimeout(function(){
                that.element.html("");
                that._drawHeader();
                that._drawContent();
                that._drawFooter();
                that._drawMonths();
                that._drawYears();
            }, 0);
        },

        getPreset: function(){
            return this.preset;
        },

        getSelected: function(){
            return this.selected;
        },

        getExcluded: function(){
            return this.exclude;
        },

        getToday: function(){
            return this.today;
        },

        getCurrent: function(){
            return this.current;
        },

        clearSelected: function(){
            this.selected = [];
            this._drawContent();
        },

        toDay: function(){
            this.today = new Date();
            this.today.setHours(0,0,0,0);
            this.current = {
                year: this.today.getFullYear(),
                month: this.today.getMonth(),
                day: this.today.getDate()
            };
            this._drawHeader();
            this._drawContent();
        },

        setExclude: function(exclude){
            var element = this.element, o = this.options;
            if (Utils.isNull(exclude) && Utils.isNull(element.attr("data-exclude"))) {
                return ;
            }
            o.exclude = !Utils.isNull(exclude) ? exclude : element.attr("data-exclude");
            this._dates2array(o.exclude, 'exclude');
            this._drawContent();
        },

        setPreset: function(preset){
            var element = this.element, o = this.options;
            if (Utils.isNull(preset) && Utils.isNull(element.attr("data-preset"))) {
                return ;
            }

            o.preset = !Utils.isNull(preset) ? preset : element.attr("data-preset");
            this._dates2array(o.preset, 'selected');
            this._drawContent();
        },

        setSpecial: function(special){
            var element = this.element, o = this.options;
            if (Utils.isNull(special) && Utils.isNull(element.attr("data-special"))) {
                return ;
            }
            o.special = !Utils.isNull(special) ? special : element.attr("data-special");
            this._dates2array(o.exclude, 'special');
            this._drawContent();
        },

        setShow: function(show){
            var element = this.element, o = this.options;

            if (Utils.isNull(show) && Utils.isNull(element.attr("data-show"))) {
                return ;
            }
            o.show = !Utils.isNull(show) ? show : element.attr("data-show");

            this.show = Utils.isDateObject(show) ? show : Utils.isValue(o.inputFormat) ? o.show.toDate(o.inputFormat) : new Date(o.show);
            this.show.setHours(0,0,0,0);
            this.current = {
                year: this.show.getFullYear(),
                month: this.show.getMonth(),
                day: this.show.getDate()
            };

            this._drawContent();
        },

        setMinDate: function(date){
            var element = this.element, o = this.options;

            o.minDate = Utils.isValue(date) ? date : element.attr("data-min-date");
            if (Utils.isValue(o.minDate) && Utils.isDate(o.minDate, o.inputFormat)) {
                this.min = Utils.isValue(o.inputFormat) ? o.minDate.toDate(o.inputFormat) : (new Date(o.minDate));
            }

            this._drawContent();
        },

        setMaxDate: function(date){
            var element = this.element, o = this.options;

            o.maxDate = Utils.isValue(date) ? date : element.attr("data-max-date");
            if (Utils.isValue(o.maxDate) && Utils.isDate(o.maxDate, o.inputFormat)) {
                this.max = Utils.isValue(o.inputFormat) ? o.maxDate.toDate(o.inputFormat) : (new Date(o.maxDate));
            }

            this._drawContent();
        },

        setToday: function(val){
            var o = this.options;

            if (!Utils.isValue(val)) {
                val = new Date();
            }
            this.today = Utils.isDateObject(val) ? val : Utils.isValue(o.inputFormat) ? val.toDate(o.inputFormat) : new Date(val);
            this.today.setHours(0,0,0,0);
            this._drawHeader();
            this._drawContent();
        },

        i18n: function(val){
            var o = this.options;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];
            this._drawCalendar();
        },

        changeAttrLocale: function(){
            var element = this.element;
            this.i18n(element.attr("data-locale"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-exclude': this.setExclude(); break;
                case 'data-preset': this.setPreset(); break;
                case 'data-special': this.setSpecial(); break;
                case 'data-show': this.setShow(); break;
                case 'data-min-date': this.setMinDate(); break;
                case 'data-max-date': this.setMaxDate(); break;
                case 'data-locale': this.changeAttrLocale(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year");
            element.off(Metro.events.click, ".button.today");
            element.off(Metro.events.click, ".button.clear");
            element.off(Metro.events.click, ".button.cancel");
            element.off(Metro.events.click, ".button.done");
            element.off(Metro.events.click, ".week-days .day");
            element.off(Metro.events.click, ".days-row .day");
            element.off(Metro.events.click, ".curr-month");
            element.off(Metro.events.click, ".calendar-months li");
            element.off(Metro.events.click, ".curr-year");
            element.off(Metro.events.click, ".calendar-years li");
            element.off(Metro.events.click);

            if (o.ripple === true) {
                element.data("ripple").destroy();
            }

            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.calendar .calendar-years').each(function(){
            $(this).removeClass("open");
        });
        $('.calendar .calendar-months').each(function(){
            $(this).removeClass("open");
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarPickerDefaultConfig = {
        label: "",
        value:'',
        calendarpickerDeferred: 0,
        nullValue: true,
        useNow: false,

        prepend: "",

        calendarWide: false,
        calendarWidePoint: null,


        dialogMode: false,
        dialogPoint: 640,
        dialogOverlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,

        locale: METRO_LOCALE,
        size: "100%",
        format: METRO_DATE_FORMAT,
        inputFormat: null,
        headerFormat: "%A, %b %e",
        clearButton: false,
        calendarButtonIcon: "<span class='default-icon-calendar'></span>",
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        copyInlineStyles: false,
        clsPicker: "",
        clsInput: "",

        yearsBefore: 100,
        yearsAfter: 100,
        weekStart: METRO_WEEK_START,
        outside: true,
        ripple: false,
        rippleColor: "#cccccc",
        exclude: null,
        minDate: null,
        maxDate: null,
        special: null,
        showHeader: true,

        showWeekNumber: false,

        clsCalendar: "",
        clsCalendarHeader: "",
        clsCalendarContent: "",
        clsCalendarMonths: "",
        clsCalendarYears: "",
        clsToday: "",
        clsSelected: "",
        clsExcluded: "",
        clsPrepend: "",
        clsLabel: "",

        onDayClick: Metro.noop,
        onCalendarPickerCreate: Metro.noop,
        onCalendarShow: Metro.noop,
        onCalendarHide: Metro.noop,
        onChange: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop
    };

    Metro.calendarPickerSetup = function (options) {
        CalendarPickerDefaultConfig = $.extend({}, CalendarPickerDefaultConfig, options);
    };

    if (typeof window["metroCalendarPickerSetup"] !== undefined) {
        Metro.calendarPickerSetup(window["metroCalendarPickerSetup"]);
    }

    Metro.Component('calendar-picker', {
        init: function( options, elem ) {
            this._super(elem, options, CalendarPickerDefaultConfig, {
                value: null,
                value_date: null,
                calendar: null,
                overlay: null,
                id: Utils.elementId("calendar-picker")
            });

            return this;
        },

        _create: function(){

            this._createStructure();
            this._createEvents();

            this._fireEvent("calendar-picker-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className + " calendar-picker");
            var buttons = $("<div>").addClass("button-group");
            var calendarButton, clearButton, cal = $("<div>").addClass("drop-shadow");
            var curr;
            var body = $("body");

            element.attr("type", "text");
            element.attr("autocomplete", "off");
            element.attr("readonly", true);

            curr = (""+o.value).trim() !== '' ? o.value : element.val().trim();

            if (!Utils.isValue(curr)) {
                if (o.useNow) this.value = new Date();
            } else {
                this.value = !Utils.isValue(o.inputFormat) ? new Date(curr) : curr.toDate(o.inputFormat, o.locale);
            }

            if (Utils.isValue(this.value)) this.value.setHours(0,0,0,0);

            element.val(!Utils.isValue(curr) && o.nullValue === true ? "" : that.value.format(o.format, o.locale));

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            cal.appendTo(o.dialogMode ? body : container);

            Metro.makePlugin(cal, "calendar", {
                wide: o.calendarWide,
                widePoint: o.calendarWidePoint,

                format: o.format,
                inputFormat: o.inputFormat,
                pickerMode: true,
                show: o.value,
                locale: o.locale,
                weekStart: o.weekStart,
                outside: o.outside,
                buttons: false,
                headerFormat: o.headerFormat,

                clsCalendar: [o.clsCalendar, "calendar-for-picker", (o.dialogMode ? "dialog-mode":"")].join(" "),
                clsCalendarHeader: o.clsCalendarHeader,
                clsCalendarContent: o.clsCalendarContent,
                clsCalendarFooter: "d-none",
                clsCalendarMonths: o.clsCalendarMonths,
                clsCalendarYears: o.clsCalendarYears,
                clsToday: o.clsToday,
                clsSelected: o.clsSelected,
                clsExcluded: o.clsExcluded,

                ripple: o.ripple,
                rippleColor: o.rippleColor,
                exclude: o.exclude,
                minDate: o.minDate,
                maxDate: o.maxDate,
                yearsBefore: o.yearsBefore,
                yearsAfter: o.yearsAfter,
                special: o.special,
                showHeader: o.showHeader,
                showFooter: false,
                showWeekNumber: o.showWeekNumber,
                onDayClick: function(sel, day, el){
                    var date = new Date(sel[0]);
                    date.setHours(0,0,0,0);

                    that._removeOverlay();

                    that.value = date;
                    element.val(date.format(o.format, o.locale));
                    element.trigger("change");
                    cal.removeClass("open open-up");
                    cal.hide();

                    that._fireEvent("change", {
                        val: that.value
                    });

                    that._fireEvent("day-click", {
                        sel: sel,
                        day: day,
                        el: el
                    });
                },
                onMonthChange: o.onMonthChange,
                onYearChange: o.onYearChange
            });

            this.calendar = cal;

            if (o.clearButton === true) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }

            calendarButton = $("<button>").addClass("button").attr("tabindex", -1).attr("type", "button").html(o.calendarButtonIcon);
            calendarButton.appendTo(buttons);

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl");
            }

            if (String(o.size).indexOf("%") > -1) {
                container.css({
                    width: o.size
                });
            } else {
                container.css({
                    width: parseInt(o.size) + "px"
                });
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                $.each(Utils.getInlineStyles(element), function(key, value){
                    container.css(key, value);
                });
            }

            container.addClass(o.clsPicker);
            element.addClass(o.clsInput);

            if (o.dialogOverlay === true) {
                this.overlay = that._overlay();
            }

            if (o.dialogMode === true) {
                container.addClass("dialog-mode");
            } else {
                if (Utils.media("(max-width: "+o.dialogPoint+"px)")) {
                    container.addClass("dialog-mode");
                    this.calendar.addClass("dialog-mode");
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();
            var clear = container.find(".input-clear-button");
            var cal = this.calendar;
            var cal_plugin = Metro.getPlugin(cal[0], 'calendar');
            var calendar = this.calendar;

            $(window).on(Metro.events.resize, function(){
                if (o.dialogMode !== true) {
                    if (Utils.media("(max-width: " + o.dialogPoint + "px)")) {
                        container.addClass("dialog-mode");
                        calendar.appendTo("body").addClass("dialog-mode");
                    } else {
                        container.removeClass("dialog-mode");
                        calendar.appendTo(container).removeClass("dialog-mode");
                    }
                }
            }, {ns: this.id});

            if (clear.length > 0) clear.on(Metro.events.click, function(e){
                element.val("").trigger('change').blur(); // TODO change blur
                that.value = null;
                e.preventDefault();
                e.stopPropagation();
            });

            container.on(Metro.events.click, "button, input", function(e){

                var value = Utils.isValue(that.value) ? that.value : new Date();

                value.setHours(0,0,0,0);

                if (cal.hasClass("open") === false && cal.hasClass("open-up") === false) {

                    $(".calendar-picker .calendar").removeClass("open open-up").hide();

                    cal_plugin.setPreset([value]);
                    cal_plugin.setShow(value);
                    cal_plugin.setToday(value);

                    if (container.hasClass("dialog-mode")) {
                        that.overlay.appendTo($('body'));
                    }
                    cal.addClass("open");
                    if (!Utils.inViewport(cal[0])) {
                        cal.addClass("open-up");
                    }
                    // if (Utils.isOutsider(cal) === false) {
                    //     cal.addClass("open-up");
                    // }

                    that._fireEvent("calendar-show", {
                        calendar: cal
                    });

                } else {

                    that._removeOverlay();
                    cal.removeClass("open open-up");

                    that._fireEvent("calendar-hide", {
                        calendar: cal
                    });

                }
                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.blur, function(){container.removeClass("focused");});
            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.change, function(){
                Utils.exec(o.onChange, [that.value], element[0]);
            });

            container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            })
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay for-calendar-picker").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _removeOverlay: function(){
            $('body').find('.overlay.for-calendar-picker').remove();
        },

        val: function(v){
            var element = this.element, o = this.options;

            if (Utils.isNull(v)) {
                return this.value;
            }

            if (Utils.isDate(v, o.inputFormat) === true) {
                Metro.getPlugin(this.calendar[0],"calendar").clearSelected();
                this.value = typeof v === 'string' ? o.inputFormat ? v.toDate(o.inputFormat, o.locale) : new Date(v) : v;
                if (Utils.isValue(this.value)) this.value.setHours(0,0,0,0);
                element.val(this.value.format(o.format, o.locale));
                element.trigger("change");
            }
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        i18n: function(val){
            var o = this.options;
            var hidden;
            var cal = this.calendar;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }

            hidden = cal[0].hidden;
            if (hidden) {
                cal.css({
                    visibility: "hidden",
                    display: "block"
                });
            }
            Metro.getPlugin(cal[0], 'calendar').i18n(val);
            if (hidden) {
                cal.css({
                    visibility: "visible",
                    display: "none"
                });
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;
            var cal = Metro.getPlugin(this.calendar[0], "calendar");

            var changeAttrLocale = function(){
                that.i18n(element.attr("data-locale"));
            };

            var changeAttrSpecial = function(){
                cal.setSpecial(element.attr("data-special"));
            };

            var changeAttrExclude = function(){
                cal.setExclude(element.attr("data-exclude"));
            };

            var changeAttrMinDate = function(){
                cal.setMinDate(element.attr("data-min-date"));
            };

            var changeAttrMaxDate = function(){
                cal.setMaxDate(element.attr("data-max-date"));
            };

            var changeAttrValue = function(){
                that.val(element.attr("value"));
            };

            var changeDataValue = function(){
                that.val(element.attr("data-value"))
            };

            switch (attributeName) {
                case "value": changeAttrValue(); break;
                case 'disabled': this.toggleState(); break;
                case 'data-locale': changeAttrLocale(); break;
                case 'data-special': changeAttrSpecial(); break;
                case 'data-exclude': changeAttrExclude(); break;
                case 'data-min-date': changeAttrMinDate(); break;
                case 'data-max-date': changeAttrMaxDate(); break;
                case 'data-value': changeDataValue(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();
            var clear = container.find(".input-clear-button");

            $(window).off(Metro.events.resize, {ns: this.id});
            clear.off(Metro.events.click);
            container.off(Metro.events.click, "button, input");
            element.off(Metro.events.blur);
            element.off(Metro.events.focus);
            element.off(Metro.events.change);

            Metro.getPlugin(this.calendar, "calendar").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, ".overlay.for-calendar-picker",function(){
        $(this).remove();
        $(".calendar-for-picker.open").removeClass("open open-up");
    });

    $(document).on(Metro.events.click, function(){
        $(".calendar-picker .calendar").removeClass("open open-up");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide", "slide-v", "fade", "switch", "zoom", "swirl"
    ];
    var CarouselDefaultConfig = {
        carouselDeferred: 0,
        autoStart: false,
        width: "100%",
        height: "16/9", // 3/4, 21/9
        effect: effects[0],
        effectFunc: "linear",
        direction: "left", //left, right
        duration: METRO_ANIMATION_DURATION,
        period: 5000,
        stopOnMouse: true,

        controls: true,
        bullets: true,
        bulletsStyle: "square", // square, circle, rect, diamond
        bulletsSize: "default", // default, mini, small, large

        controlsOnMouse: false,
        controlsOutside: false,
        bulletsPosition: "default", // default, left, right

        controlPrev: '&#x23F4',
        controlNext: '&#x23F5',
        clsCarousel: "",
        clsSlides: "",
        clsSlide: "",
        clsControls: "",
        clsControlNext: "",
        clsControlPrev: "",
        clsBullets: "",
        clsBullet: "",
        clsBulletOn: "",
        clsThumbOn: "",

        onStop: Metro.noop,
        onStart: Metro.noop,
        onPlay: Metro.noop,
        onSlideClick: Metro.noop,
        onBulletClick: Metro.noop,
        onThumbClick: Metro.noop,
        onMouseEnter: Metro.noop,
        onMouseLeave: Metro.noop,
        onNextClick: Metro.noop,
        onPrevClick: Metro.noop,
        onSlideShow: Metro.noop,
        onSlideHide: Metro.noop,
        onCarouselCreate: Metro.noop
    };

    Metro.carouselSetup = function (options) {
        CarouselDefaultConfig = $.extend({}, CarouselDefaultConfig, options);
    };

    if (typeof window["metroCarouselSetup"] !== undefined) {
        Metro.carouselSetup(window["metroCarouselSetup"]);
    }

    Metro.Component('carousel', {
        init: function( options, elem ) {
            this._super(elem, options, CarouselDefaultConfig, {
                height: 0,
                width: 0,
                slides: [],
                current: null,
                currentIndex: null,
                dir: "left",
                interval: false,
                isAnimate: false,
                id: Utils.elementId("carousel")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides_container = element.find(".slides");

            this.dir = this.options.direction;

            element.addClass("carousel").addClass(o.clsCarousel);
            if (o.controlsOutside === true) {
                element.addClass("controls-outside");
            }

            if (slides_container.length === 0) {
                slides_container = $("<div>").addClass("slides").appendTo(element);
                slides.appendTo(slides_container);
            }

            slides.addClass(o.clsSlides);

            if (slides.length > 0) {

                this._createSlides();
                this._createControls();
                this._createBullets();
                this._createEvents();
                this._resize();

                if (o.controlsOnMouse === true) {
                    element.find("[class*=carousel-switch]").fadeOut(0);
                    element.find(".carousel-bullets").fadeOut(0);
                }

                if (o.autoStart === true) {
                    this._start();
                } else {
                    this._fireEvent("slide-show", {
                        current: this.slides[this.currentIndex][0],
                        prev: undefined
                    });
                }

            }

            this._fireEvent("carousel-create", {
                element: element
            });
        },

        _start: function(){
            var that = this, element = this.element, o = this.options;
            var period = o.period;
            var current = this.slides[this.currentIndex];

            if (current.data("period") !== undefined) {
                period = current.data("period");
            }

            if (this.slides.length <= 1) {
                return ;
            }

            if (this.interval === false) this.interval = setTimeout(function run() {
                var t = o.direction === 'left' ? 'next' : 'prior';
                that._slideTo(t, true);
            }, period);

            this._fireEvent("start", {
                element: element
            });
        },

        _stop: function(){
            clearInterval(this.interval);
            this.interval = false;
        },

        _resize: function(){
            var element = this.element, o = this.options;
            var width = element.outerWidth();
            var height;
            var medias = [];

            if (["16/9", "21/9", "4/3"].indexOf(o.height) > -1) {
                height = Utils.aspectRatioH(width, o.height);
            } else {
                if (String(o.height).indexOf("@") > -1) {
                    medias = o.height.substr(1).toArray("|");
                    $.each(medias, function(){
                        var media = this.toArray(",");
                        if (window.matchMedia(media[0]).matches) {
                            if (["16/9", "21/9", "4/3"].indexOf(media[1]) > -1) {
                                height = Utils.aspectRatioH(width, media[1]);
                            } else {
                                height = parseInt(media[1]);
                            }
                        }
                    });
                } else {
                    height = parseInt(o.height);
                }
            }

            element.css({
                height: height
            });
        },

        _createSlides: function(){
            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");

            $.each(slides, function(i){
                var slide = $(this);
                if (slide.data("cover") !== undefined) {
                    slide.css({
                        backgroundImage: "url("+slide.data('cover')+")"
                    });
                }

                if (i !== 0) {
                    switch (o.effect) {
                        case "switch":
                        case "slide":
                            slide.css("left", "100%");
                            break;
                        case "slide-v":
                            slide.css("top", "100%");
                            break;
                        case "fade":
                        case "zoom":
                        case "swirl":
                            slide.css("opacity", "0");
                            break;
                    }
                } else {
                    slide.addClass("active-slide");
                }

                slide.addClass(o.clsSlide);

                that.slides.push(slide);
            });

            this.currentIndex = 0;
            this.current = this.slides[this.currentIndex];
        },

        _createControls: function(){
            var element = this.element, o = this.options;
            var next, prev;

            if (o.controls === false) {
                return ;
            }

            next = $('<span/>').addClass('carousel-switch-next').addClass(o.clsControls).addClass(o.clsControlNext).html(">");
            prev = $('<span/>').addClass('carousel-switch-prev').addClass(o.clsControls).addClass(o.clsControlPrev).html("<");

            if (o.controlNext) {
                next.html(o.controlNext);
            }

            if (o.controlPrev) {
                prev.html(o.controlPrev);
            }

            next.appendTo(element);
            prev.appendTo(element);
        },

        _createBullets: function(){
            var element = this.element, o = this.options;
            var bullets, i;

            if (o.bullets === false) {
                return ;
            }

            bullets = $('<div>').addClass("carousel-bullets").addClass(o.bulletsSize+"-size").addClass("bullet-style-"+o.bulletsStyle).addClass(o.clsBullets);
            if (o.bulletsPosition === 'default' || o.bulletsPosition === 'center') {
                bullets.addClass("flex-justify-center");
            } else if (o.bulletsPosition === 'left') {
                bullets.addClass("flex-justify-start");
            } else {
                bullets.addClass("flex-justify-end");
            }

            for (i = 0; i < this.slides.length; i++) {
                var bullet = $('<span>').addClass("carousel-bullet").addClass(o.clsBullet).data("slide", i);
                if (i === 0) {
                    bullet.addClass('bullet-on').addClass(o.clsBulletOn);
                }
                bullet.appendTo(bullets);
            }

            bullets.appendTo(element);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".carousel-bullet", function(){
                var bullet = $(this);
                if (that.isAnimate === false) {
                    that._slideToSlide(bullet.data('slide'));
                    that._fireEvent("bullet-click", {
                        bullet: bullet
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-next", function(){
                if (that.isAnimate === false) {
                    that._slideTo("next", false);
                    that._fireEvent("next-click", {
                        button: this
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-prev", function(){
                if (that.isAnimate === false) {
                    that._slideTo("prev", false);
                    that._fireEvent("prev-click", {
                        button: this
                    });
                }
            });

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.on(Metro.events.enter, function () {
                    that._stop();
                    that._fireEvent("mouse-enter", {
                        element: element
                    }, false, true);
                });
                element.on(Metro.events.leave, function () {
                    that._start();
                    that._fireEvent("mouse-leave", {
                        element: element
                    }, false, true);
                });
            }

            if (o.controlsOnMouse === true) {
                element.on(Metro.events.enter, function () {
                    element.find("[class*=carousel-switch]").fadeIn();
                    element.find(".carousel-bullets").fadeIn();
                });
                element.on(Metro.events.leave, function () {
                    element.find("[class*=carousel-switch]").fadeOut();
                    element.find(".carousel-bullets").fadeOut();
                });
            }

            element.on(Metro.events.click, ".slide", function(){
                var slide = $(this);
                that._fireEvent("slide-click", {
                    slide: slide
                });
            });

            $(window).on(Metro.events.resize, function(){
                that._resize();
            }, {ns: this.id});
        },

        _slideToSlide: function(index){
            var element = this.element, o = this.options;
            var current, next, to;

            if (this.slides[index] === undefined) {
                return ;
            }

            if (this.currentIndex === index) {
                return ;
            }

            to = index > this.currentIndex ? "next" : "prev";
            current = this.slides[this.currentIndex];
            next = this.slides[index];

            this.currentIndex = index;

            this._effect(current, next, o.effect, to);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _slideTo: function(to, interval){
            var element = this.element, o = this.options;
            var current, next;

            if (to === undefined) {
                to = "next";
            }

            current = this.slides[this.currentIndex];

            if (to === "next") {
                this.currentIndex++;
                if (this.currentIndex >= this.slides.length) {
                    this.currentIndex = 0;
                }
            } else {
                this.currentIndex--;
                if (this.currentIndex < 0) {
                    this.currentIndex = this.slides.length - 1;
                }
            }

            next = this.slides[this.currentIndex];

            this._effect(current, next, o.effect, to, interval);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _effect: function(current, next, effect, to, interval){
            var that = this, o = this.options;
            var duration = o.duration;
            var func, effectFunc = o.effectFunc;
            var period = o.period;

            var run = function(f, c, n, o){
                Metro.animations[f](c, n, o);
            }

            if (next.data('duration') !== undefined) {
                duration = next.data('duration');
            }

            if (next.data('effectFunc') !== undefined) {
                effectFunc = next.data('effectFunc');
            }

            if (effect === 'switch') {
                duration = 0;
            }

            current.stop(true);
            next.stop(true);
            this.isAnimate = true;

            setTimeout(function(){that.isAnimate = false;}, duration + 100);

            if (effect === 'slide') {
                func = to === 'next' ? 'slideLeft': 'slideRight';
            } else
            if (effect === 'slide-v') {
                func = to === 'next' ? 'slideUp': 'slideDown';
            } else {
                func = effect;
            }

            if (!effects.includes(effect)) {
                func = "switch";
            }

            run(func, current, next, {duration: duration, ease: effectFunc});

            current.removeClass("active-slide");
            next.addClass("active-slide");

            setTimeout(function(){
                that._fireEvent("slide-show", {
                    current: next[0],
                    prev: current[0]
                })
            }, duration);

            setTimeout(function(){
                that._fireEvent("slide-hide", {
                    current: current[0],
                    next: next[0]
                })
            }, duration);

            if (interval === true) {

                if (next.data('period') !== undefined) {
                    period = next.data('period');
                }

                this.interval = setTimeout(function run() {
                    var t = o.direction === 'left' ? 'next' : 'prior';
                    that._slideTo(t, true);
                }, period);
            }
        },

        toSlide: function(index){
            this._slideToSlide(index);
        },

        next: function(){
            this._slideTo("next");
        },

        prev: function(){
            this._slideTo("prev");
        },

        stop: function () {
            clearInterval(this.interval);
            this._fireEvent("stop");
        },

        play: function(){
            this._start();
            this._fireEvent("play");
        },

        setEffect: function(effect){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");

            if (!effects.includes(effect)) return ;

            o.effect = effect;

            slides.removeStyleProperty("transform").css({
                top: 0,
                left: 0
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
            if (attributeName === 'data-effect') {
                this.setEffect(newValue);
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".carousel-bullet");
            element.off(Metro.events.click, ".carousel-switch-next");
            element.off(Metro.events.click, ".carousel-switch-prev");

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            if (o.controlsOnMouse === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            element.off(Metro.events.click, ".slide");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CharmsDefaultConfig = {
        charmsDeferred: 0,
        position: "right",
        opacity: 1,
        clsCharms: "",
        onCharmCreate: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onToggle: Metro.noop
    };

    Metro.charmsSetup = function (options) {
        CharmsDefaultConfig = $.extend({}, CharmsDefaultConfig, options);
    };

    if (typeof window["metroCharmsSetup"] !== undefined) {
        Metro.charmsSetup(window["metroCharmsSetup"]);
    }

    Metro.Component('charms', {
        init: function( options, elem ) {
            this._super(elem, options, CharmsDefaultConfig, {
                origin: {
                    background: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("charm-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element
                .addClass("charms")
                .addClass(o.position + "-side")
                .addClass(o.clsCharms);

            this.origin.background = element.css("background-color");

            element.css({
                backgroundColor: Utils.computedRgbToRgba(Utils.getStyleOne(element, "background-color"), o.opacity)
            });
        },

        _createEvents: function(){
        },

        open: function(){
            var element = this.element;

            element.addClass("open");

            this._fireEvent("open");
        },

        close: function(){
            var element = this.element;

            element.removeClass("open");

            this._fireEvent("close");
        },

        toggle: function(){
            var element = this.element;

            if (element.hasClass("open") === true) {
                this.close();
            } else {
                this.open();
            }

            this._fireEvent("toggle");
        },

        opacity: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.opacity;
            }

            var opacity = Math.abs(parseFloat(v));
            if (opacity < 0 || opacity > 1) {
                return ;
            }
            o.opacity = opacity;
            element.css({
                backgroundColor: Utils.computedRgbToRgba(Utils.getStyleOne(element, "background-color"), opacity)
            });
        },

        changeOpacity: function(){
            var element = this.element;
            this.opacity(element.attr("data-opacity"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-opacity": this.changeOpacity(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['charms'] = {
        check: function(el){
            if (Utils.isMetroObject(el, "charms") === false) {
                console.warn("Element is not a charms component");
                return false;
            }
            return true;
        },

        isOpen: function(el){
            if (this.check(el) === false) return ;
            return $(el).hasClass("open");
        },

        open: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").open();
        },

        close: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").close();
        },

        toggle: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").toggle();
        },

        closeAll: function(){
            $('[data-role*=charms]').each(function() {
                Metro.getPlugin(this, 'charms').close();
            });
        },

        opacity: function(el, opacity){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").opacity(opacity);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var defaultAvatar = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gOTAK/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgAUABQAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+t+KKPxo/GgA70Yo/Gj8aADFH4VesdC1HUl3WtjcXCf344yV/PGKW+0HUtNXddWNzbp/fkjIX88YoAofhR+FH40fjQAfhR+FH40fjQAUUUUAFepeAPh5D9li1LVYhK8g3Q27j5VXszDuT6f5HA+FtOXVvEWn2rjMcko3j1UckfkDX0MBgYHAoARVCKFUBVHAA6ClZQwKkZBGCDS0UAec+Pvh3BJay6lpUQimjBeW3QYVx3Kjsfbv/PyqvpuvnvxfpqaT4l1C1QbY0lJUDsrfMB+RoAyKKKKACiiigDa8GXq6f4p02eQgIJQpJ7Bvlz+tfQP4V8yDg17P4A8cw65ZxWV5IE1KMbfmP+uA7j39R+NAHaUfhSUUAL+FeA+OL1NQ8WalNGQU83YCO+0Bf6V6b498cQ6BZyWlrIJNSkXaApz5QP8AEff0FeKk5OTyTQAUUUUAH40fjRU1naTX93DbQIXmlYIijuTQBc0Dw/eeI74W1mm49XkbhUHqTXsHhz4eaXoCpI8YvbscmaYZAP8Asr0H8/etHwv4cg8M6XHaxANIfmllxy7dz9PStigA/Gk/GlooA5bxJ8PdL19XkWMWd43PnwjGT/tL0P8AP3rx/X/D954cvjbXibT1SReVceoNfRFZHijw5B4m0uS1lAWQfNFLjlG7H6etAHz5+NH41NeWk1hdzW06FJonKMp7EGoaACvQfhBowudTudRkXK2y7I8j+Nup/Afzrz6vafhRaCDwmkgHM8zufwO3/wBloA7Kiij8KACkpaSgBaSj8KKAPJvi/owttTttRjXC3K7JMf3l6H8R/KvPq9p+K1qJ/CbyEcwTI4P1O3/2avFqAP/Z";
    var ChatDefaultConfig = {
        chatDeferred: 0,
        inputTimeFormat: "%m-%d-%y",
        timeFormat: "%d %b %l:%M %p",
        name: "John Doe",
        avatar: defaultAvatar,
        welcome: null,
        title: null,
        width: "100%",
        height: "auto",
        randomColor: false,
        messages: null,
        sendButtonTitle: "Send",
        readonly: false,

        clsChat: "",
        clsName: "",
        clsTime: "",
        clsInput: "",
        clsSendButton: "",
        clsMessageLeft: "default",
        clsMessageRight: "default",

        onMessage: Metro.noop,
        onSend: Metro.noop,
        onSendButtonClick: Metro.noop,
        onChatCreate: Metro.noop
    };

    Metro.chatSetup = function (options) {
        ChatDefaultConfig = $.extend({}, ChatDefaultConfig, options);
    };

    if (typeof window["metroChatSetup"] !== undefined) {
        Metro.chatSetup(window["metroChatSetup"]);
    }

    Metro.Component('chat', {
        init: function( options, elem ) {
            this._super(elem, options, ChatDefaultConfig, {
                input: null,
                classes: "primary secondary success alert warning yellow info dark light".split(" "),
                lastMessage: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("chat-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var messages, messageInput, input;
            var customButtons = [
                {
                    html: o.sendButtonTitle,
                    cls: o.clsSendButton+" js-chat-send-button",
                    onclick: o.onSendButtonClick
                }
            ];

            element.addClass("chat").addClass(o.clsChat);

            element.css({
                width: o.width,
                height: o.height
            });

            if (Utils.isValue(o.title)) {
                $("<div>").addClass("title").html(o.title).appendTo(element);
            }

            messages = $("<div>").addClass("messages");
            messages.appendTo(element);
            messageInput = $("<div>").addClass("message-input").appendTo(element);
            input = $("<input type='text'>");
            input.appendTo(messageInput);
            input.input({
                customButtons: customButtons,
                clsInput: o.clsInput
            });

            if (o.welcome) {
                this.add({
                    text: o.welcome,
                    time: (new Date()),
                    position: "left",
                    name: "Welcome",
                    avatar: defaultAvatar
                })
            }

            if (Utils.isValue(o.messages) && typeof o.messages === "string") {
                o.messages = Utils.isObject(o.messages);
            }

            if (!Utils.isNull(o.messages) && typeof o.messages === "object" && Utils.objectLength(o.messages) > 0) {
                $.each(o.messages, function(){
                    that.add(this);
                });
            }

            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            var send = function(){
                var msg = ""+input.val(), m;
                if (msg.trim() === "") {return false;}
                m = {
                    id: Utils.elementId("chat-message"),
                    name: o.name,
                    avatar: o.avatar,
                    text: msg,
                    position: "right",
                    time: (new Date())
                };
                that.add(m);
                input.val("");
                that._fireEvent("send", {
                    msg: m
                });
            };

            sendButton.on(Metro.events.click, function () {
                send();
            });

            input.on(Metro.events.keyup, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    send();
                }
            })
        },

        add: function(msg){
            var that = this, element = this.element, o = this.options;
            var index, message, sender, time, item, avatar, text;
            var messages = element.find(".messages");
            var messageDate;

            messageDate = typeof msg.time === 'string' ? msg.time.toDate(o.inputTimeFormat) : msg.time;

            message = $("<div>").addClass("message").addClass(msg.position).appendTo(messages);
            sender = $("<div>").addClass("message-sender").addClass(o.clsName).html(msg.name).appendTo(message);
            time = $("<div>").addClass("message-time").addClass(o.clsTime).html(messageDate.format(o.timeFormat)).appendTo(message);
            item = $("<div>").addClass("message-item").appendTo(message);
            avatar = $("<img>").attr("src", msg.avatar).addClass("message-avatar").appendTo(item);
            text = $("<div>").addClass("message-text").html(msg.text).appendTo(item);

            if (Utils.isValue(msg.id)) {
                message.attr("id", msg.id);
            }

            if (o.randomColor === true) {
                index = $.random(0, that.classes.length - 1);
                text.addClass(that.classes[index]);
            } else {
                if (msg.position === 'left' && Utils.isValue(o.clsMessageLeft)) {
                    text.addClass(o.clsMessageLeft);
                }
                if (msg.position === 'right' && Utils.isValue(o.clsMessageRight)) {
                    text.addClass(o.clsMessageRight);
                }
            }

            that._fireEvent("message", {
                msg: msg,
                el: {
                    message: message,
                    sender: sender,
                    time: time,
                    item: item,
                    avatar: avatar,
                    text: text
                }
            });

            messages.animate({
                draw: {
                    scrollTop: messages[0].scrollHeight
                },
                dur: 1000
            });

            this.lastMessage = msg;

            return this;
        },

        addMessages: function(messages){
            var that = this;

            if (Utils.isValue(messages) && typeof messages === "string") {
                messages = Utils.isObject(messages);
            }

            if (typeof messages === "object" && Utils.objectLength(messages) > 0) {
                $.each(messages, function(){
                    that.add(this);
                });
            }

            return this;
        },

        delMessage: function(id){
            var element = this.element;

            element.find(".messages").find("#"+id).remove();

            return this;
        },

        updMessage: function(msg){
            var element = this.element;
            var message = element.find(".messages").find("#"+msg.id);

            if (message.length === 0) return this;

            message.find(".message-text").html(msg.text);
            message.find(".message-time").html(msg.time);

            return this;
        },

        clear: function(){
            var element = this.element;
            var messages = element.find(".messages");
            messages.html("");
            this.lastMessage = null;
        },

        toggleReadonly: function(readonly){
            var element = this.element, o = this.options;
            o.readonly = typeof readonly === "undefined" ? !o.readonly : readonly;
            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-readonly": this.toggleReadonly(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            sendButton.off(Metro.events.click);
            input.off(Metro.events.keyup);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CheckboxDefaultConfig = {
        checkboxDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        indeterminate: false,
        clsCheckbox: "",
        clsCheck: "",
        clsCaption: "",
        onCheckboxCreate: Metro.noop
    };

    Metro.checkboxSetup = function (options) {
        CheckboxDefaultConfig = $.extend({}, CheckboxDefaultConfig, options);
    };

    if (typeof window["metroCheckboxSetup"] !== undefined) {
        Metro.checkboxSetup(window["metroCheckboxSetup"]);
    }

    Metro.Component('checkbox', {
        init: function( options, elem ) {
            this._super(elem, options, CheckboxDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();
            this._fireEvent("checkbox-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var checkbox;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            checkbox = element
                .wrap("<label>")
                .addClass("checkbox " + element[0].className)
                .addClass(o.style === 2 ? "style2" : "");

            check.appendTo(checkbox);
            caption.appendTo(checkbox);

            if (o.transition === true) {
                checkbox.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                checkbox.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            checkbox.addClass(o.clsCheckbox);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (o.indeterminate) {
                element[0].indeterminate = true;
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        indeterminate: function(v){
            var element = this.element;

            v = Utils.isNull(v) ? true : Utils.bool(v);

            element[0].indeterminate = v;
            element.attr("data-indeterminate", v);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            this.indeterminate(false);

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                if (v === -1) {
                    this.indeterminate(true);
                } else {
                    element.prop("checked", v === 1);
                }
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            var indeterminateState = function(){
                element[0].indeterminate = JSON.parse(element.attr("data-indeterminate")) === true;
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-indeterminate': indeterminateState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            element.off("focus");
            element.off("blur");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ClockDefaultConfig = {
        clockDeferred: 0,
        showTime: true,
        showDate: true,
        timeFormat: '24',
        dateFormat: 'american',
        divider: "&nbsp;&nbsp;",
        leadingZero: true,
        dateDivider: '-',
        timeDivider: ":",
        onTick: Metro.noop,
        onSecond: Metro.noop,
        onClockCreate: Metro.noop
    };

    Metro.clockSetup = function (options) {
        ClockDefaultConfig = $.extend({}, ClockDefaultConfig, options);
    };

    if (typeof window["metroClockSetup"] !== undefined) {
        Metro.clockSetup(window["metroClockSetup"]);
    }

    Metro.Component('clock', {
        init: function( options, elem ) {
            this._super(elem, options, ClockDefaultConfig, {
                _clockInterval: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._fireEvent('clock-create', {
                element: element
            });

            this._tick();

            this._clockInterval = setInterval(function(){
                that._tick();
            }, 500);
            this._secondInterval = setInterval(function(){
                that._second();
            }, 1000);
        },

        _addLeadingZero: function(i){
            if (i<10){i="0" + i;}
            return i;
        },

        _second: function(){
            var timestamp = new Date();

            this._fireEvent('second', {
                timestamp: timestamp
            })
        },

        _tick: function(){
            var element = this.element, o = this.options;
            var timestamp = new Date();
            var result = "";
            var h = timestamp.getHours(),
                i = timestamp.getMinutes(),
                s = timestamp.getSeconds(),
                d = timestamp.getDate(),
                m = timestamp.getMonth() + 1,
                y = timestamp.getFullYear(),
                a = '';

            if (parseInt(o.timeFormat) === 12) {
                a = " AM";
                if (h > 11) { a = " PM"; }
                if (h > 12) { h = h - 12; }
                if (h === 0) { h = 12; }
            }

            i = this._addLeadingZero(i);
            s = this._addLeadingZero(s);

            if (o.leadingZero) {
                h = this._addLeadingZero(h);
                m = this._addLeadingZero(m);
                d = this._addLeadingZero(d);
            }

            if (o.showDate) {
                if (o.dateFormat === 'american') {
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                } else {
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                }
                result += o.divider;
            }

            if (o.showTime) {
                result += "<span class='clock-hour'>" + h + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-minute'>" + i + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-second'>" + s + "</span>";
                result += "<span class='clock-suffix'>" + a + "</span>";
            }

            element.html(result);

            this._fireEvent('tick', {
                timestamp: timestamp
            })
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            clearInterval(this._clockInterval);
            this._clockInterval = null;
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CollapseDefaultConfig = {
        collapseDeferred: 0,
        collapsed: false,
        toggleElement: false,
        duration: 100,
        onExpand: Metro.noop,
        onCollapse: Metro.noop,
        onCollapseCreate: Metro.noop
    };

    Metro.collapseSetup = function (options) {
        CollapseDefaultConfig = $.extend({}, CollapseDefaultConfig, options);
    };

    if (typeof window["metroCollapseSetup"] !== undefined) {
        Metro.collapseSetup(window["metroCollapseSetup"]);
    }

    Metro.Component('collapse', {
        init: function( options, elem ) {
            this._super(elem, options, CollapseDefaultConfig, {
                toggle: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var toggle;

            toggle = o.toggleElement !== false ? $(o.toggleElement) : element.siblings('.collapse-toggle').length > 0 ? element.siblings('.collapse-toggle') : element.siblings('a:nth-child(1)');

            if (o.collapsed === true || element.attr("collapsed") === true) {
                element.hide(0);
            }

            toggle.on(Metro.events.click, function(e){
                if (element.css('display') === 'block' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    that._open(element);
                }

                if (["INPUT"].indexOf(e.target.tagName) === -1) {
                    e.preventDefault();
                }
                e.stopPropagation();
            });

            this.toggle = toggle;

            this._fireEvent("collapse-create", {
                element: element
            });
        },

        _close: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideUp';
            var dur = immediate ? 0 : options.duration;

            this.toggle.removeClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onCollapse", null, el);
                el.data("collapsed", true);
                el.addClass("collapsed");

                dropdown._fireEvent("collapse");
            });
        },

        _open: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideDown';
            var dur = immediate ? 0 : options.duration;

            this.toggle.addClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onExpand", null, el);
                el.data("collapsed", false);
                el.removeClass("collapsed");

                dropdown._fireEvent("expand");
            });
        },

        collapse: function(immediate){
            this._close(this.element, immediate);
        },

        expand: function(immediate){
            this._open(this.element, immediate);
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        isCollapsed: function(){
            return this.element.data("collapsed");
        },

        toggleState: function(){
            var element = this.element;
            if (element.attr("collapsed") === true || element.data("collapsed") === true) {
                this.collapse();
            } else {
                this.expand();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "collapsed":
                case "data-collapsed": this.toggleState(); break;
            }
        },

        destroy: function(){
            this.toggle.off(Metro.events.click);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var cookieDisclaimerDefaults = {
        name: 'cookies_accepted',
        template: null,
        templateSource: null,
        acceptButton: '.cookie-accept-button',
        cancelButton: '.cookie-cancel-button',
        message: 'Our website uses cookies to monitor traffic on our website and ensure that we can provide our customers with the best online experience possible.',
        duration: "30days",
        clsContainer: "",
        clsMessage: "",
        clsButtons: "",
        clsAcceptButton: "alert",
        clsCancelButton: "",
        onAccept: Metro.noop,
        onDecline: Metro.noop
    };

    Metro.cookieDisclaimer = {
        init: function(options){
            var that = this, cookie = Metro.cookie;

            this.options = $.extend({}, cookieDisclaimerDefaults, options);
            this.disclaimer = $("<div>");

            if (cookie.getCookie(this.options.name)) {
                return ;
            }

            if (this.options.template) {
                $.get(this.options.template).then(function(response){
                    that.create(response);
                });
            } else if (this.options.templateSource) {
                this.create($(this.options.templateSource));
            } else {
                this.create();
            }
        },

        create: function(html){
            var cookie = Metro.cookie;
            var o = this.options, wrapper = this.disclaimer, buttons;

            wrapper
                .addClass("cookie-disclaimer-block")
                .addClass(o.clsContainer);

            if (!html) {
                buttons = $("<div>")
                    .addClass("cookie-disclaimer-actions")
                    .addClass(o.clsButtons)
                    .append( $('<button>').addClass('button cookie-accept-button').addClass(o.clsAcceptButton).html('Accept') )
                    .append( $('<button>').addClass('button cookie-cancel-button').addClass(o.clsCancelButton).html('Cancel') );

                wrapper
                    .html( $("<div>").addClass(o.clsMessage).html(o.message) )
                    .append( $("<hr>").addClass('thin') )
                    .append(buttons);

            } else if (html instanceof $) {
                wrapper.append(html);
            } else {
                wrapper.html(html);
            }

            wrapper.appendTo($('body'));

            wrapper.on(Metro.events.click, o.acceptButton, function(){
                var dur = 0;
                var durations = (""+o.duration).toArray(" ");

                $.each(durations, function(){
                    var d = ""+this;
                    if (d.includes("day")) {
                        dur += parseInt(d)*24*60*60*1000;
                    } else
                    if (d.includes("hour")) {
                        dur += parseInt(d)*60*60*1000;
                    } else
                    if (d.includes("min")) {
                        dur += parseInt(d)*60*1000;
                    } else
                    if (d.includes("sec")) {
                        dur += parseInt(d)*1000;
                    } else {
                        dur += parseInt(d);
                    }
                })

                cookie.setCookie(o.name, true, dur);
                Utils.exec(o.onAccept);
                wrapper.remove();
            });

            wrapper.on(Metro.events.click, o.cancelButton, function(){
                Utils.exec(o.onDecline);
                wrapper.remove();
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CookieDefaultConfig = {
        path: "/",
        expires: null,
        maxAge: null,
        domain: null,
        secure: false,
        samesite: null
    }

    Metro.cookieSetup = function (options) {
        CookieDefaultConfig = $.extend({}, CookieDefaultConfig, options);
    };

    if (typeof window["metroCookieSetup"] !== undefined) {
        Metro.cookieSetup(window["metroCookieSetup"]);
    }

    Metro.cookie = {
        getCookies: function(){
            var a = document.cookie.toArray(";");
            var o = {};
            $.each(a, function(){
                var i = this.split('=');
                o[i[0]] = i[1];
            });
            return o;
        },

        getCookie: function(name){
            var cookieName = encodeURIComponent(name) + "=";
            var cookies = document.cookie.toArray(";");
            var i, cookie;

            for(i = 0; i < cookies.length; i++) {
                cookie = cookies[i];
                while (cookie.charAt(0) === ' ') {
                    cookie = cookie.substring(1, cookie.length);
                }
                if (cookie.indexOf(cookieName) === 0) {
                    return decodeURIComponent(cookie.substring(cookieName.length, cookie.length));
                }
            }
            return null;
        },

        setCookie: function(name, value, options){
            var date;
            var cookieName = encodeURIComponent(name);
            var cookieValue = encodeURIComponent(value);
            var opt, a = [];

            if (options && typeof options !== "object") {
                date = new Date();
                date.setTime(date.getTime()+(parseInt(options)));
                opt = $.extend({}, CookieDefaultConfig, {
                    expires: date.toUTCString()
                });
            } else {
                opt = $.extend({}, CookieDefaultConfig, options);
            }

            $.each(opt, function(key, val){
                if (key !== 'secure' && val) {
                    a.push($.dashedName(key) + "=" + val);
                }
                if (key === 'secure' && val === true) {
                    a.push( "secure" );
                }
            });

            document.cookie = cookieName + '=' + cookieValue + "; " +  a.join("; ");
        },

        delCookie: function(name){
            this.setCookie(name, false, {
                maxAge: -1
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CountdownDefaultConfig = {
        countdownDeferred: 0,
        stopOnBlur: true,
        animate: "none",
        animationFunc: "linear",
        inputFormat: null,
        locale: METRO_LOCALE,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        date: null,
        start: true,
        clsCountdown: "",
        clsPart: "",
        clsZero: "",
        clsAlarm: "",
        clsDays: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        onAlarm: Metro.noop,
        onTick: Metro.noop,
        onZero: Metro.noop,
        onBlink: Metro.noop,
        onCountdownCreate: Metro.noop
    };

    Metro.countdownSetup = function (options) {
        CountdownDefaultConfig = $.extend({}, CountdownDefaultConfig, options);
    };

    if (typeof window["metroCountdownSetup"] !== undefined) {
        Metro.countdownSetup(window["metroCountdownSetup"]);
    }

    Metro.Component('countdown', {
        init: function( options, elem ) {
            this._super(elem, options, CountdownDefaultConfig, {
                locale: Metro.locales["en-US"],
                breakpoint: (new Date()).getTime(),
                blinkInterval: null,
                tickInterval: null,
                zeroDaysFired: false,
                zeroHoursFired: false,
                zeroMinutesFired: false,
                zeroSecondsFired: false,
                fontSize: parseInt(Utils.getStyleOne(elem, "font-size")),
                current: {
                    d: 0, h: 0, m: 0, s: 0
                },
                inactiveTab: false,
                id: Utils.elementId("countdown")
            });

            return this;
        },

        _create: function(){
            var o = this.options;

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this._build();
            this._createEvents();
        },

        _setBreakpoint: function(){
            var o = this.options;
            var dm = 86400000, hm = 3600000, mm = 60000, sm = 1000;

            this.breakpoint = (new Date()).getTime();

            if (Utils.isValue(o.date) && Utils.isDate(o.date, o.inputFormat)) {
                this.breakpoint = Utils.isValue(o.inputFormat) ? (o.date.toDate(o.inputFormat)).getTime() : (new Date(o.date)).getTime();
            }

            if (parseInt(o.days) > 0) {
                this.breakpoint += parseInt(o.days) * dm;
            }
            if (parseInt(o.hours) > 0) {
                this.breakpoint += parseInt(o.hours) * hm;
            }
            if (parseInt(o.minutes) > 0) {
                this.breakpoint += parseInt(o.minutes) * mm;
            }
            if (parseInt(o.seconds) > 0) {
                this.breakpoint += parseInt(o.seconds) * sm;
            }
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];
            var dm = 24*60*60*1000;
            var delta_days;
            var now = (new Date()).getTime();
            var digit;

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("countdown"));
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("countdown"));
            }

            element.addClass("countdown").addClass(o.clsCountdown);

            this._setBreakpoint();

            delta_days = Math.round((that.breakpoint - now) / dm);

            $.each(parts, function(){
                var part = $("<div>").addClass("part " + this).addClass(o.clsPart).attr("data-label", that.locale["calendar"]["time"][this]).appendTo(element);

                if (this === "days") {part.addClass(o.clsDays);}
                if (this === "hours") {part.addClass(o.clsHours);}
                if (this === "minutes") {part.addClass(o.clsMinutes);}
                if (this === "seconds") {part.addClass(o.clsSeconds);}

                $("<div>").addClass("digit").appendTo(part);
                $("<div>").addClass("digit").appendTo(part);

                if (this === "days" && delta_days >= 100) {

                    for(var i = 0; i < String(Math.round(delta_days/100)).length; i++) {
                        $("<div>").addClass("digit").appendTo(part);
                    }
                }

            });

            digit = element.find(".digit");
            digit.append($("<span class='digit-placeholder'>").html("0"));
            digit.append($("<span class='digit-value'>").html("0"));

            this._fireEvent("countdown-create", {
                element: element
            })

            if (o.start === true) {
                this.start();
            } else {
                this.tick();
            }
        },

        _createEvents: function(){
            var that = this;
            $(document).on("visibilitychange", function() {
                if (document.hidden) {
                    that.pause();
                } else {
                    that.resume();
                }
            }, {ns: this.id});
        },

        blink: function(){
            var element = this.element;
            element.toggleClass("blink");

            this._fireEvent("blink", {
                time: this.current
            });
        },

        tick: function(){
            var element = this.element, o = this.options;
            var dm = 24*60*60, hm = 60*60, mm = 60, sm = 1;
            var left, now = (new Date()).getTime();
            var d, h, m, s;
            var days = element.find(".days"),
                hours = element.find(".hours"),
                minutes = element.find(".minutes"),
                seconds = element.find(".seconds");

            left = Math.floor((this.breakpoint - now)/1000);

            if (left <= -1) {
                this.stop();
                element.addClass(o.clsAlarm);

                this._fireEvent("alarm", {
                    time: now
                });

                return ;
            }

            d = Math.floor(left / dm);

            left -= d * dm;
            if (this.current.d !== d) {
                this.current.d = d;
                this.draw("days", d);
            }

            if (d === 0) {
                if (this.zeroDaysFired === false) {
                    this.zeroDaysFired = true;
                    days.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "days",
                        value: days
                    });
                }
            }

            h = Math.floor(left / hm);
            left -= h*hm;
            if (this.current.h !== h) {
                this.current.h = h;
                this.draw("hours", h);
            }

            if (d === 0 && h === 0) {
                if (this.zeroHoursFired === false) {
                    this.zeroHoursFired = true;
                    hours.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "hours",
                        value: hours
                    });
                }
            }

            m = Math.floor(left / mm);
            left -= m*mm;
            if (this.current.m !== m) {
                this.current.m = m;
                this.draw("minutes", m);
            }

            if (d === 0 && h === 0 && m === 0) {
                if (this.zeroMinutesFired === false) {
                    this.zeroMinutesFired = true;
                    minutes.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "minutes",
                        value: minutes
                    });

                }
            }

            s = Math.floor(left / sm);
            if (this.current.s !== s) {
                this.current.s = s;
                this.draw("seconds", s);
            }

            if (d === 0 && h === 0 && m === 0 && s === 0) {
                if (this.zeroSecondsFired === false) {
                    this.zeroSecondsFired = true;
                    seconds.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "seconds",
                        value: seconds
                    });

                }
            }

            this._fireEvent("tick", {
                days: d,
                hours: h,
                minutes: m,
                seconds: s
            });
        },

        draw: function(part, value){
            var element = this.element, o = this.options;
            var digits, digits_length, digit_value, digit_current, digit;
            var len, i, duration = 900;

            var slideDigit = function(digit, value){
                var digit_copy, height = digit.height();

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: -1 * height + 'px'
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0
                        },
                        dur: duration,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            var fadeDigit = function(digit, value){
                var digit_copy;
                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    opacity: 0
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            opacity: 0
                        },
                        dur: duration / 2,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            var zoomDigit = function(digit, value) {
                var digit_copy, height = digit.height(), fs = parseInt(digit.style("font-size"));

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: 0,
                    left: 0,
                    opacity: 1
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0,
                            fontSize: 0
                        },
                        dur: duration,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1,
                            fontSize: [0, fs]
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            value = ""+value;

            if (value.length === 1) {
                value = '0'+value;
            }

            len = value.length;

            digits = element.find("."+part+" .digit:not(-old-digit)");
            digits_length = digits.length;

            for(i = 0; i < len; i++){
                digit = digits.eq(digits_length - 1).find(".digit-value");
                digit_value = Math.floor( parseInt(value) / Math.pow(10, i) ) % 10;
                digit_current = parseInt(digit.text());

                digits_length--;

                if (digit_current === digit_value) {
                    continue;
                }

                switch ((""+o.animate).toLowerCase()) {
                    case "slide": slideDigit(digit, digit_value); break;
                    case "fade": fadeDigit(digit, digit_value); break;
                    case "zoom": zoomDigit(digit, digit_value); break;
                    default: digit.html(digit_value);
                }
            }
        },

        start: function(){
            var that = this, element = this.element;

            if (element.data("paused") === false) {
                return;
            }

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.data("paused", false);

            this._setBreakpoint();
            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        stop: function(){
            var element = this.element;
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            element.data("paused", true);
            element.find(".digit").html("0");
            this.current = {
                d: 0, h:0, m: 0, s:0
            };
        },

        pause: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            this.element.data("paused", true);
        },

        resume: function(){
            var that = this;

            this.element.data("paused", false);
            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        reset: function(){
            var that = this, element = this.element, o = this.options;

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.find(".part").removeClass(o.clsZero);
            element.find(".digit").html("0");

            this._setBreakpoint();

            element.data("paused", false);

            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        togglePlay: function(){
            if (this.element.attr("data-pause") === true) {
                this.pause();
            } else {
                this.start();
            }
        },

        isPaused: function(){
            return this.element.data("paused");
        },

        getBreakpoint: function(asDate){
            return asDate === true ? new Date(this.breakpoint) : this.breakpoint;
        },

        getLeft: function(){
            var dm = 24*60*60*1000, hm = 60*60*1000, mm = 60*1000, sm = 1000;
            var now = (new Date()).getTime();
            var left_seconds = Math.floor(this.breakpoint - now);
            return {
                days: Math.round(left_seconds / dm),
                hours: Math.round(left_seconds / hm),
                minutes: Math.round(left_seconds / mm),
                seconds: Math.round(left_seconds / sm)
            };
        },

        i18n: function(val){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];


            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];

            $.each(parts, function(){
                var cls = ".part." + this;
                var part = element.find(cls);
                part.attr("data-label", that.locale["calendar"]["time"][this]);
            });
        },

        changeAttrLocale: function(){
            var element = this.element;
            var locale = element.attr('data-locale');
            this.i18n(locale);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-pause": this.togglePlay(); break;
                case "data-locale": this.changeAttrLocale(); break;
            }
        },

        destroy: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            $(document).off("visibilitychange", {ns: this.id});

            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CounterDefaultConfig = {
        startOnViewport: true,
        counterDeferred: 0,
        duration: 2000,
        value: 0,
        from: 0,
        timeout: 0,
        delimiter: ",",
        prefix: "",
        suffix: "",
        onStart: Metro.noop,
        onStop: Metro.noop,
        onTick: Metro.noop,
        onCounterCreate: Metro.noop
    };

    Metro.counterSetup = function (options) {
        CounterDefaultConfig = $.extend({}, CounterDefaultConfig, options);
    };

    if (typeof window["metroCounterSetup"] !== undefined) {
        Metro.counterSetup(window["metroCounterSetup"]);
    }

    Metro.Component('counter', {
        init: function( options, elem ) {
            this._super(elem, options, CounterDefaultConfig, {
                numbers: [],
                html: $(elem).html(),
                started: false,
                id: Utils.elementId("counter")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("counter-create");
            this._run();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $.window().on("scroll", function(){
                if (o.startOnViewport === true && Utils.inViewport(element[0]) && !that.started) {
                    that.start();
                }
            }, {ns: this.id})
        },

        _run: function(){
            var element = this.element, o = this.options;

            this.started = false;

            if (o.startOnViewport !== true) {
                this.start();
            } else {
                if (Utils.inViewport(element[0])) {
                    this.start();
                }
            }
        },

        startInViewport: function(val, from){
            var o = this.options;

            if (Utils.isValue(from)) {
                o.from = +from;
            }

            if (Utils.isValue(val)) {
                o.value = +val;
            }
            this._run();
        },

        start: function(val, from){
            var that = this, element = this.element, o = this.options;

            if (Utils.isValue(from)) {
                o.from = +from;
            }

            if (Utils.isValue(val)) {
                o.value = +val;
            }

            this.started = true;

            this._fireEvent("start");

            element.animate({
                draw: {
                    innerHTML: [o.from, o.value]
                },
                defer: o.timeout,
                dur: o.duration,
                onFrame: function () {
                    that._fireEvent("tick", {
                        value: +this.innerHTML
                    });
                    this.innerHTML = o.prefix + Number(this.innerHTML).format(0, 0, o.delimiter) + o.suffix
                },
                onDone: function(){
                    that._fireEvent("stop");
                }
            })
        },

        reset: function(){
            this.started = false;
            this.element.html(this.html);
        },

        changeAttribute: function(attr, val){
            var o = this.options;

            if (attr === "data-value") {
                o.value = +val;
            }
            if (attr === "data-from") {
                o.from = +val;
            }
        },

        destroy: function(){
            $.window().off("scroll", {ns: this.id});
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CubeDefaultConfig = {
        cubeDeferred: 0,
        rules: null,
        color: null,
        flashColor: null,
        flashInterval: 1000,
        numbers: false,
        offBefore: true,
        attenuation: .3,
        stopOnBlur: false,
        cells: 4,
        margin: 8,
        showAxis: false,
        axisStyle: "arrow", //line
        cellClick: false,
        autoRestart: 5000,

        clsCube: "",
        clsCell: "",
        clsSide: "",
        clsSideLeft: "",
        clsSideRight: "",
        clsSideTop: "",
        clsSideLeftCell: "",
        clsSideRightCell: "",
        clsSideTopCell: "",
        clsAxis: "",
        clsAxisX: "",
        clsAxisY: "",
        clsAxisZ: "",

        custom: Metro.noop,
        onTick: Metro.noop,
        onCubeCreate: Metro.noop
    };

    Metro.cubeSetup = function (options) {
        CubeDefaultConfig = $.extend({}, CubeDefaultConfig, options);
    };

    if (typeof window["metroCubeSetup"] !== undefined) {
        Metro.cubeSetup(window["metroCubeSetup"]);
    }

    Metro.cubeDefaultRules = [
        {
            on: {'top': [16],      'left': [4],         'right': [1]},
            off: {'top': [13, 4],   'left': [1, 16],     'right': [13, 4]}
        },
        {
            on: {'top': [12, 15],  'left': [3, 8],      'right': [2, 5]},
            off: {'top': [9, 6, 3], 'left': [5, 10, 15], 'right': [14, 11, 8]}
        },
        {
            on: {'top': [11],      'left': [7],         'right': [6]},
            off: {'top': [1, 2, 5], 'left': [9, 13, 14], 'right': [15, 12, 16]}
        },
        {
            on: {'top': [8, 14],   'left': [2, 12],     'right': [9, 3]},
            off: {'top': [16],      'left': [4],         'right': [1]}
        },
        {
            on: {'top': [10, 7],   'left': [6, 11],     'right': [10, 7]},
            off: {'top': [12, 15],  'left': [3, 8],      'right': [2, 5]}
        },
        {
            on: {'top': [13, 4],   'left': [1, 16],     'right': [13, 4]},
            off: {'top': [11],      'left': [7],         'right': [6]}
        },
        {
            on: {'top': [9, 6, 3], 'left': [5, 10, 15], 'right': [14, 11, 8]},
            off: {'top': [8, 14],   'left': [2, 12],     'right': [9, 3]}
        },
        {
            on: {'top': [1, 2, 5], 'left': [9, 13, 14], 'right': [15, 12, 16]},
            off: {'top': [10, 7],   'left': [6, 11],     'right': [10, 7]}
        }
    ];

    Metro.Component('cube', {
        init: function( options, elem ) {
            this._super(elem, options, CubeDefaultConfig, {
                id: Utils.elementId("cube"),
                rules: null,
                interval: false,
                ruleInterval: false,
                running: false,
                intervals: []
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.rules === null) {
                this.rules = Metro.cubeDefaultRules;
            } else {
                this._parseRules(o.rules);
            }

            this._createCube();
            this._createEvents();

            this._fireEvent("cube-create", {
                element: element
            });
        },

        _parseRules: function(rules){

            if (rules === undefined || rules === null) {
                return false;
            }

            if (Utils.isObject(rules)) {
                this.rules = Utils.isObject(rules);
                return true;
            } else {
                try {
                    this.rules = JSON.parse(rules);
                    return true;
                } catch (err) {
                    console.warn("Unknown or empty rules for cell flashing!");
                    return false;
                }
            }
        },

        _createCube: function(){
            var element = this.element, o = this.options;
            var sides = ['left', 'right', 'top'];
            var id = Utils.elementId("cube");
            var cells_count = Math.pow(o.cells, 2);

            element.addClass("cube").addClass(o.clsCube);

            if (!element.attr('id')) {
                element.attr('id', id);
            }

            this.id = element.attr('id');

            this._createCssForFlashColor();
            this._createCssForCellSize();

            $.each(sides, function(){
                var side, cell, i;

                side = $("<div>").addClass("side " + this+"-side").addClass(o.clsSide).appendTo(element);

                if (this === 'left') {side.addClass(o.clsSideLeft);}
                if (this === 'right') {side.addClass(o.clsSideRight);}
                if (this === 'top') {side.addClass(o.clsSideTop);}

                for(i = 0; i < cells_count; i++) {
                    cell = $("<div>").addClass("cube-cell").addClass("cell-id-"+(i+1)).addClass(o.clsCell);
                    cell.data("id", i + 1).data("side", this);
                    cell.appendTo(side);
                    if (o.numbers === true) {
                        cell.html(i + 1);
                    }
                }
            });

            var cells  = element.find(".cube-cell");
            if (o.color !== null) {
                if (Utils.isColor(o.color)) {
                    cells.css({
                        backgroundColor: o.color,
                        borderColor: o.color
                    })
                } else {
                    cells.addClass(o.color);
                }
            }

            var axis = ['x', 'y', 'z'];
            $.each(axis, function(){
                var axis_name = this;
                var ax = $("<div>").addClass("axis " + o.axisStyle).addClass("axis-"+axis_name).addClass(o.clsAxis);
                if (axis_name === "x") ax.addClass(o.clsAxisX);
                if (axis_name === "y") ax.addClass(o.clsAxisY);
                if (axis_name === "z") ax.addClass(o.clsAxisZ);
                ax.appendTo(element);
            });

            if (o.showAxis === false) {
                element.find(".axis").hide();
            }

            this._run();
        },

        _run: function(){
            var that = this, element = this.element, o = this.options;
            var interval = 0;

            clearInterval(this.interval);
            element.find(".cube-cell").removeClass("light");

            if (o.custom !== Metro.noop) {
                Utils.exec(o.custom, [element]);
            } else {

                element.find(".cube-cell").removeClass("light");

                that._start();

                interval = Utils.isObject(this.rules) ? Utils.objectLength(this.rules) : 0;

                this.interval = setInterval(function(){
                    that._start();
                }, interval * o.flashInterval);
            }
        },

        _createCssForCellSize: function(){
            var element = this.element, o = this.options;
            var sheet = Metro.sheet;
            var width;
            var cell_size;

            if (o.margin === 8 && o.cells === 4) {
                return ;
            }

            width = parseInt(Utils.getStyleOne(element, 'width'));
            cell_size = Math.ceil((width / 2 - o.margin * o.cells * 2) / o.cells);
            Utils.addCssRule(sheet, "#"+element.attr('id')+" .side .cube-cell", "width: "+cell_size+"px!important; height: "+cell_size+"px!important; margin: " + o.margin + "px!important;");
        },

        _createCssForFlashColor: function(){
            var element = this.element, o = this.options;
            var sheet = Metro.sheet;
            var rule1;
            var rule2;
            var rules1 = [];
            var rules2 = [];
            var i;

            if (o.flashColor === null) {
                return ;
            }

            rule1 = "0 0 10px " + Utils.hexColorToRgbA(o.flashColor, 1);
            rule2 = "0 0 10px " + Utils.hexColorToRgbA(o.flashColor, o.attenuation);

            for(i = 0; i < 3; i++) {
                rules1.push(rule1);
                rules2.push(rule2);
            }

            Utils.addCssRule(sheet, "@keyframes pulsar-cell-"+element.attr('id'), "0%, 100% { " + "box-shadow: " + rules1.join(",") + "} 50% { " + "box-shadow: " + rules2.join(",") + " }");
            Utils.addCssRule(sheet, "#"+element.attr('id')+" .side .cube-cell.light", "animation: pulsar-cell-" + element.attr('id') + " 2.5s 0s ease-out infinite; " + "background-color: " + o.flashColor + "!important; border-color: " + o.flashColor+"!important;");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $(window).on(Metro.events.blur, function(){
                if (o.stopOnBlur === true && that.running === true) {
                    that._stop();
                }
            }, {ns: element.attr("id")});

            $(window).on(Metro.events.focus, function(){
                if (o.stopOnBlur === true && that.running === false) {
                    that._start();
                }
            }, {ns: element.attr("id")});

            element.on(Metro.events.click, ".cube-cell", function(){
                if (o.cellClick === true) {
                    var cell = $(this);
                    cell.toggleClass("light");
                }
            });
        },

        _start: function(){
            var that = this, element = this.element;

            element.find(".cube-cell").removeClass("light");

            this.running = true;

            $.each(this.rules, function(index, rule){
                that._execRule(index, rule);
            });
        },

        _stop: function(){
            this.running = false;
            clearInterval(this.interval);
            $.each(this.intervals, function(){
                clearInterval(this);
            })
        },

        _tick: function(index, speed){
            var that = this, o = this.options;
            if (speed === undefined) {
                speed = o.flashInterval * index;
            }

            var interval = setTimeout(function(){

                that._fireEvent("tick", {
                    index: index
                });

                clearInterval(interval);
                Utils.arrayDelete(that.intervals, interval);
            }, speed);
            this.intervals.push(interval);
        },

        _toggle: function(cell, func, time, speed){
            var that = this;
            if (speed === undefined) {
                speed = this.options.flashInterval * time;
            }
            var interval = setTimeout(function(){
                cell[func === 'on' ? 'addClass' : 'removeClass']("light");
                clearInterval(interval);
                Utils.arrayDelete(that.intervals, interval);
            }, speed);
            this.intervals.push(interval);
        },

        start: function(){
            this._start();
        },

        stop: function(){
            this._stop();
        },

        toRule: function(index, speed){
            var that = this, element = this.element, o = this.options;
            var rules = this.rules;

            if (rules === null || rules === undefined || rules[index] === undefined) {
                return ;
            }
            clearInterval(this.ruleInterval);
            this.ruleInterval = false;
            this.stop();
            element.find(".cube-cell").removeClass("light");
            for (var i = 0; i <= index; i++) {
                this._execRule(i, rules[i], speed);
            }
            if (Utils.isInt(o.autoRestart) && o.autoRestart > 0) {
                this.ruleInterval = setTimeout(function(){
                    that._run();
                }, o.autoRestart);
            }
        },

        _execRule: function(index, rule, speed){
            var that = this, element = this.element;
            var sides = ['left', 'right', 'top'];

            this._tick(index, speed);

            $.each(sides, function(){
                var side_class = "."+this+"-side";
                var side_name = this;
                var cells_on = rule["on"] !== undefined && rule["on"][side_name] !== undefined ? rule["on"][side_name] : false;
                var cells_off = rule["off"] !== undefined && rule["off"][side_name] !== undefined ? rule["off"][side_name] : false;

                if (cells_on !== false) $.each(cells_on, function(){
                    var cell_index = this;
                    var cell = element.find(side_class + " .cell-id-"+cell_index);

                    that._toggle(cell, 'on', index, speed);
                });

                if (cells_off !== false) $.each(cells_off, function(){
                    var cell_index = this;
                    var cell = element.find(side_class + " .cell-id-"+cell_index);

                    that._toggle(cell, 'off', index, speed);
                });
            });
        },

        rule: function(r){
            if (r === undefined) {
                return this.rules;
            }

            if (this._parseRules(r) !== true) {
                return ;
            }
            this.options.rules = r;
            this.stop();
            this.element.find(".cube-cell").removeClass("light");
            this._run();
        },

        axis: function(show){
            var func = show === true ? "show" : "hide";
            this.element.find(".axis")[func]();
        },

        changeRules: function(){
            var element = this.element, o = this.options;
            var rules = element.attr("data-rules");
            if (this._parseRules(rules) !== true) {
                return ;
            }
            this.stop();
            element.find(".cube-cell").removeClass("light");
            o.rules = rules;
            this._run();
        },

        changeAxisVisibility: function(){
            var element = this.element;
            var visibility = JSON.parse(element.attr("data-show-axis")) === true;
            var func = visibility ? "show" : "hide";
            element.find(".axis")[func]();
        },

        changeAxisStyle: function(){
            var element = this.element;
            var style = element.attr("data-axis-style");

            element.find(".axis").removeClass("arrow line no-style").addClass(style);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-rules": this.changeRules(); break;
                case "data-show-axis": this.changeAxisVisibility(); break;
                case "data-axis-style": this.changeAxisStyle(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            clearInterval(this.interval);
            this.interval = null;

            $(window).off(Metro.events.blur, {ns: element.attr("id")});
            $(window).off(Metro.events.focus,{ns: element.attr("id")});

            element.off(Metro.events.click, ".cube-cell");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DatePickerDefaultConfig = {
        label: "",
        datepickerDeferred: 0,
        gmt: 0,
        format: "%Y-%m-%d",
        inputFormat: null,
        locale: METRO_LOCALE,
        value: null,
        distance: 3,
        month: true,
        day: true,
        year: true,
        minYear: null,
        maxYear: null,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsMonth: "",
        clsDay: "",
        clsYear: "",
        clsLabel: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onDatePickerCreate: Metro.noop
    };

    Metro.datePickerSetup = function (options) {
        DatePickerDefaultConfig = $.extend({}, DatePickerDefaultConfig, options);
    };

    if (typeof window["metroDatePickerSetup"] !== undefined) {
        Metro.datePickerSetup(window["metroDatePickerSetup"]);
    }

    Metro.Component('date-picker', {
        init: function( options, elem ) {
            this._super(elem, options, DatePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: new Date(),
                locale: null,
                offset: (new Date()).getTimezoneOffset() / 60 + 1,
                listTimer: {
                    day: null,
                    month: null,
                    year: null
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (Utils.isValue(element.val())) {
                o.value = element.val();
            }

            if (Utils.isValue(o.value)) {
                if (Utils.isValue(o.inputFormat)) {
                    this.value = (""+o.value).toDate(o.inputFormat);
                } else {
                    if (Utils.isDate(o.value)) {
                        this.value = new Date(o.value);
                    }
                }
            }

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.minYear === null) {
                o.minYear = (new Date()).getFullYear() - 100;
            }

            if (o.maxYear === null) {
                o.maxYear = (new Date()).getFullYear() + 100;
            }

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("datepicker-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, month, day, year, i, j;
            var dateWrapper, selectWrapper, selectBlock, actionBlock;

            var id = Utils.elementId("datepicker");

            picker = $("<div>").attr("id", id).addClass("wheel-picker date-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            dateWrapper = $("<div>").addClass("date-wrapper").appendTo(picker);

            if (o.month === true) {
                month = $("<div>").addClass("month").addClass(o.clsPart).addClass(o.clsMonth).appendTo(dateWrapper);
            }
            if (o.day === true) {
                day = $("<div>").addClass("day").addClass(o.clsPart).addClass(o.clsDay).appendTo(dateWrapper);
            }
            if (o.year === true) {
                year = $("<div>").addClass("year").addClass(o.clsPart).addClass(o.clsYear).appendTo(dateWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);

            if (o.month === true) {
                month = $("<ul>").addClass("sel-month").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            if (o.day === true) {
                day = $("<ul>").addClass("sel-day").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
                for (i = 0; i < 31; i++) {
                    $("<li>").addClass("js-day-"+i+" js-day-real-"+(i+1)).html(i + 1).data("value", i + 1).appendTo(day);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
            }

            if (o.year === true) {
                year = $("<ul>").addClass("sel-year").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
                for (i = o.minYear, j = 0; i <= o.maxYear; i++, j++) {
                    $("<li>").addClass("js-year-"+ j + " js-year-real-" + i).html(i).data("value", i).appendTo(year);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: picker.attr("id")});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: picker.attr("id")});
                    $(document).off(Metro.events.stop, {ns: picker.attr("id")});
                }, {ns: picker.attr("id")});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var m, d, y;
                var sm = picker.find(".sel-month li.active"),
                    sd = picker.find(".sel-day li.active"),
                    sy = picker.find(".sel-year li.active");

                m = sm.length === 0 ? that.value.getMonth() : sm.data("value");
                d = sd.length === 0 ? that.value.getDate() : sd.data("value");
                y = sy.length === 0 ? that.value.getFullYear() : sy.data("value");

                that.value = new Date(y, m, d);
                that._correct();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(["month", "day", "year"], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (that.isOpen) {
                        if (that.listTimer[part]) {
                            clearTimeout(that.listTimer[part]);
                            that.listTimer[part] = null;
                        }

                        if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                            var target, targetElement, scrollTop;

                            that.listTimer[part] = null;

                            target = Math.round((Math.ceil(list.scrollTop()) / 40));

                            targetElement = list.find(".js-" + part + "-" + target);
                            scrollTop = targetElement.position().top - (o.distance * 40);

                            list.find(".active").removeClass("active");

                            list[0].scrollTop = scrollTop;
                            targetElement.addClass("active");
                            Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                        }, scrollLatency);
                    }
                })
            });
        },

        _correct: function(){
            var m = this.value.getMonth(),
                d = this.value.getDate(),
                y = this.value.getFullYear();

            this.value = new Date(y, m, d);
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var m = this.locale['months'][this.value.getMonth()],
                d = this.value.getDate(),
                y = this.value.getFullYear();

            if (o.month === true) {
                picker.find(".month").html(m);
            }
            if (o.day === true) {
                picker.find(".day").html(d);
            }
            if (o.year === true) {
                picker.find(".year").html(y);
            }

            element.val(this.value.format(o.format, o.locale)).trigger("change");

            this._fireEvent("set", {
                value: this.value,
                elementValue: element.val(),
                picker: picker
            })
        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var m = this.value.getMonth(), d = this.value.getDate() - 1, y = this.value.getFullYear();
            var m_list, d_list, y_list;
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            picker.find("li").removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            if (o.month === true) {
                m_list = picker.find(".sel-month");
                m_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: m_list.find("li.js-month-" + m).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.day === true) {
                d_list = picker.find(".sel-day");
                d_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: d_list.find("li.js-day-" + d).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.year === true) {
                y_list = picker.find(".sel-year");
                y_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: y_list.find("li.js-year-real-" + y).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }

            this.isOpen = true;

            this._fireEvent("open", {
                value: this.value,
                picker: picker
            })

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                value: this.value,
                picker: picker
            });
        },

        val: function(value){
            var o = this.options;

            if (!Utils.isValue(value)) {
                return this.element.val();
            }

            if (Utils.isValue(o.inputFormat)) {
                this.value = (""+value).toDate(o.inputFormat);
            } else {
                this.value = new Date(value);
            }

            // this.value = (new Date(t)).addHours(this.offset);
            this._set();
        },

        date: function(t){
            if (t === undefined) {
                return this.value;
            }

            try {
                this.value = new Date(t.format("%Y-%m-%d"));
                this._set();
            } catch (e) {
                return false;
            }
        },

        i18n: function(locale){
            var element = this.element, o = this.options;
            var month, i;

            o.locale = locale ? locale : element.attr("data-locale");
            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.month === true) {
                month =  element.closest(".date-picker").find(".sel-month").html("");
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            this._set();
        },


        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName, newValue){
            switch (attributeName) {
                case "disabled": this.toggleState(); break;
                case "data-value": this.val(newValue); break;
                case "data-locale": this.i18n(newValue); break;
                case "data-format":
                    this.options.format = newValue;
                    this._set();
                    break;
            }
        },

        destroy: function(){
            var element = this.element, picker = this.picker;

            $.each(["moth", "day", "year"], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $.each($(".date-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "datepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DialogDefaultConfig = {
        dialogDeferred: 0,
        closeButton: false,
        leaveOverlayOnClose: false,
        toTop: false,
        toBottom: false,
        locale: METRO_LOCALE,
        title: "",
        content: "",
        actions: {},
        actionsAlign: "right",
        defaultAction: true,
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        overlayClickClose: false,
        width: '480',
        height: 'auto',
        shadow: true,
        closeAction: true,
        clsDialog: "",
        clsTitle: "",
        clsContent: "",
        clsAction: "",
        clsDefaultAction: "",
        clsOverlay: "",
        autoHide: 0,
        removeOnClose: false,
        show: false,

        _runtime: false,

        onShow: Metro.noop,
        onHide: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onDialogCreate: Metro.noop
    };

    Metro.dialogSetup = function (options) {
        DialogDefaultConfig = $.extend({}, DialogDefaultConfig, options);
    };

    if (typeof window["metroDialogSetup"] !== undefined) {
        Metro.dialogSetup(window["metroDialogSetup"]);
    }

    Metro.Component('dialog', {
        _counter: 0,

        init: function( options, elem ) {
            this._super(elem, options, DialogDefaultConfig, {
                interval: null,
                overlay: null,
                id: Utils.elementId("dialog")
            });

            return this;
        },

        _create: function(){
            var o = this.options;
            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];
            this._build();
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var body = $("body");
            var overlay;

            element.addClass("dialog");

            if (o.shadow === true) {
                element.addClass("shadow-on");
            }

            if (o.title !== "") {
                this.setTitle(o.title);
            }

            if (o.content !== "") {
                this.setContent(o.content);
            }

            if (o.defaultAction === true || (o.actions !== false && typeof o.actions === 'object' && Utils.objectLength(o.actions) > 0)) {
                var buttons = element.find(".dialog-actions");
                var button;

                if (buttons.length === 0) {
                    buttons = $("<div>").addClass("dialog-actions").addClass("text-"+o.actionsAlign).appendTo(element);
                }

                if (o.defaultAction === true && (Utils.objectLength(o.actions) === 0 && element.find(".dialog-actions > *").length === 0)) {
                    button = $("<button>").addClass("button js-dialog-close").addClass(o.clsDefaultAction).html(this.locale["buttons"]["ok"]);
                    button.appendTo(buttons);
                }

                if (Utils.isObject(o.actions)) $.each(Utils.isObject(o.actions), function(){
                    var item = this;
                    button = $("<button>").addClass("button").addClass(item.cls).html(item.caption);
                    if (item.onclick !== undefined) button.on(Metro.events.click, function(){
                        Utils.exec(item.onclick, [element]);
                    });
                    button.appendTo(buttons);
                });
            }

            if (o.overlay === true) {
                overlay  = this._overlay();
                this.overlay = overlay;
            }

            if (o.closeAction === true) {
                element.on(Metro.events.click, ".js-dialog-close", function(){
                    that.close();
                });
            }

            var closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer js-dialog-close");
                closer.appendTo(element);
            }
            if (o.closeButton !== true) {
                closer.hide();
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.addClass(o.clsDialog);
            element.find(".dialog-title").addClass(o.clsTitle);
            element.find(".dialog-content").addClass(o.clsContent);
            element.find(".dialog-actions").addClass(o.clsAction);

            element.appendTo(body);

            if (o.show) {
                this.open();
            }

            $(window).on(Metro.events.resize, function(){
                that.setPosition();
            }, {ns: this.id});

            this._fireEvent("dialog-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        hide: function(callback){
            var element = this.element, o = this.options;
            var timeout = 0;
            if (o.onHide !== Metro.noop) {
                timeout = 500;

                this._fireEvent("hide");
            }
            setTimeout(function(){
                Utils.exec(callback, null, element[0]);
                element.css({
                    visibility: "hidden",
                    top: "100%"
                });
            }, timeout);
        },

        show: function(callback){
            var element = this.element;
            this.setPosition();
            element.css({
                visibility: "visible"
            });

            this._fireEvent("show");

            Utils.exec(callback, null, element[0]);
        },

        setPosition: function(){
            var element = this.element, o = this.options;
            var top, bottom;
            if (o.toTop !== true && o.toBottom !== true) {
                top = ( $(window).height() - element.outerHeight() ) / 2;
                if (top < 0) {
                    top = 0;
                }
                bottom = "auto";
            } else {
                if (o.toTop === true) {
                    top = 0;
                    bottom = "auto";
                }
                if (o.toTop !== true && o.toBottom === true) {
                    bottom = 0;
                    top = "auto";
                }
            }
            element.css({
                top: top,
                bottom: bottom,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".dialog-content");
            if (content.length === 0) {
                content = $("<div>").addClass("dialog-content");
                content.appendTo(element);
            }

            if (!Utils.isQ(c) && Utils.isFunc(c)) {
                c = Utils.exec(c);
            }

            if (Utils.isQ(c)) {
                c.appendTo(content);
            } else {
                content.html(c);
            }
        },

        setTitle: function(t){
            var element = this.element;
            var title = element.find(".dialog-title");
            if (title.length === 0) {
                title = $("<div>").addClass("dialog-title");
                title.appendTo(element);
            }
            title.html(t);
        },

        close: function(){
            var that = this, element = this.element, o = this.options;

            if (!Utils.bool(o.leaveOverlayOnClose)) {
                $('body').find('.overlay').remove();
            }

            this.hide(function(){
                element.data("open", false);

                that._fireEvent("close")

                if (o.removeOnClose === true) {
                    element.remove();
                }
            });
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            if (o.overlay === true && $(".overlay").length === 0) {
                this.overlay.appendTo($("body"));
                if (o.overlayClickClose === true) {
                    this.overlay.on(Metro.events.click, function(){
                        that.close();
                    });
                }
            }

            this.show(function(){

                that._fireEvent("open");

                element.data("open", true);
                if (parseInt(o.autoHide) > 0) {
                    setTimeout(function(){
                        that.close();
                    }, parseInt(o.autoHide));
                }
            });
        },

        toggle: function(){
            var element = this.element;
            if (element.data('open')) {
                this.close();
            } else {
                this.open();
            }
        },

        isOpen: function(){
            return this.element.data('open') === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".js-dialog-close");
            element.find(".button").off(Metro.events.click);
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });

    Metro.dialog = {
        isDialog: function(el){
            return Utils.isMetroObject(el, "dialog");
        },

        open: function(el, content, title){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin(el, "dialog");
            if (title !== undefined) {
                dialog.setTitle(title);
            }
            if (content !== undefined) {
                dialog.setContent(content);
            }
            dialog.open();
        },

        close: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").close();
        },

        toggle: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").toggle();
        },

        isOpen: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").isOpen();
        },

        remove: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin($(el)[0], "dialog");
            dialog.options.removeOnClose = true;
            dialog.close();
        },

        create: function(options){
            var dlg;

            dlg = $("<div>").appendTo($("body"));

            var dlg_options = $.extend({}, {
                show: true,
                closeAction: true,
                removeOnClose: true
            }, (options !== undefined ? options : {}));

            dlg_options._runtime = true;

            return Metro.makePlugin(dlg, "dialog", dlg_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DonutDefaultConfig = {
        donutDeferred: 0,
        size: 100,
        radius: 50,
        hole: .8,
        value: 0,
        background: "#ffffff",
        color: "",
        stroke: "#d1d8e7",
        fill: "#49649f",
        fontSize: 24,
        total: 100,
        cap: "%",
        showText: true,
        showValue: false,
        animate: 0,
        onChange: Metro.noop,
        onDonutCreate: Metro.noop
    };

    Metro.donutSetup = function (options) {
        DonutDefaultConfig = $.extend({}, DonutDefaultConfig, options);
    };

    if (typeof window["metroDonutSetup"] !== undefined) {
        Metro.donutSetup(window["metroDonutSetup"]);
    }

    Metro.Component('donut', {
        init: function( options, elem ) {
            this._super(elem, options, DonutDefaultConfig, {
                value: 0,
                animation_change_interval: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var html = "";
            var r = o.radius  * (1 - (1 - o.hole) / 2);
            var width = o.radius * (1 - o.hole);
            var transform = 'rotate(-90 ' + o.radius + ',' + o.radius + ')';
            var fontSize = r * o.hole * 0.6;

            element.addClass("donut");

            element.css({
                width: o.size,
                height: o.size,
                background: o.background
            });

            html += "<svg>";
            html += "   <circle class='donut-back' r='"+(r)+"px' cx='"+(o.radius)+"px' cy='"+(o.radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.stroke)+"' stroke-width='"+(width)+"'/>";
            html += "   <circle class='donut-fill' r='"+(r)+"px' cx='"+(o.radius)+"px' cy='"+(o.radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.fill)+"' stroke-width='"+(width)+"'/>";
            if (o.showText === true) html += "   <text   class='donut-title' x='"+(o.radius)+"px' y='"+(o.radius)+"px' dy='"+(fontSize/3)+"px' text-anchor='middle' fill='"+(o.color !== "" ? o.color: o.fill)+"' font-size='"+(fontSize)+"px'>0"+(o.cap)+"</text>";
            html += "</svg>";

            element.html(html);

            this.val(o.value);

            this._fireEvent("donut-create", {
                element: element
            });
        },

        _setValue: function(v){
            var element = this.element, o = this.options;

            var fill = element.find(".donut-fill");
            var title = element.find(".donut-title");
            var r = o.radius  * (1 - (1 - o.hole) / 2);
            var circumference = Math.round(2 * Math.PI * r);
            var title_value = (o.showValue ? v : Utils.percent(o.total, v, true))/*  + (o.cap)*/;
            var fill_value = Math.round(((+v * circumference) / o.total));// + ' ' + circumference;

            var sda = fill.attr("stroke-dasharray");
            if (typeof sda === "undefined") {
                sda = 0;
            } else {
                sda = +sda.split(" ")[0];
            }
            var delta = fill_value - sda;

            fill.animate({
                draw: function(t, p){
                    $(this).attr("stroke-dasharray", (sda + delta * p ) + ' ' + circumference);
                },
                dur: o.animate
            })
            title.animate({
                draw: {
                    innerHTML: title_value
                },
                dur: o.animate,
                onFrame: function(){
                    this.innerHTML += o.cap;
                }
            });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined) {
                return this.value
            }

            if (parseInt(v) < 0 || parseInt(v) > o.total) {
                return false;
            }

            this._setValue(v);

            this.value = v;

            this._fireEvent("change", {
                value: this.value
            });
        },

        changeValue: function(){
            this.val(this.element.attr("data-value"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value": this.changeValue(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DoubleSliderDefaultConfig = {
        doublesliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        valueMin: null,
        valueMax: null,
        hint: false,
        hintAlways: false,
        hintPositionMin: Metro.position.TOP,
        hintPositionMax: Metro.position.TOP,
        hintMaskMin: "$1",
        hintMaskMax: "$1",
        target: null,
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsMarker: "",
        clsMarkerMin: "",
        clsMarkerMax: "",
        clsHint: "",
        clsHintMin: "",
        clsHintMax: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onDoubleSliderCreate: Metro.noop
    };

    Metro.doubleSliderSetup = function (options) {
        DoubleSliderDefaultConfig = $.extend({}, DoubleSliderDefaultConfig, options);
    };

    if (typeof window["metroDoubleSliderSetup"] !== undefined) {
        Metro.doubleSliderSetup(window["metroDoubleSliderSetup"]);
    }

    Metro.Component('double-slider', {
        init: function( options, elem ) {
            this._super(elem, options, DoubleSliderDefaultConfig, {
                slider: null,
                valueMin: null,
                valueMax: null,
                keyInterval: false,
                id: Utils.elementId("slider")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.valueMin = Utils.isValue(o.valueMin) ? +o.valueMin : +o.min;
            this.valueMax = Utils.isValue(o.valueMax) ? +o.valueMax : +o.max;

            this._createSlider();
            this._createEvents();

            this.val(this.valueMin, this.valueMax);

            this._fireEvent("double-slider-create", {
                element: element
            })
        },

        _createSlider: function(){
            var element = this.element, o = this.options;
            var slider_wrapper = $("<div>").addClass("slider-wrapper");
            var slider = $("<div>").addClass("slider").addClass(o.clsSlider).addClass(this.elem.className);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var markerMin = $("<button>").attr("type", "button").addClass("marker marker-min").addClass(o.clsMarker).addClass(o.clsMarkerMin);
            var markerMax = $("<button>").attr("type", "button").addClass("marker marker-max").addClass(o.clsMarker).addClass(o.clsMarkerMax);
            var hintMin = $("<div>").addClass("hint hint-min").addClass(o.hintPositionMin + "-side").addClass(o.clsHint).addClass(o.clsHintMin);
            var hintMax = $("<div>").addClass("hint hint-max").addClass(o.hintPositionMax + "-side").addClass(o.clsHint).addClass(o.clsHintMax);
            var i;

            if (o.size > 0) {
                slider.outerWidth(o.size);
            }

            slider.insertBefore(element);
            element.appendTo(slider);
            slider_wrapper.insertBefore(slider);
            slider.appendTo(slider_wrapper);

            backside.appendTo(slider);
            complete.appendTo(slider);
            markerMin.appendTo(slider);
            markerMax.appendTo(slider);
            hintMin.appendTo(markerMin);
            hintMax.appendTo(markerMax);

            if (o.hintAlways === true) {
                $([hintMin, hintMax]).css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");

            marker.on(Metro.events.startAll, function(){
                var _marker = $(this);
                var hint = _marker.find(".hint");
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    that._move(e);
                    that._fireEvent("move", {
                        min: that.valueMin,
                        max: that.valueMax
                    });

                }, {ns: that.id});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        min: that.valueMin,
                        max: that.valueMax
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.valueMin, that.valueMax);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = slider.outerWidth() - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;
            var _dec = function(v){
                return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
            };

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(_dec(accuracy));
        },

        _move: function(e){
            var target = $(e.target).closest(".marker");
            var isMin = target.hasClass("marker-min");
            var slider = this.slider;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                markerMin = slider.find(".marker-min"),
                markerMax = slider.find(".marker-max"),
                length = slider.outerWidth(),
                cPix, cStart, cStop;

            cPix = Utils.pageXY(e).x - offset.left - marker_size / 2;

            if (isMin) {
                cStart = 0;
                cStop = parseInt(markerMax.css("left")) - marker_size;
            } else {
                cStart = parseInt(markerMin.css("left")) + marker_size;
                cStop = length - marker_size;
            }

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this[isMin ? "valueMin" : "valueMax"] = this._correct(this._convert(cPix, 'pix2val'));

            this._redraw();
        },

        _hint: function(){
            var that = this, o = this.options, slider = this.slider, hint = slider.find(".hint");

            hint.each(function(){
                var _hint = $(this);
                var isMin = _hint.hasClass("hint-min");
                var _mask = isMin ? o.hintMaskMin : o.hintMaskMax;
                var value = +(isMin ? that.valueMin : that.valueMax) || 0;
                _hint.text(_mask.replace("$1", value.toFixed(Utils.decCount(o.accuracy))))
            });
        },

        _value: function(){
            var element = this.element, o = this.options;
            var v1 = +this.valueMin || 0, v2 = +this.valueMax || 0;
            var value;

            if (o.roundValue) {
                v1 = v1.toFixed(Utils.decCount(o.accuracy));
                v2 = v2.toFixed(Utils.decCount(o.accuracy));
            }

            value = [v1, v2].join(", ");

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value
            });
        },

        _marker: function(){
            var slider = this.slider;
            var markerMin = slider.find(".marker-min");
            var markerMax = slider.find(".marker-max");
            var complete = slider.find(".complete");
            var marker_size = parseInt(Utils.getStyleOne(markerMin, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                $([markerMin, markerMax]).css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (slider_visible) {
                markerMin.css('left', this._convert(this.valueMin, 'val2pix'));
                markerMax.css('left', this._convert(this.valueMax, 'val2pix'));
            } else {
                markerMin.css({
                    'left': (this._convert(this.valueMin, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMin, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
                markerMax.css({
                    'left': (this._convert(this.valueMax, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMax, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
            }

            complete.css({
                "left": this._convert(this.valueMin, 'val2pix'),
                "width": this._convert(this.valueMax, 'val2pix') - this._convert(this.valueMin, 'val2pix')
            });
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        val: function(vMin, vMax){
            var o = this.options;

            if (!Utils.isValue(vMin) && !Utils.isValue(vMax)) {
                return [this.valueMin, this.valueMax];
            }

            if (vMin < o.min) vMin = o.min;
            if (vMax < o.min) vMax = o.min;

            if (vMin > o.max) vMin = o.max;
            if (vMax > o.max) vMax = o.max;

            this.valueMin = this._correct(vMin);
            this.valueMax = this._correct(vMax);

            this._redraw();
        },

        changeValue: function(){
            var element = this.element;
            var valMin = +element.attr("data-value-min");
            var valMax = +element.attr("data-value-max");
            this.val(valMin, valMax);
        },

        disable: function(){
            var element = this.element;
            element.data("disabled", true);
            element.parent().addClass("disabled");
        },

        enable: function(){
            var element = this.element;
            element.data("disabled", false);
            element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value-min": this.changeValue(); break;
                case "data-value-max": this.changeValue(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DragItemsDefaultConfig = {
        dragitemsDeferred: 0,
        target: null,
        dragItem: "li",
        dragMarker: ".drag-item-marker",
        drawDragMarker: false,
        clsDragItemAvatar: "",
        clsDragItem: "",
        canDrag: true,
        onDragStartItem: Metro.noop,
        onDragMoveItem: Metro.noop,
        onDragDropItem: Metro.noop,
        onTarget: Metro.noop,
        onTargetIn: Metro.noop, //TODO
        onTargetOut: Metro.noop, //TODO
        onDragItemsCreate: Metro.noop
    };

    Metro.dragItemsSetup = function (options) {
        DragItemsDefaultConfig = $.extend({}, DragItemsDefaultConfig, options);
    };

    if (typeof window["metroDragItemsSetup"] !== undefined) {
        Metro.dragItemsSetup(window["metroDragItemsSetup"]);
    }

    Metro.Component('drag-items', {
        init: function( options, elem ) {
            this._super(elem, options, DragItemsDefaultConfig, {
                id: Utils.elementId("dragItems"),
                canDrag: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("drag-items-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("drag-items-target");

            if (o.drawDragMarker === true) {
                element.find(o.dragItem).each(function(){
                    $("<span>").addClass("drag-item-marker").appendTo(this);
                })
            }

            o.canDrag ? this.on() : this.off();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var doc = $.document(), body = $.body();
            var offset, shift = {top: 0, left: 0}, width, height;

            var move = function(e, avatar, dragItem){
                var x = Utils.pageXY(e).x, y = Utils.pageXY(e).y;
                var _top = y - shift.top;
                var _left = x - shift.left;

                avatar.css({
                    top: _top,
                    left: _left
                });

                var target = document.elementsFromPoint(x, y).filter(function(el){
                    return $(el).hasClass('drag-items-target');
                });

                if (target.length === 0) {
                    return;
                }

                that._fireEvent("target", {
                    target: target
                });

                var sibling = document.elementsFromPoint(x, y).filter(function(el){
                    var $el = $(el);
                    return $.matches(el, o.dragItem) && !$el.hasClass("dragged-item-avatar");
                })[0];

                if (!Utils.isValue(sibling)) {
                    dragItem.appendTo(target);
                } else {
                    var $sibling = $(sibling);
                    var $sibling_offset = $sibling.offset();
                    var offsetY = y - $sibling_offset.top;
                    var offsetX = x - $sibling_offset.left;
                    var side;
                    var dim = {w: $sibling.width(), h: $sibling.height()};

                    if (offsetX < dim.w / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'left';
                    } else if (offsetX > dim.w * 2 / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'right';
                    } else if (offsetX > dim.w / 3 && offsetX < dim.w * 2 / 3 && offsetY > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (!$sibling.hasClass("dragged-item")) {
                        if (side === "top" || side === "left") {
                            dragItem.insertBefore($sibling);
                        } else {
                            dragItem.insertAfter($sibling);
                        }
                    }
                }
            };

            element.on(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem), function(e_start){
                var dragItem = $(e_start.target).closest(o.dragItem);
                var avatar;

                if (Utils.isRightMouse(e_start)) {
                    return ;
                }

                if (that.canDrag !== true) {
                    return ;
                }

                dragItem.addClass("dragged-item").addClass(o.clsDragItem);
                avatar = $("<div>").addClass("dragged-item-avatar").addClass(o.clsDragItemAvatar);
                offset = dragItem.offset();
                width = dragItem.width();
                height = dragItem.height();
                shift.top = Utils.pageXY(e_start).y - offset.top;
                shift.left = Utils.pageXY(e_start).x - offset.left;

                avatar.css({
                    top: offset.top,
                    left: offset.left,
                    width: width,
                    height: height
                }).appendTo(body);

                that._fireEvent("drag-start-item", {
                    dragItem: dragItem[0],
                    avatar: avatar[0]
                });

                doc.on(Metro.events.moveAll, function(e_move){

                    move(e_move, avatar, dragItem);

                    that._fireEvent("drag-move-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    e_move.preventDefault();

                }, {ns: that.id, passive: false});

                doc.on(Metro.events.stopAll, function(){

                    that._fireEvent("drag-drop-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    dragItem.removeClass("dragged-item").removeClass(o.clsDragItem);
                    avatar.remove();

                    doc.off(Metro.events.moveAll, {ns: that.id});
                    doc.off(Metro.events.stopAll, {ns: that.id});

                }, {ns: that.id});

                if (o.drawDragMarker) {
                    e_start.preventDefault();
                    e_start.stopPropagation();
                }
            });
        },

        on: function(){
            this.canDrag = true;
            this.element.find(".drag-item-marker").show();
        },

        off: function(){
            this.canDrag = false;
            this.element.find(".drag-item-marker").hide();
        },

        toggle: function(){
            this.canDrag = this.canDrag ? this.off() : this.on();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;
            var changeCanDrag = function(){
                o.canDtag = JSON.parse(element.attr("data-can-drag"));
                o.canDtag ? that.on() : that.off();
            };

            if (attributeName === "data-can-drag") {
                changeCanDrag();
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem));
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DraggableDefaultConfig = {
        dragContext: null,
        draggableDeferred: 0,
        dragElement: 'self',
        dragArea: "parent",
        timeout: 0,
        boundaryRestriction: true,
        onCanDrag: Metro.noop_true,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onDraggableCreate: Metro.noop
    };

    Metro.draggableSetup = function (options) {
        DraggableDefaultConfig = $.extend({}, DraggableDefaultConfig, options);
    };

    if (typeof window["metroDraggableSetup"] !== undefined) {
        Metro.draggableSetup(window["metroDraggableSetup"]);
    }

    Metro.Component('draggable', {
        init: function( options, elem ) {
            this._super(elem, options, DraggableDefaultConfig, {
                drag: false,
                move: false,
                backup: {
                    cursor: 'default',
                    zIndex: '0'
                },
                dragArea: null,
                dragElement: null,
                id: Utils.elementId("draggable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("draggable-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var offset = element.offset();
            var dragElement  = o.dragElement !== 'self' ? element.find(o.dragElement) : element;

            element.data("canDrag", true);

            this.dragElement = dragElement;

            dragElement[0].ondragstart = function(){return false;};

            element.css("position", "absolute");

            if (o.dragArea === 'document' || o.dragArea === 'window') {
                o.dragArea = "body";
            }

            setImmediate(function(){
                that.dragArea = o.dragArea === 'parent' ? element.parent() : $(o.dragArea);
                if (o.dragArea !== 'parent') {
                    element.appendTo(that.dragArea);
                    element.css({
                        top: offset.top,
                        left: offset.left
                    });
                }
            });

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("draggable"));
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var position = {
                x: 0,
                y: 0
            };

            this.dragElement.on(Metro.events.startAll, function(e){

                var coord = o.dragArea !== "parent" ? element.offset() : element.position(),
                    shiftX = Utils.pageXY(e).x - coord.left,
                    shiftY = Utils.pageXY(e).y - coord.top;

                var moveElement = function(e){
                    var top = Utils.pageXY(e).y - shiftY;
                    var left = Utils.pageXY(e).x - shiftX;

                    if (o.boundaryRestriction) {
                        if (top < 0) top = 0;
                        if (left < 0) left = 0;

                        if (top > that.dragArea.outerHeight() - element.outerHeight()) top = that.dragArea.outerHeight() - element.outerHeight();
                        if (left > that.dragArea.outerWidth() - element.outerWidth()) left = that.dragArea.outerWidth() - element.outerWidth();
                    }

                    position.y = top;
                    position.x = left;

                    element.css({
                        left: left,
                        top: top
                    });
                };


                if (element.data("canDrag") === false || Utils.exec(o.onCanDrag, [element]) !== true) {
                    return ;
                }

                if (Metro.isTouchable === false && e.which !== 1) {
                    return ;
                }

                that.drag = true;

                that.backup.cursor = element.css("cursor");
                that.backup.zIndex = element.css("z-index");

                element.addClass("draggable");

                moveElement(e);

                that._fireEvent("drag-start", {
                    position: position,
                    context: o.dragContext
                });

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    moveElement(e);

                    that._fireEvent("drag-move", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    element.css({
                        cursor: that.backup.cursor,
                        zIndex: that.backup.zIndex
                    }).removeClass("draggable");

                    if (that.drag) {
                        $(document).off(Metro.events.moveAll, {ns: that.id});
                        $(document).off(Metro.events.stopAll, {ns: that.id});
                    }

                    that.drag = false;
                    that.move = false;

                    that._fireEvent("drag-stop", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id});
            });
        },

        off: function(){
            this.element.data("canDrag", false);
        },

        on: function(){
            this.element.data("canDrag", true);
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
        },

        destroy: function(){
            var element = this.element;
            this.dragElement.off(Metro.events.startAll);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DropdownDefaultConfig = {
        dropdownDeferred: 0,
        dropFilter: null,
        toggleElement: null,
        noClose: false,
        duration: 50,
        checkDropUp: false,
        dropUp: false,
        onDrop: Metro.noop,
        onUp: Metro.noop,
        onDropdownCreate: Metro.noop
    };

    Metro.dropdownSetup = function (options) {
        DropdownDefaultConfig = $.extend({}, DropdownDefaultConfig, options);
    };

    if (typeof window["metroDropdownSetup"] !== undefined) {
        Metro.dropdownSetup(window["metroDropdownSetup"]);
    }

    Metro.Component('dropdown', {
        init: function( options, elem ) {
            this._super(elem, options, DropdownDefaultConfig, {
                _toggle: null,
                displayOrigin: null,
                isOpen: false
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("dropdown-create", {
                element: element
            });

            if (element.hasClass("open")) {
                element.removeClass("open");
                setTimeout(function(){
                    that.open(true);
                },0);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var toggle;

            if (o.dropUp) {
                element.addClass("drop-up");
            }

            toggle = o.toggleElement !== null ? $(o.toggleElement) : element.siblings('.dropdown-toggle').length > 0 ? element.siblings('.dropdown-toggle') : element.prev();

            this.displayOrigin = Utils.getStyleOne(element, "display");

            if (element.hasClass("v-menu")) {
                element.addClass("for-dropdown");
            }

            element.css("display", "none");

            this._toggle = toggle;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var toggle = this._toggle, parent = element.parent();

            toggle.on(Metro.events.click, function(e){
                parent.siblings(parent[0].tagName).removeClass("active-container");
                $(".active-container").removeClass("active-container");

                if (element.css('display') !== 'none' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    $('[data-role=dropdown]').each(function(i, el){
                        if (!element.parents('[data-role=dropdown]').is(el) && !$(el).hasClass('keep-open') && $(el).css('display') !== 'none') {
                            if (!Utils.isValue(o.dropFilter)) {
                                that._close(el);
                            } else {
                                if ($(el).closest(o.dropFilter).length > 0) {
                                    that._close(el);
                                }
                            }
                        }
                    });
                    if (element.hasClass('horizontal')) {
                        element.css({
                            'visibility': 'hidden',
                            'display': 'block'
                        });
                        var children_width = 0;
                        $.each(element.children('li'), function(){
                            children_width += $(this).outerWidth(true);
                        });

                        element.css({
                            'visibility': 'visible',
                            'display': 'none'
                        });
                        element.css('width', children_width);
                    }
                    that._open(element);
                    parent.addClass("active-container");
                }
                e.preventDefault();
                e.stopPropagation();
            });

            if (o.noClose === true) {
                element.addClass("keep-open").on(Metro.events.click, function (e) {
                    //e.preventDefault();
                    e.stopPropagation();
                });
            }

            $(element).find('li.disabled a').on(Metro.events.click, function(e){
                e.preventDefault();
            });
        },

        _close: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideUp";

            toggle.removeClass('active-toggle').removeClass("active-control");
            dropdown.element.parent().removeClass("active-container");

            if (immediate) {
                func = 'hide'
            }

            el[func](immediate ? 0 : options.duration, function(){
                dropdown._fireEvent("close");
                dropdown._fireEvent("up");

                if (!options.dropUp && options.checkDropUp) {
                    dropdown.element.removeClass("drop-up");
                }
            });

            this.isOpen = false;
        },

        _open: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideDown";

            toggle.addClass('active-toggle').addClass("active-control");

            el[func](immediate ? 0 : options.duration, function(){

                if (!options.dropUp && options.checkDropUp) {
                    // dropdown.element.removeClass("drop-up");
                    if (!Utils.inViewport(dropdown.element[0])) {
                        dropdown.element.addClass("drop-up");
                    }
                }

                dropdown._fireEvent("open");
                dropdown._fireEvent("drop");
            });

            // this._fireEvent("drop");

            this.isOpen = true;
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        toggle: function(){
            if (this.isOpen)
                this.close();
            else
                this.open();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(){
        },

        destroy: function(){
            this._toggle.off(Metro.events.click);
        }
    });

    $(document).on(Metro.events.click, function(){
        $('[data-role*=dropdown]').each(function(){
            var el = $(this);

            if (el.css('display')!=='none' && !el.hasClass('keep-open') && !el.hasClass('stay-open') && !el.hasClass('ignore-document-click')) {
                Metro.getPlugin(el, 'dropdown').close();
            }
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var FileDefaultConfig = {
        fileDeferred: 0,
        label: "",
        mode: "input",
        buttonTitle: "Choose file(s)",
        filesTitle: "file(s) selected",
        dropTitle: "<strong>Choose a file(s)</strong> or drop it here",
        dropIcon: "<span class='default-icon-upload'></span>",
        prepend: "",
        clsComponent: "",
        clsPrepend: "",
        clsButton: "",
        clsCaption: "",
        clsLabel: "",
        copyInlineStyles: false,
        onSelect: Metro.noop,
        onFileCreate: Metro.noop
    };

    Metro.fileSetup = function (options) {
        FileDefaultConfig = $.extend({}, FileDefaultConfig, options);
    };

    if (typeof window["metroFileSetup"] !== undefined) {
        Metro.fileSetup(window["metroFileSetup"]);
    }

    Metro.Component('file', {
        init: function( options, elem ) {
            this._super(elem, options, FileDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("file-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container = $("<label>").addClass((o.mode === "input" ? " file " : o.mode === "button" ? " file-button " : " drop-zone ") + element[0].className).addClass(o.clsComponent);
            var caption = $("<span>").addClass("caption").addClass(o.clsCaption);
            var files = $("<span>").addClass("files").addClass(o.clsCaption);
            var icon, button;


            container.insertBefore(element);
            element.appendTo(container);

            if (o.mode === 'drop' || o.mode === 'dropzone') {
                icon = $(o.dropIcon).addClass("icon").appendTo(container);
                caption.html(o.dropTitle).insertAfter(icon);
                files.html("0" + " " + o.filesTitle).insertAfter(caption);
            } else if (o.mode === 'button') {

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

            } else {
                caption.insertBefore(element);

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

                if (element.attr('dir') === 'rtl' ) {
                    container.addClass("rtl");
                }

                if (o.prepend !== "") {
                    var prepend = $("<div>").html(o.prepend);
                    prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
                }
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest("label");
            var caption = container.find(".caption");
            var files = container.find(".files");
            var form = element.closest("form");

            if (form.length) {
                form.on("reset", function(){
                    that.clear();
                })
            }

            container.on(Metro.events.click, "button", function(){
                element[0].click();
            });

            element.on(Metro.events.change, function(){
                var fi = this;
                var file_names = [];
                var entry;

                // if (fi.files.length === 0) {
                //     return ;
                // }

                Array.from(fi.files).forEach(function(file){
                    file_names.push(file.name);
                });

                if (o.mode === "input") {

                    entry = file_names.join(", ");

                    caption.html(entry);
                    caption.attr('title', entry);
                } else {
                    files.html(element[0].files.length + " " +o.filesTitle);
                }

                that._fireEvent("select", {
                    files: fi.files
                });
            });

            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.blur, function(){container.removeClass("focused");});

            if (o.mode !== "input") {
                container.on('drag dragstart dragend dragover dragenter dragleave drop', function(e){
                    e.preventDefault();
                });

                container.on('dragenter dragover', function(){
                    container.addClass("drop-on");
                });

                container.on('dragleave', function(){
                    container.removeClass("drop-on");
                });

                container.on('drop', function(e){
                    element[0].files = e.dataTransfer.files;
                    files.html(element[0].files.length + " " +o.filesTitle);
                    container.removeClass("drop-on");
                    element.trigger("change");
                });
            }
        },

        clear: function(){
            var element = this.element, o = this.options;
            if (o.mode === "input") {
                element.siblings(".caption").html("");
            } else {
                element.siblings(".caption").html(o.dropTitle);
                element.siblings(".files").html("0" + " " + o.filesTitle);
            }

            element.val("");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleDir: function(){
            if (this.element.attr("dir") === 'rtl') {
                this.element.parent().addClass("rtl");
            } else {
                this.element.parent().removeClass("rtl");
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'dir': this.toggleDir(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            element.off(Metro.events.change);
            parent.off(Metro.events.click, "button");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var GravatarDefaultConfig = {
        gravatarDeferred: 0,
        email: "",
        size: 80,
        default: "mp",
        onGravatarCreate: Metro.noop
    };

    Metro.gravatarSetup = function (options) {
        GravatarDefaultConfig = $.extend({}, GravatarDefaultConfig, options);
    };

    if (typeof window["metroGravatarSetup"] !== undefined) {
        Metro.gravatarSetup(window["metroGravatarSetup"]);
    }

    Metro.Component('gravatar', {
        init: function( options, elem ) {
            this._super(elem, options, GravatarDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this.get();

            this._fireEvent("gravatar-create", {
                element: element
            });
        },

        getImage: function(email, size, def, is_object){
            var image = $("<img>").attr('alt', email);

            image.attr("src", this.getImageSrc(email, size));

            return is_object === true ? image : image[0];
        },

        getImageSrc: function(email, size, def){
            if (email === undefined || email.trim() === '') {
                return "";
            }

            size = size || 80;
            def = Utils.encodeURI(def) || '404';

            return "//www.gravatar.com/avatar/" + Metro.md5((email.toLowerCase()).trim()) + '?size=' + size + '&d=' + def;
        },

        get: function(){
            var element = this.element, o = this.options;
            var img = element[0].tagName === 'IMG' ? element : element.find("img");

            if (img.length === 0) {
                return;
            }
            img.attr("src", this.getImageSrc(o.email, o.size, o.default));

            return this;
        },

        resize: function(new_size){
            this.options.size = new_size !== undefined ? new_size : this.element.attr("data-size");
            this.get();
        },

        email: function(new_email){
            this.options.email = new_email !== undefined ? new_email : this.element.attr("data-email");
            this.get();
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-size': this.resize(); break;
                case 'data-email': this.email(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HintDefaultConfig = {
        hintDeferred: 0,
        hintHide: 5000,
        clsHint: "",
        hintText: "",
        hintPosition: Metro.position.TOP,
        hintOffset: 4,
        onHintShow: Metro.noop,
        onHintHide: Metro.noop,
        onHintCreate: Metro.noop
    };

    Metro.hintSetup = function (options) {
        HintDefaultConfig = $.extend({}, HintDefaultConfig, options);
    };

    if (typeof window["metroHintSetup"] !== undefined) {
        Metro.hintSetup(window["metroHintSetup"]);
    }

    Metro.Component('hint', {
        init: function( options, elem ) {
            this._super(elem, options, HintDefaultConfig, {
                hint: null,
                hint_size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("hint")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("hint-create", {
                element: this.element
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.enter, function(){
                that.createHint();
                if (+o.hintHide > 0) {
                    setTimeout(function(){
                        that.removeHint();
                    }, o.hintHide);
                }
            });

            element.on(Metro.events.leave, function(){
                that.removeHint();
            });

            $(window).on(Metro.events.scroll+" "+Metro.events.resize, function(){
                if (that.hint !== null) that.setPosition();
            }, {ns: this.id});
        },

        createHint: function(){
            var elem = this.elem, element = this.element, o = this.options;
            var hint = $("<div>").addClass("hint").addClass(o.clsHint).html(o.hintText);

            this.hint = hint;
            this.hint_size = Utils.hiddenElementSize(hint);

            $(".hint:not(.permanent-hint)").remove();

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                element = wrp;
            }

            this.setPosition();

            hint.appendTo($('body'));

            this._fireEvent("hint-show", {
                hint: hint[0]
            })
        },

        setPosition: function(){
            var hint = this.hint, hint_size = this.hint_size, o = this.options, element = this.element;

            if (o.hintPosition === Metro.position.BOTTOM) {
                hint.addClass('bottom');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.hintOffset,
                    left: element.offset().left + element.outerWidth()/2 - hint_size.width/2  - $(window).scrollLeft()
                });
            } else if (o.hintPosition === Metro.position.RIGHT) {
                hint.addClass('right');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.hintOffset
                });
            } else if (o.hintPosition === Metro.position.LEFT) {
                hint.addClass('left');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - hint_size.width - $(window).scrollLeft() - o.hintOffset
                });
            } else {
                hint.addClass('top');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() - hint_size.height - o.hintOffset,
                    left: element.offset().left - $(window).scrollLeft() + element.outerWidth()/2 - hint_size.width/2
                });
            }
        },

        removeHint: function(){
            var that = this;
            var hint = this.hint;
            var options = this.options;
            var timeout = options.onHintHide === Metro.noop ? 0 : 300;

            if (hint !== null) {

                this._fireEvent("hint-hide", {
                    hint: hint[0]
                });

                setTimeout(function(){
                    hint.hide(0, function(){
                        hint.remove();
                        that.hint = null;
                    });
                }, timeout);
            }
        },

        changeText: function(){
            this.options.hintText = this.element.attr("data-hint-text");
        },

        changeAttribute: function(attributeName){
            if (attributeName === "data-hint-text") {
                this.changeText();
            }
        },

        destroy: function(){
            var element = this.element;
            this.removeHint();
            element.off(Metro.events.enter + "-hint");
            element.off(Metro.events.leave + "-hint");
            $(window).off(Metro.events.scroll + "-hint");
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Hotkey = {
        specialKeys: {
            8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
            20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
            37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
            96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
            104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/",
            112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8",
            120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 188: ",", 190: ".",
            191: "/", 224: "meta" },

        shiftNums: {
            "~":"`", "!":"1", "@":"2", "#":"3", "$":"4", "%":"5", "^":"6", "&":"7",
            "*":"8", "(":"9", ")":"0", "_":"-", "+":"=", ":":";", "\"":"'", "<":",",
            ">":".",  "?":"/",   "|":"\\"
        },

        shiftNumsInverse: {
            "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&",
            "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<",
            ".": ">",  "/": "?",  "\\": "|"
        },

        textAcceptingInputTypes: [
            "text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime",
            "datetime-local", "search", "color", "tel"
        ],

        getKey: function(e){
            var key, k = e.keyCode, char = String.fromCharCode( k ).toLowerCase();
            if( e.shiftKey ){
                key = Hotkey.shiftNums[ char ] ? Hotkey.shiftNums[ char ] : char;
            }
            else {
                key = Hotkey.specialKeys[ k ] === undefined
                    ? char
                    : Hotkey.specialKeys[ k ];
            }

            return Hotkey.getModifier(e).length ? Hotkey.getModifier(e).join("+") + "+" + key : key;
        },

        getModifier: function(e){
            var m = [];
            if (e.altKey) {m.push("alt");}
            if (e.ctrlKey) {m.push("ctrl");}
            if (e.shiftKey) {m.push("shift");}
            return m;
        }
    };

    function bindKey(key, fn){
        return this.each(function(){
            $(this).on(Metro.events.keyup+".hotkey-method-"+key, function(e){
                var _key = Hotkey.getKey(e);
                var el = $(this);
                var href = ""+el.attr("href");

                if (key !== _key) {
                    return;
                }

                if (el.is("a")) {
                    if (href && href.trim() !== "#") {
                        window.location.href = href;
                    }
                }

                Utils.exec(fn, [e, _key, key], this);
            })
        })
    }

    $.fn.hotkey = bindKey;

    if (window.METRO_JQUERY && window.jquery_present) {
        jQuery.fn.hotkey = bindKey;
    }

    // TODO keyup or keydown ?
    $(document).on(Metro.events.keyup + ".hotkey-data", function(e){
        var el, fn, key, href;

        if (
            (METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS && /textarea|input|select/i.test(e.target.nodeName)) ||
            (METRO_HOTKEYS_FILTER_CONTENT_EDITABLE && $(e.target).attr('contenteditable')) ||
            (METRO_HOTKEYS_FILTER_TEXT_INPUTS && Hotkey.textAcceptingInputTypes.indexOf(e.target.type) > -1)
        )
        {
            return;
        }

        key = Hotkey.getKey(e);

        if (Utils.keyInObject(Metro.hotkeys, key)) {
            el = $(Metro.hotkeys[key][0]);
            fn = Metro.hotkeys[key][1];
            href = (""+el.attr("href")).trim();

            if (fn) {
                Utils.exec(fn);
            } else {
                if (el.is("a") && href && href.length > 0 && href.trim() !== "#") {
                    window.location.href = href;
                } else {
                    el.click();
                }
            }
        }
    });

    // TODO add destroy
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HtmlContainerDefaultConfig = {
        htmlcontainerDeferred: 0,
        method: "get",
        htmlSource: null,
        requestData: null,
        requestOptions: null,
        insertMode: "default", // replace, append, prepend
        onHtmlLoad: Metro.noop,
        onHtmlLoadFail: Metro.noop,
        onHtmlLoadDone: Metro.noop,
        onHtmlContainerCreate: Metro.noop
    };

    Metro.htmlContainerSetup = function (options) {
        HtmlContainerDefaultConfig = $.extend({}, HtmlContainerDefaultConfig, options);
    };

    if (typeof window["metroHtmlContainerSetup"] !== undefined) {
        Metro.htmlContainerSetup(window["metroHtmlContainerSetup"]);
    }

    Metro.Component('html-container', {
        init: function( options, elem ) {
            this._super(elem, options, HtmlContainerDefaultConfig, {
                data: {},
                opt: {},
                htmlSource: ''
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (typeof o.requestData === 'string') {
                o.requestData = JSON.parse(o.requestData);
            }

            if (Utils.isObject(o.requestData)) {
                this.data = Utils.isObject(o.requestData);
            }

            if (typeof o.requestOptions === 'string') {
                o.requestOptions = JSON.parse(o.requestOptions);
            }

            if (Utils.isObject(o.requestOptions)) {
                this.opt = Utils.isObject(o.requestOptions);
            }

            o.method = o.method.toLowerCase();

            if (Utils.isValue(o.htmlSource)) {
                this.htmlSource = o.htmlSource;
                this._load();
            }

            this._fireEvent("html-container-create", {
                element: element
            });
        },

        _load: function(){
            var that = this, element = this.element, o = this.options;

            $[o.method](this.htmlSource, this.data, this.opt).then(function(data){
                var _data = $(data);

                if (_data.length === 0) {
                    _data = $("<div>").html(data);
                }

                switch (o.insertMode.toLowerCase()) {
                    case "prepend": element.prepend(_data); break;
                    case "append": element.append(_data); break;
                    case "replace": _data.insertBefore(element).script(); element.remove(); break;
                    default: {
                        element.html(_data);
                    }
                }
                that._fireEvent("html-load", {
                    data: data,
                    source: o.htmlSource,
                    requestData: that.data,
                    requestOptions: that.opt
                });
            }, function(xhr){
                that._fireEvent("html-load-fail", {
                    xhr: xhr
                });
            });
        },

        load: function(source, data, opt){
            if (source) {
                this.htmlSource = source;
            }

            if (data) {
                this.data = Utils.isObject(data);
            }

            if (opt) {
                this.opt = Utils.isObject(opt);
            }

            this._load();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeHTMLSource = function(){
                var html = element.attr("data-html-source");
                if (Utils.isNull(html)) {
                    return ;
                }
                if (html.trim() === "") {
                    element.html("");
                }
                o.htmlSource = html;
                that._load();
            };

            var changeInsertMode = function(){
                var attr = element.attr("data-insert-mode");
                if (Utils.isValue(attr)) {
                    o.insertMode = attr;
                }
            };

            var changeRequestData = function(){
                var data = element.attr("data-request-data");
                that.load(o.htmlSource, data);
            };

            switch (attributeName) {
                case "data-html-source": changeHTMLSource(); break;
                case "data-insert-mode": changeInsertMode(); break;
                case "data-request-data": changeRequestData(); break;
            }
        },

        destroy: function(){}
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ImageCompareDefaultConfig = {
        imagecompareDeferred: 0,
        width: "100%",
        height: "auto",
        onSliderMove: Metro.noop,
        onImageCompareCreate: Metro.noop
    };

    Metro.imageCompareSetup = function (options) {
        ImageCompareDefaultConfig = $.extend({}, ImageCompareDefaultConfig, options);
    };

    if (typeof window["metroImageCompareSetup"] !== undefined) {
        Metro.imageCompareSetup(window["metroImageCompareSetup"]);
    }

    Metro.Component('image-compare', {
        init: function( options, elem ) {
            this._super(elem, options, ImageCompareDefaultConfig, {
                id: Utils.elementId("image-compare")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("image-compare-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container, container_overlay, slider;
            var images, element_width, element_height;

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("image-compare"));
            }

            element.addClass("image-compare").css({
                width: o.width
            });

            element_width = element.width();

            switch (o.height) {
                case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                default: element_height = o.height;
            }

            element.css({
                height: element_height
            });

            container = $("<div>").addClass("image-container").appendTo(element);
            container_overlay = $("<div>").addClass("image-container-overlay").appendTo(element).css({
                width: element_width / 2
            });

            slider = $("<div>").addClass("image-slider").appendTo(element);
            slider.css({
                top: element_height / 2 - slider.height() / 2,
                left: element_width / 2 - slider.width() / 2
            });

            images = element.find("img");

            $.each(images, function(i){
                var img = $("<div>").addClass("image-wrapper");
                img.css({
                    width: element_width,
                    height: element_height,
                    backgroundImage: "url("+this.src+")"
                });
                img.appendTo(i === 0 ? container : container_overlay);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            var overlay = element.find(".image-container-overlay");
            var slider = element.find(".image-slider");

            slider.on(Metro.events.startAll, function(){
                var w = element.width();
                $(document).on(Metro.events.moveAll, function(e){
                    var x = Utils.getCursorPositionX(element[0], e), left_pos;
                    if (x < 0) x = 0;
                    if (x > w) x = w;
                    overlay.css({
                        width: x
                    });
                    left_pos = x - slider.width() / 2;
                    slider.css({
                        left: left_pos
                    });

                    that._fireEvent("slider-move", {
                        x: x,
                        l: left_pos
                    });
                }, {ns: that.id});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});
                }, {ns: that.id})
            });

            $(window).on(Metro.events.resize, function(){
                var element_width = element.width(), element_height;

                if (o.width !== "100%") {
                    return ;
                }

                switch (o.height) {
                    case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                    default: element_height = o.height;
                }

                element.css({
                    height: element_height
                });

                $.each(element.find(".image-wrapper"), function(){
                    $(this).css({
                        width: element_width,
                        height: element_height
                    })
                });

                element.find(".image-container-overlay").css({
                    width: element_width / 2
                });

                slider.css({
                    top: element_height / 2 - slider.height() / 2,
                    left: element_width / 2 - slider.width() / 2
                });

            }, {ns: this.id});
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.start);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ImageGridDefaultConfig = {
        useBackground: false,
        backgroundSize: "cover",
        backgroundPosition: "top left",

        clsImageGrid: "",
        clsImageGridItem: "",
        clsImageGridImage: "",

        onItemClick: Metro.noop,
        onDrawItem: Metro.noop,
        onImageGridCreate: Metro.noop
    };

    Metro.imageGridSetup = function (options) {
        ImageGridDefaultConfig = $.extend({}, ImageGridDefaultConfig, options);
    };

    if (typeof window["metroImageGridSetup"] !== undefined) {
        Metro.imageGridSetup(window["metroImageGridSetup"]);
    }

    Metro.Component('image-grid', {
        init: function( options, elem ) {
            this._super(elem, options, ImageGridDefaultConfig, {
                // define instance vars here
                items: []
            });
            return this;
        },

        _create: function(){
            this.items = this.element.children("img");
            this._createStructure();
            this._createEvents();
            this._fireEvent('image-grid-create');
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("image-grid").addClass(o.clsImageGrid);

            this._createItems();
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".image-grid__item", function(){
                that._fireEvent("item-click", {
                    item: this
                });
            });
        },

        _createItems: function(){
            var that = this, element = this.element, o = this.options;
            var items = this.items;

            element.clear();

            items.each(function(){
                var el = $(this);
                var src = this.src;
                var wrapper = $("<div>").addClass("image-grid__item").addClass(o.clsImageGridItem).appendTo(element);
                var img = new Image();

                img.src = src;
                img.onload = function(){
                    var port = this.height >= this.width;
                    wrapper.addClass(port ? "image-grid__item-portrait" : "image-grid__item-landscape");
                    el.addClass(o.clsImageGridImage).appendTo(wrapper);

                    if (o.useBackground) {
                        wrapper
                            .css({
                                background: "url("+src+")",
                                backgroundRepeat: "no-repeat",
                                backgroundSize: o.backgroundSize,
                                backgroundPosition: o.backgroundPosition
                            })
                            .attr("data-original", el.attr("data-original") || src)
                            .attr("data-title", el.attr("alt") || el.attr("data-title") || "");
                        el.visible(false);
                    }

                    that._fireEvent("draw-item", {
                        item: wrapper[0],
                        image: el[0]
                    });
                }
            });
        },

        changeAttribute: function(attr, val){
            var o = this.options;

            if (attr === "data-use-background") {
                o.useBackground = Utils.bool(val);
                this._createItems();
            }

            if (attr === "data-background-size") {
                o.backgroundSize = val;
                this._createItems();
            }

            if (attr === "data-background-position") {
                o.backgroundPosition = val;
                this._createItems();
            }
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ImageMagnifierDefaultConfig = {
        imagemagnifierDeferred: 0,
        width: "100%",
        height: "auto",
        lensSize: 100,
        lensType: "square", // square, circle
        magnifierZoom: 2,
        magnifierMode: "glass", // glass, zoom
        magnifierZoomElement: null,

        clsMagnifier: "",
        clsLens: "",
        clsZoom: "",

        onMagnifierMove: Metro.noop,
        onImageMagnifierCreate: Metro.noop
    };

    Metro.imageMagnifierSetup = function (options) {
        ImageMagnifierDefaultConfig = $.extend({}, ImageMagnifierDefaultConfig, options);
    };

    if (typeof window["metroImageMagnifierSetup"] !== undefined) {
        Metro.imageMagnifierSetup(window["metroImageMagnifierSetup"]);
    }

    Metro.Component('image-magnifier', {
        init: function( options, elem ) {
            this._super(elem, options, ImageMagnifierDefaultConfig, {
                zoomElement: null,
                id: Utils.elementId("image-magnifier")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("image-magnifier-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var magnifier, element_width, element_height;
            var image = element.find("img");

            if (image.length === 0) {
                throw new Error("Image not defined");
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("image-magnifier"));
            }

            element.addClass("image-magnifier").css({
                width: o.width
            }).addClass(o.clsMagnifier);

            element_width = element.width();

            switch (o.height) {
                case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                default: element_height = o.height;
            }

            element.css({
                height: element_height
            });

            var x = element_width / 2 - o.lensSize / 2;
            var y = element_height / 2 - o.lensSize / 2;

            if (o.magnifierMode === "glass") {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: o.lensType !== "circle" ? 0 : "50%",
                    top: y,
                    left: x,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                    backgroundSize: (image[0].width * o.magnifierZoom) + "px " + (image[0].height * o.magnifierZoom) + "px"
                }).addClass(o.clsLens);

            } else {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: 0,
                    borderWidth: 1,
                    top: y,
                    left: x
                }).addClass(o.clsLens);

                if (!Utils.isValue(o.magnifierZoomElement) || $(o.magnifierZoomElement).length === 0) {
                    this.zoomElement = $("<div>").insertAfter(element);
                } else {
                    this.zoomElement = $(o.magnifierZoomElement);
                }

                var zoom_element_width = magnifier[0].offsetWidth * o.magnifierZoom;
                var zoom_element_height = magnifier[0].offsetHeight * o.magnifierZoom;
                var cx = zoom_element_width / o.lensSize;
                var cy = zoom_element_height / o.lensSize;

                this.zoomElement.css({
                    width: zoom_element_width,
                    height: zoom_element_height,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px",
                    backgroundSize: (image[0].width * cx) + "px " + (image[0].height * cy) + "px"
                }).addClass(o.clsZoom);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var glass = element.find(".image-magnifier-glass");
            var glass_size = glass[0].offsetWidth / 2;
            var image = element.find("img")[0];
            var zoomElement = this.zoomElement;
            var cx, cy;

            $(window).on(Metro.events.resize, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                if (o.magnifierMode === "glass") {
                    glass.css({
                        backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                        backgroundSize: (image.width * o.magnifierZoom) + "px " + (image.height * o.magnifierZoom) + "px"
                    });
                }
            }, {ns: this.id})

            if (o.magnifierMode !== "glass") {
                cx = zoomElement[0].offsetWidth / glass_size / 2;
                cy = zoomElement[0].offsetHeight / glass_size / 2;

                zoomElement.css({
                    backgroundSize: (image.width * cx) + "px " + (image.height * cy) + "px"
                });
            }

            var lens_move = function(pos){
                var x, y;
                var magic = 4, zoom = parseInt(o.magnifierZoom);

                if (o.magnifierMode === "glass") {

                    x = pos.x;
                    y = pos.y;

                    if (x > image.width - (glass_size / zoom)) {
                        x = image.width - (glass_size / zoom);
                    }
                    if (x < glass_size / zoom) {
                        x = glass_size / zoom;
                    }
                    if (y > image.height - (glass_size / zoom)) {
                        y = image.height - (glass_size / zoom);
                    }
                    if (y < glass_size / zoom) {
                        y = glass_size / zoom;
                    }

                    glass.css({
                        top: y - glass_size,
                        left: x - glass_size,
                        backgroundPosition: "-" + ((x * zoom) - glass_size + magic) + "px -" + ((y * zoom) - glass_size + magic) + "px"
                    });
                } else {

                    x = pos.x - (glass_size);
                    y = pos.y - (glass_size);

                    if (x > image.width - glass_size * 2) {x = image.width - glass_size * 2;}
                    if (x < 0) {x = 0;}
                    if (y > image.height - glass_size * 2) {y = image.height - glass_size * 2;}
                    if (y < 0) {y = 0;}

                    glass.css({
                        top: y,
                        left: x
                    });

                    zoomElement.css({
                        backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px"
                    });
                }
            };

            element.on(Metro.events.move, function(e){
                var pos = Utils.getCursorPosition(image, e);

                lens_move(pos);

                that._fireEvent("magnifier-move", {
                    pos: pos,
                    glass: glass[0],
                    zoomElement: zoomElement ? zoomElement[0] : undefined
                });

                e.preventDefault();
            });

            element.on(Metro.events.leave, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                glass.animate({
                    draw: {
                        top: y,
                        left: x
                    }
                });

                lens_move({
                    x: x + o.lensSize / 2, y: y + o.lensSize / 2
                });
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.move);
            element.off(Metro.events.leave);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InfoBoxDefaultConfig = {
        infoboxDeferred: 0,
        type: "",
        width: 480,
        height: "auto",
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        autoHide: 0,
        removeOnClose: false,
        closeButton: true,
        clsBox: "",
        clsBoxContent: "",
        clsOverlay: "",
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onInfoBoxCreate: Metro.noop
    };

    Metro.infoBoxSetup = function (options) {
        InfoBoxDefaultConfig = $.extend({}, InfoBoxDefaultConfig, options);
    };

    if (typeof window["metroInfoBoxSetup"] !== undefined) {
        Metro.infoBoxSetup(window["metroInfoBoxSetup"]);
    }

    Metro.Component('info-box', {
        init: function( options, elem ) {
            this._super(elem, options, InfoBoxDefaultConfig, {
                overlay: null,
                id: Utils.elementId("info-box")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("info-box-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var closer, content;

            if (o.overlay === true) {
                this.overlay = this._overlay();
            }

            element.addClass("info-box").addClass(o.type).addClass(o.clsBox);

            closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer");
                closer.appendTo(element);
            }

            if (o.closeButton !== true) {
                closer.hide();
            }

            content = element.find(".info-box-content");
            if (content.length > 0) {
                content.addClass(o.clsBoxContent);
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.appendTo($('body'));
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".closer", function(){
                that.close();
            });

            element.on(Metro.events.click, ".js-dialog-close", function(){
                that.close();
            });

            $(window).on(Metro.events.resize, function(){
                that.reposition();
            }, {ns: this.id});
        },

        _setPosition: function(){
            var element = this.element;
            element.css({
                top: ( $(window).height() - element.outerHeight() ) / 2,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        reposition: function(){
            this._setPosition();
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".info-box-content");
            if (content.length === 0) {
                return ;
            }
            content.html(c);
            this.reposition();
        },

        setType: function(t){
            var element = this.element;
            element.removeClass("success info alert warning").addClass(t);
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            if (o.overlay === true) {
                this.overlay.appendTo($("body"));
            }

            this._setPosition();

            element.css({
                visibility: "visible"
            });

            this._fireEvent("open");

            element.data("open", true);

            if (parseInt(o.autoHide) > 0) {
                setTimeout(function(){
                    that.close();
                }, parseInt(o.autoHide));
            }
        },

        close: function(){
            var element = this.element, o = this.options;

            if (o.overlay === true) {
                $('body').find('.overlay').remove();
            }

            element.css({
                visibility: "hidden",
                top: "100%"
            });

            this._fireEvent("close");

            element.data("open", false);

            if (o.removeOnClose === true) {
                this.destroy();
                element.remove();
            }
        },

        isOpen: function(){
            return this.element.data("open") === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off("all");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    Metro['infobox'] = {
        isInfoBox: function(el){
            return Utils.isMetroObject(el, "infobox");
        },

        open: function(el, c, t){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            if (c !== undefined) {
                ib.setContent(c);
            }
            if (t !== undefined) {
                ib.setType(t);
            }
            ib.open();
        },

        close: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            ib.close();
        },

        setContent: function(el, c){
            if (!this.isInfoBox(el)) {
                return false;
            }

            if (c === undefined) {
                c = "";
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setContent(c);
            ib.reposition();
        },

        setType: function(el, t){
            if (!this.isInfoBox(el)) {
                return false;
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setType(t);
            ib.reposition();
        },

        isOpen: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            return ib.isOpen();
        },

        create: function(c, t, o, open){
            var $$ = Utils.$();
            var el, ib, box_type;

            box_type = t !== undefined ? t : "";

            el = $$("<div>").appendTo($$("body"));
            $$("<div>").addClass("info-box-content").appendTo(el);

            var ib_options = $$.extend({}, {
                removeOnClose: true,
                type: box_type
            }, (o !== undefined ? o : {}));

            ib_options._runtime = true;

            el.infobox(ib_options);

            ib = Metro.getPlugin(el, 'infobox');
            ib.setContent(c);
            if (open !== false) {
                ib.open();
            }

            return el;
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var InputMaskDefaultConfig = {
        maskPattern: ".",
        mask: null,
        maskPlaceholder: "_",
        maskEditableStart: 0,
        thresholdInterval: 300,
        onChar: Metro.noop,
        onInputMaskCreate: Metro.noop
    };

    Metro.inputMaskSetup = function (options) {
        InputMaskDefaultConfig = $.extend({}, InputMaskDefaultConfig, options);
    };

    if (typeof window["metroInputMaskSetup"] !== undefined) {
        Metro.inputMaskSetup(window["metroInputMaskSetup"]);
    }

    Metro.Component('input-mask', {
        init: function( options, elem ) {
            if ($.device) {
                if (elem.setAttribute) elem.setAttribute("placeholder", options.mask);
                console.warn("The component input-mask can't be initialized, because you run it on a mobile device!");
                return ;
            }
            this._super(elem, options, InputMaskDefaultConfig, {
                // define instance vars here
                pattern: null,
                mask: "",
                maskArray: [],
                placeholder: "",
                length: 0,
                thresholdTimer: null,
                id: Utils.elementId("input-mask")
            });
            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent('input-mask-create');
        },

        _createStructure: function(){
            var o = this.options;

            if (!o.mask) {
                throw new Error('You must provide a pattern for masked input.')
            }

            if (typeof o.maskPlaceholder !== 'string' || o.maskPlaceholder.length > 1) {
                throw new Error('Mask placeholder should be a single character or an empty string.')
            }

            this.placeholder = o.maskPlaceholder;
            this.mask = (""+o.mask);
            this.maskArray = this.mask.split("");
            this.pattern = new RegExp("^"+o.maskPattern+"+$");
            this.length = this.mask.length;

            this._showValue();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var editableStart = o.maskEditableStart;
            var id = this.id;

            var checkEditablePosition = function(pos){
                if (pos < editableStart) {
                    setPosition(editableStart);
                    return false;
                }
                return true;
            }

            var checkEditableChar = function(pos){
                return pos < that.mask.length && that.mask.charAt(pos) === that.placeholder;
            }

            var findNextEditablePosition = function (pos){
                var i, a = that.maskArray;

                for (i = pos; i <= a.length; i++) {
                    if (a[i] === that.placeholder) {
                        return i;
                    }
                }
                return pos;
            }

            var setPosition = function(pos){
                that.elem.setSelectionRange(pos, pos);
            }

            var clearThresholdInterval = function(){
                clearInterval(that.thresholdTimer);
                that.thresholdTimer = null;
            }

            element.on("change", function(){
                if (this.value === "") {
                    this.value = that.mask;
                    setPosition(editableStart);
                }
            }, {ns: id});

            element.on("focus click", function(){
                checkEditablePosition(this.selectionStart);
                setPosition(findNextEditablePosition(this.selectionStart));
            }, {ns: id});

            element.on("keydown", function(e){
                var pos = this.selectionStart;
                var val = this.value;
                var code = e.code, key = e.key;

                if (code === "ArrowRight" || code === "End") {
                    return true;
                } else {
                    if (pos >= that.length && (["Backspace", "Home", "ArrowLeft", "ArrowUp"].indexOf(code) === -1)) {
                        // Don't move over mask length
                        e.preventDefault();
                    } else if (code === "Home" || code === "ArrowUp") {
                        // Goto editable start position
                        e.preventDefault();
                        setPosition(editableStart);
                    } else if (code === "ArrowLeft") {
                        if (pos - 1 < editableStart) {
                            // Don't move behind a editable start position
                            e.preventDefault();
                        }
                    } else if (code === "Backspace") {
                        e.preventDefault();
                        if (pos - 1 >= editableStart) {
                            if (checkEditableChar(pos - 1)) {
                                if (this.value.charAt(pos - 1) !== that.placeholder) {
                                    // Replace char if it is not a mask placeholder
                                    this.value = val.substr(0, pos - 1) + that.placeholder + val.substr(pos);
                                }
                            }
                            // Move to prev char position
                            setPosition(pos - 1);
                        }
                    } else if (code === "Space") {
                        e.preventDefault();
                        setPosition(pos + 1);
                    } else if (!that.pattern.test(key)) {
                        e.preventDefault();
                    } else {
                        e.preventDefault();
                        if (checkEditableChar(pos)) {
                            this.value = val.substr(0, pos) + (o.onChar === Metro.noop ? key : Utils.exec(o.onChar, [key], this)) + val.substr(pos + 1);
                            setPosition(findNextEditablePosition(pos + 1));
                        }
                    }
                }
            }, {ns: id});

            element.on("keyup", function(){
                var el = this;

                clearThresholdInterval();

                that.thresholdTimer = setInterval(function(){
                    clearThresholdInterval();
                    setPosition(findNextEditablePosition(el.selectionStart));
                }, o.thresholdInterval)
            }, {ns: id});
        },

        _showValue: function(){
            var that = this, elem = this.elem;
            var a = new Array(this.length);
            var val;
            if (!elem.value) {
                elem.value = this.mask;
            } else {
                val = elem.value;
                $.each(this.maskArray, function(i, v){
                    if (val[i] !== v && !that.pattern.test(val[i])) {
                        a[i] = that.placeholder;
                    } else {
                        a[i] = val[i];
                    }
                });
                this.elem.value = a.join("");
            }
        },

        destroy: function(){
            var element = this.element, id = this.id;

            element.off("change", {ns: id});
            element.off("focus", {ns: id});
            element.off("click", {ns: id});
            element.off("keydown", {ns: id});
            element.off("keyup", {ns: id});

            return element;
        }
    });
}(Metro, m4q));


(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MaterialInputDefaultConfig = {
        materialinputDeferred: 0,
        label: "",
        informer: "",
        icon: "",

        permanentLabel: false,

        clsComponent: "",
        clsInput: "",
        clsLabel: "",
        clsInformer: "",
        clsIcon: "",
        clsLine: "",

        onInputCreate: Metro.noop
    };

    Metro.materialInputSetup = function (options) {
        MaterialInputDefaultConfig = $.extend({}, MaterialInputDefaultConfig, options);
    };

    if (typeof window["metroMaterialInputSetup"] !== undefined) {
        Metro.materialInputSetup(window["metroMaterialInputSetup"]);
    }

    Metro.Component('material-input', {
        init: function( options, elem ) {
            this._super(elem, options, MaterialInputDefaultConfig, {
                history: [],
                historyIndex: -1
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("input-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container = $("<div>").addClass("input-material " + element[0].className);

            element[0].className = "";
            element.attr("autocomplete", "nope");

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            container.insertBefore(element);
            element.appendTo(container);

            if (Utils.isValue(o.label)) {
                $("<span>").html(o.label).addClass("label").addClass(o.clsLabel).insertAfter(element);
            }
            if (Utils.isValue(o.informer)) {
                $("<span>").html(o.informer).addClass("informer").addClass(o.clsInformer).insertAfter(element);
            }
            if (Utils.isValue(o.icon)) {
                container.addClass("with-icon");
                $("<span>").html(o.icon).addClass("icon").addClass(o.clsIcon).insertAfter(element);
            }

            container.append($("<hr>").addClass(o.clsLine));

            if (o.permanentLabel === true) {
                container.addClass("permanent-label");
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsInput);

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){

        },

        clear: function(){
            this.element.val('');
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            if (attributeName === 'disabled') {
                this.toggleState();
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InputDefaultConfig = {
        inputDeferred: 0,

        // mask: null,
        label: "",

        autocomplete: null,
        autocompleteDivider: ",",
        autocompleteListHeight: 200,

        history: false,
        historyPreset: "",
        historyDivider: "|",
        preventSubmit: false,
        defaultValue: "",
        size: "default",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        searchButton: false,
        clearButton: true,
        revealButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        revealButtonIcon: "<span class='default-icon-eye'></span>",
        searchButtonIcon: "<span class='default-icon-search'></span>",
        customButtons: [],
        searchButtonClick: 'submit',

        clsComponent: "",
        clsInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsClearButton: "",
        clsRevealButton: "",
        clsCustomButton: "",
        clsSearchButton: "",
        clsLabel: "",

        onAutocompleteSelect: Metro.noop,
        onHistoryChange: Metro.noop,
        onHistoryUp: Metro.noop,
        onHistoryDown: Metro.noop,
        onClearClick: Metro.noop,
        onRevealClick: Metro.noop,
        onSearchButtonClick: Metro.noop,
        onEnterClick: Metro.noop,
        onInputCreate: Metro.noop
    };

    Metro.inputSetup = function (options) {
        InputDefaultConfig = $.extend({}, InputDefaultConfig, options);
    };

    if (typeof window["metroInputSetup"] !== undefined) {
        Metro.inputSetup(window["metroInputSetup"]);
    }

    Metro.Component('input', {
        init: function( options, elem ) {
            this._super(elem, options, InputDefaultConfig, {
                history: [],
                historyIndex: -1,
                autocomplete: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("input-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className);
            var buttons = $("<div>").addClass("button-group");
            var clearButton, revealButton, searchButton;

            if (Utils.isValue(o.historyPreset)) {
                $.each(o.historyPreset.toArray(o.historyDivider), function(){
                    that.history.push(this);
                });
                that.historyIndex = that.history.length - 1;
            }

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);

            if (!Utils.isValue(element.val().trim())) {
                element.val(o.defaultValue);
            }

            if (o.clearButton === true && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }
            if (element.attr('type') === 'password' && o.revealButton === true) {
                revealButton = $("<button>").addClass("button input-reveal-button").addClass(o.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o.revealButtonIcon);
                revealButton.appendTo(buttons);
            }
            if (o.searchButton === true) {
                searchButton = $("<button>").addClass("button input-search-button").addClass(o.clsSearchButton).attr("tabindex", -1).attr("type", o.searchButtonClick === 'submit' ? "submit" : "button").html(o.searchButtonIcon);
                searchButton.appendTo(buttons);
            }

            if (Utils.isValue(o.prepend)) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (Utils.isValue(o.append)) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (typeof o.customButtons === "string") {
                o.customButtons = Utils.isObject(o.customButtons);
            }

            if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                $.each(o.customButtons, function(){
                    var item = this;
                    var customButton = $("<button>");

                    customButton
                        .addClass("button input-custom-button")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .attr("type", "button")
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr($.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    customButton.appendTo(buttons);
                });
            }

            if (Utils.isValue(element.attr('data-exclaim'))) {
                container.attr('data-exclaim', element.attr('data-exclaim'));
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsInput);

            if (o.size !== "default") {
                container.css({
                    width: o.size
                });
            }

            if (!Utils.isNull(o.autocomplete)) {

                var autocomplete_obj = Utils.isObject(o.autocomplete);

                if (autocomplete_obj !== false) {
                    this.autocomplete = autocomplete_obj;
                } else {
                    this.autocomplete = o.autocomplete.toArray(o.autocompleteDivider);
                }
                $("<div>").addClass("autocomplete-list").css({
                    maxHeight: o.autocompleteListHeight,
                    display: "none"
                }).appendTo(container);
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".input");
            var autocompleteList = container.find(".autocomplete-list");

            container.on(Metro.events.click, ".input-clear-button", function(){
                var curr = element.val();
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").fire('clear').fire('change').fire('keyup').focus();
                if (autocompleteList.length > 0) {
                    autocompleteList.css({
                        display: "none"
                    })
                }

                that._fireEvent("clear-click", {
                    prev: curr,
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-reveal-button", function(){
                if (element.attr('type') === 'password') {
                    element.attr('type', 'text');
                } else {
                    element.attr('type', 'password');
                }

                that._fireEvent("reveal-click", {
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-search-button", function(){
                if (o.searchButtonClick !== 'submit') {

                    that._fireEvent("search-button-click", {
                        val: element.val(),
                        button: this
                    });

                } else {
                    this.form.submit();
                }
            });

            // container.on(Metro.events.stop, ".input-reveal-button", function(){
            //     element.attr('type', 'password').focus();
            // });

            container.on(Metro.events.click, ".input-custom-button", function(){
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [element.val(), button], this);
            });

            element.on(Metro.events.keyup, function(e){
                var val = element.val().trim();

                if (o.history && e.keyCode === Metro.keyCode.ENTER && val !== "") {
                    element.val("");
                    that.history.push(val);
                    that.historyIndex = that.history.length - 1;

                    that._fireEvent("history-change", {
                        val: val,
                        history: that.history,
                        historyIndex: that.historyIndex
                    })

                    if (o.preventSubmit === true) {
                        e.preventDefault();
                    }
                }

                if (o.history && e.keyCode === Metro.keyCode.UP_ARROW) {
                    that.historyIndex--;
                    if (that.historyIndex >= 0) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-down", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = 0;
                    }
                    e.preventDefault();
                }

                if (o.history && e.keyCode === Metro.keyCode.DOWN_ARROW) {
                    that.historyIndex++;
                    if (that.historyIndex < that.history.length) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-up", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = that.history.length - 1;
                    }
                    e.preventDefault();
                }
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    that._fireEvent("enter-click", {
                        val: element.val()
                    });
                }
            });

            element.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            element.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            element.on(Metro.events.input, function(){
                var val = this.value.toLowerCase();
                var items;

                if (autocompleteList.length === 0) {
                    return;
                }

                autocompleteList.html("");

                items = that.autocomplete.filter(function(item){
                    return item.toLowerCase().indexOf(val) > -1;
                });

                autocompleteList.css({
                    display: items.length > 0 ? "block" : "none"
                });

                $.each(items, function(i, v){
                    var index = v.toLowerCase().indexOf(val);
                    var item = $("<div>").addClass("item").attr("data-autocomplete-value", v);
                    var html;

                    if (index === 0) {
                        html = "<strong>"+v.substr(0, val.length)+"</strong>"+v.substr(val.length);
                    } else {
                        html = v.substr(0, index) + "<strong>"+v.substr(index, val.length)+"</strong>"+v.substr(index + val.length);
                    }
                    item.html(html).appendTo(autocompleteList);
                })
            });

            container.on(Metro.events.click, ".autocomplete-list .item", function(){
                var val = $(this).attr("data-autocomplete-value");
                element.val(val);
                autocompleteList.css({
                    display: "none"
                });
                element.trigger("change");
                that._fireEvent("autocomplete-select", {
                    value: val
                });
            });
        },

        getHistory: function(){
            return this.history;
        },

        getHistoryIndex: function(){
            return this.historyIndex;
        },

        setHistoryIndex: function(val){
            this.historyIndex = val >= this.history.length ? this.history.length - 1 : val;
        },

        setHistory: function(history, append) {
            var that = this, o = this.options;
            if (Utils.isNull(history)) return;
            if (!Array.isArray(history) && typeof history === 'string') {
                history = history.toArray(o.historyDivider);
            }
            if (append === true) {
                $.each(history, function () {
                    that.history.push(this);
                })
            } else{
                this.history = history;
            }
            this.historyIndex = this.history.length - 1;
        },

        clear: function(){
            this.element.val('');
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        setAutocompleteList: function(l){
            var autocomplete_list = Utils.isObject(l);
            if (autocomplete_list !== false) {
                this.autocomplete = autocomplete_list;
            } else if (typeof l === "string") {
                this.autocomplete = l.toArray(this.options.autocompleteDivider);
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            var clearBtn = parent.find(".input-clear-button");
            var revealBtn = parent.find(".input-reveal-button");
            var customBtn = parent.find(".input-custom-button");

            if (clearBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }
            if (revealBtn.length > 0) {
                revealBtn.off(Metro.events.start);
                revealBtn.off(Metro.events.stop);
            }
            if (customBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.input .autocomplete-list').hide();
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var KeypadDefaultConfig = {
        keypadDeferred: 0,
        label: "",
        keySize: 48,
        keys: "1, 2, 3, 4, 5, 6, 7, 8, 9, 0",
        copyInlineStyles: false,
        target: null,
        keyLength: 0,
        shuffle: false,
        shuffleCount: 3,
        position: Metro.position.BOTTOM_LEFT, //top-left, top, top-right, right, bottom-right, bottom, bottom-left, left
        dynamicPosition: false,
        serviceButtons: true,
        showValue: true,
        open: false,
        sizeAsKeys: false,

        clsKeypad: "",
        clsInput: "",
        clsKeys: "",
        clsKey: "",
        clsServiceKey: "",
        clsBackspace: "",
        clsClear: "",
        clsLabel: "",

        onChange: Metro.noop,
        onClear: Metro.noop,
        onBackspace: Metro.noop,
        onShuffle: Metro.noop,
        onKey: Metro.noop,
        onKeypadCreate: Metro.noop
    };

    Metro.keypadSetup = function (options) {
        KeypadDefaultConfig = $.extend({}, KeypadDefaultConfig, options);
    };

    if (typeof window["metroKeypadSetup"] !== undefined) {
        Metro.keypadSetup(window["metroKeypadSetup"]);
    }

    Metro.Component('keypad', {
        init: function( options, elem ) {
            this._super(elem, options, KeypadDefaultConfig, {
                value: elem.tagName === 'INPUT' ? elem.value : elem.innerText,
                positions: ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"],
                keypad: null,
                keys: [],
                keys_to_work: []
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.keys = o.keys.toArray(",");
            this.keys_to_work = this.keys;

            this._createKeypad();
            if (o.shuffle === true) {
                this.shuffle();
            }
            this._createKeys();
            this._createEvents();

            this._fireEvent("keypad-create", {
                element: element
            });
        },

        _createKeypad: function(){
            var element = this.element, o = this.options;
            var parent = element.parent();
            var keypad, keys;

            if (parent.hasClass("input")) {
                keypad = parent;
            } else {
                keypad = $("<div>").addClass("input").addClass(element[0].className);
            }

            keypad.addClass("keypad");
            if (keypad.css("position") === "static" || keypad.css("position") === "") {
                keypad.css({
                    position: "relative"
                });
            }

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            keypad.insertBefore(element);

            element.attr("readonly", true);
            element.appendTo(keypad);

            keys = $("<div>").addClass("keys").addClass(o.clsKeys);
            keys.appendTo(keypad);
            this._setKeysPosition();

            if (o.open === true) {
                keys.addClass("open keep-open");
            }


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    keypad.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            element.addClass(o.clsInput);
            keypad.addClass(o.clsKeypad);

            element.on(Metro.events.blur, function(){keypad.removeClass("focused");});
            element.on(Metro.events.focus, function(){keypad.addClass("focused");});

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(keypad);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (o.disabled === true || element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.keypad = keypad;
        },

        _setKeysPosition: function(){
            var element = this.element, o = this.options;
            var keypad = element.parent();
            var keys = keypad.find(".keys");
            keys.removeClass(this.positions.join(" ")).addClass(o.position)
        },

        _createKeys: function(){
            var element = this.element, o = this.options;
            var keypad = element.parent();
            var key, keys = keypad.find(".keys");
            var factor = Math.round(Math.sqrt(this.keys.length + 2));
            var key_size = o.keySize;
            var width;

            keys.html("");

            $.each(this.keys_to_work, function(){
                key = $("<span>").addClass("key").addClass(o.clsKey).html(this);
                key.data("key", this);
                key.css({
                    width: o.keySize,
                    height: o.keySize,
                    lineHeight: o.keySize - 4
                }).appendTo(keys);
            });

            if (o.serviceButtons === true) {

                var service_keys = ['&larr;', '&times;'];

                $.each(service_keys, function () {
                    key = $("<span>").addClass("key service-key").addClass(o.clsKey).addClass(o.clsServiceKey).html(this);
                    if (this === '&larr;') {
                        key.addClass(o.clsBackspace);
                    }
                    if (this === '&times;') {
                        key.addClass(o.clsClear);
                    }
                    key.data("key", this);
                    key.css({
                        width: o.keySize,
                        height: o.keySize,
                        lineHeight: o.keySize - 4
                    }).appendTo(keys);
                });
            }

            width = factor * (key_size + 2) - 6;
            keys.outerWidth(width);

            if (o.sizeAsKeys === true && ['top-left', 'top', 'top-right', 'bottom-left', 'bottom', 'bottom-right'].indexOf(o.position) !== -1) {
                keypad.outerWidth(keys.outerWidth());
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.on(Metro.events.click, ".key", function(e){
                var key = $(this);

                if (key.data('key') !== '&larr;' && key.data('key') !== '&times;') {

                    if (o.keyLength > 0 && (String(that.value).length === o.keyLength)) {
                        return false;
                    }

                    that.value = that.value + "" + key.data('key');

                    if (o.shuffle === true) {
                        that.shuffle();
                        that._createKeys();
                    }

                    if (o.dynamicPosition === true) {
                        o.position = that.positions[$.random(0, that.positions.length - 1)];
                        that._setKeysPosition();
                    }

                    that._fireEvent("key", {
                        key: key.data("key"),
                        val: that.value
                    });

                } else {
                    if (key.data('key') === '&times;') {
                        that.value = "";

                        that._fireEvent("clear");

                    }
                    if (key.data('key') === '&larr;') {
                        that.value = (that.value.substring(0, that.value.length - 1));

                        that._fireEvent("backspace", {
                            val: that.value
                        });
                    }
                }

                if (o.showValue === true) {
                    if (element[0].tagName === "INPUT") {
                        element.val(that.value);
                    } else {
                        element.text(that.value);
                    }
                }

                element.trigger('change');
                Utils.exec(o.onChange, [that.value], element[0]);

                e.preventDefault();
                e.stopPropagation();
            });

            keypad.on(Metro.events.click, function(e){
                if (o.open === true) {
                    return ;
                }

                if (keys.hasClass("open") === true) {
                    keys.removeClass("open");
                } else {
                    keys.addClass("open");
                }

                e.preventDefault();
                e.stopPropagation();
            });

            if (o.target !== null) {
                element.on(Metro.events.change, function(){
                    var t = $(o.target);
                    if (t.length === 0) {
                        return ;
                    }
                    if (t[0].tagName === "INPUT") {
                        t.val(that.value);
                    } else {
                        t.text(that.value);
                    }
                });
            }
        },

        shuffle: function(){
            var o = this.options;
            for (var i = 0; i < o.shuffleCount; i++) {
                this.keys_to_work = this.keys_to_work.shuffle();
            }

            this._fireEvent("shuffle", {
                keysToWork: this.keys_to_work,
                keys: this.keys
            });
        },

        shuffleKeys: function(count){
            if (count === undefined) {
                count = this.options.shuffleCount;
            }
            for (var i = 0; i < count; i++) {
                this.keys_to_work = this.keys_to_work.shuffle();
            }
            this._createKeys();
        },

        val: function(v){

            if (typeof v === "undefined") {
                return this.value;
            }

            this.value = v;
            this.element[0].tagName === "INPUT" ? this.element.val(v) : this.element.text(v);
            return this;
        },

        open: function(){
            var element = this.element;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.addClass("open");
        },

        close: function(){
            var element = this.element;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.removeClass("open");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        setPosition: function(pos){
            var new_position = pos !== undefined ? pos : this.element.attr("data-position");
            if (this.positions.indexOf(new_position) === -1) {
                return ;
            }
            this.options.position = new_position;
            this._setKeysPosition();
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-position': this.setPosition(); break;
            }
        },

        destroy: function(){
            var element = this.element, keypad = this.keypad, keys = keypad.find(".keys");

            keypad.off(Metro.events.click);
            keys.off(Metro.events.click, ".key");
            element.off(Metro.events.change);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        var keypads = $(".keypad .keys");
        $.each(keypads, function(){
            if (!$(this).hasClass("keep-open")) {
                $(this).removeClass("open");
            }
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var LightboxDefaultConfig = {
        loop: true,
        source: "img",

        iconClose: "<span class='default-icon-cross'>",
        iconPrev: "<span class='default-icon-chevron-left'>",
        iconNext: "<span class='default-icon-chevron-right'>",

        clsNext: "",
        clsPrev: "",
        clsClose: "",
        clsImage: "",
        clsImageContainer: "",
        clsImageWrapper: "",
        clsLightbox: "",

        onDrawImage: Metro.noop,
        onLightboxCreate: Metro.noop
    };

    Metro.lightboxSetup = function (options) {
        LightboxDefaultConfig = $.extend({}, LightboxDefaultConfig, options);
    };

    if (typeof window["metroLightboxSetup"] !== undefined) {
        Metro.lightboxSetup(window["metroLightboxSetup"]);
    }

    Metro.Component('lightbox', {
        init: function( options, elem ) {
            this._super(elem, options, LightboxDefaultConfig, {
                // define instance vars here
                overlay: null,
                lightbox: null,
                current: null,
                items: []
            });
            return this;
        },

        _create: function(){
            var o = this.options;

            if (!o.source) {
                o.source = "img";
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent('lightbox-create');
        },

        _createStructure: function(){
            var o = this.options;
            var lightbox, overlay;

            overlay = $(".lightbox-overlay");

            if (overlay.length === 0) {
                overlay = $("<div>").addClass("lightbox-overlay").appendTo("body").hide();
            }

            lightbox = $("<div>").addClass("lightbox").addClass(o.clsLightbox).appendTo("body").hide();

            $("<span>").addClass("lightbox__prev").addClass(o.clsPrev).html(o.iconPrev).appendTo(lightbox);
            $("<span>").addClass("lightbox__next").addClass(o.clsNext).html(o.iconNext).appendTo(lightbox);
            $("<span>").addClass("lightbox__closer").addClass(o.clsClose).html(o.iconClose).appendTo(lightbox);
            $("<div>").addClass("lightbox__image").addClass(o.clsImageContainer).appendTo(lightbox);

            this.component = lightbox[0];
            this.lightbox = lightbox;
            this.overlay = overlay;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var lightbox = $(this.component);

            element.on(Metro.events.click, o.source, function(){
                that.open(this);
            });

            lightbox.on(Metro.events.click, ".lightbox__closer", function(){
                that.close();
            });

            lightbox.on(Metro.events.click, ".lightbox__prev", function(){
                that.prev();
            });

            lightbox.on(Metro.events.click, ".lightbox__next", function(){
                that.next();
            });
        },

        _setupItems: function(){
            var element = this.element, o = this.options;
            var items = element.find(o.source);

            if (items.length === 0) {
                return ;
            }

            this.items = items;
        },

        _goto: function(el){
            var that = this, o = this.options;
            var $el = $(el);
            var img = $("<img>"), src;
            var imageContainer, imageWrapper, activity;

            imageContainer = this.lightbox.find(".lightbox__image");

            imageContainer.find(".lightbox__image-wrapper").remove();
            imageWrapper = $("<div>")
                .addClass("lightbox__image-wrapper")
                .addClass(o.clsImageWrapper)
                .attr("data-title", ($el.attr("alt") || $el.attr("data-title") || ""))
                .appendTo(imageContainer);

            activity = $("<div>").appendTo(imageWrapper);

            Metro.makePlugin(activity, "activity", {
                type: "cycle",
                style: "color"
            });

            this.current = el;

            if (el.tagName === "IMG" || el.tagName === "DIV") {
                src = $el.attr("data-original") || $el.attr("src");
                img.attr("src", src);
                img[0].onload = function(){
                    var port = this.height > this.width;
                    img.addClass(port ? "lightbox__image-portrait" : "lightbox__image-landscape").addClass(o.clsImage);
                    img.attr("alt", $el.attr("alt"));
                    img.appendTo(imageWrapper);
                    activity.remove();
                    that._fireEvent("draw-image", {
                        image: img[0],
                        item: imageWrapper[0]
                    });
                }
            }
        },

        _index: function(el){
            var index = -1;

            this.items.each(function(i){
                if (this === el) {
                    index = i;
                }
            });

            return index;
        },

        next: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index + 1 >= this.items.length) {
                if (this.options.loop) {
                    index = -1;
                } else {
                    return;
                }
            }

            this._goto(this.items[index + 1]);
        },

        prev: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index - 1 < 0) {
                if (this.options.loop) {
                    index = this.items.length;
                } else {
                    return;
                }
            }

            this._goto(this.items[index - 1]);
        },

        open: function(el){
            this._setupItems();

            this._goto(el);

            this.overlay.show();
            this.lightbox.show();

            return this;
        },

        close: function(){
            this.overlay.hide();
            this.lightbox.hide();
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListDefaultConfig = {
        listDeferred: 0,
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,
        paginationShortMode: true,
        thousandSeparator: ",",
        decimalSeparator: ",",
        sortTarget: "li",
        sortClass: null,
        sortDir: "asc",
        sortInitial: true,
        filterClass: null,
        filter: null,
        filterString: "",
        filters: null,
        source: null,
        showItemsSteps: false,
        showSearch: false,
        showListInfo: false,
        showPagination: false,
        showActivity: true,
        muteList: true,
        items: -1,
        itemsSteps: "all, 10,25,50,100",
        itemsAllTitle: "Show all",
        listItemsCountTitle: "Show entries:",
        listSearchTitle: "Search:",
        listInfoTitle: "Showing $1 to $2 of $3 entries",
        paginationPrevTitle: "Prev",
        paginationNextTitle: "Next",
        activityType: "cycle",
        activityStyle: "color",
        activityTimeout: 100,
        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        clsComponent: "",
        clsList: "",
        clsListItem: "",
        clsListTop: "",
        clsItemsCount: "",
        clsSearch: "",
        clsListBottom: "",
        clsListInfo: "",
        clsListPagination: "",
        clsPagination: "",
        onDraw: Metro.noop,
        onDrawItem: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadError: Metro.noop,
        onFilterItemAccepted: Metro.noop,
        onFilterItemDeclined: Metro.noop,
        onListCreate: Metro.noop
    };

    Metro.listSetup = function (options) {
        ListDefaultConfig = $.extend({}, ListDefaultConfig, options);
    };

    if (typeof window["metroListSetup"] !== undefined) {
        Metro.listSetup(window["metroListSetup"]);
    }

    Metro.Component('list', {
        init: function( options, elem ) {
            this._super(elem, options, ListDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                filterString: "",
                data: null,
                activity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                filterIndex: null,
                filtersIndexes: [],
                itemTemplate: null,

                sort: {
                    dir: "asc",
                    colIndex: 0
                },

                header: null,
                items: []
            });

            return this;
        },

        _create: function(){
            var that = this, o = this.options;

            if (o.source) {
                that._fireEvent("data-load", {
                    source: o.source
                });

                $.json(o.source).then(function(data){
                    that._fireEvent("data-loaded", {
                        source: o.source,
                        data: data
                    });
                    that._build(data);
                }, function(xhr){
                    that._fireEvent("data-load-error", {
                        source: o.source,
                        xhr: xhr
                    });
                });
            } else {
                that._build();
            }
        },

        _build: function(data){
            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("list-create");
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element, o = this.options;

            this.items = [];

            $.each(element.children(o.sortTarget), function(){
                that.items.push(this);
            });
        },

        _createItemsFromJSON: function(source){
            var that = this, o = this.options;

            this.items = [];

            if (Utils.isValue(source.template)) {
                this.itemTemplate = source.template;
            }

            if (Utils.isValue(source.header)) {
                this.header = source.header;
            }

            if (Utils.isValue(source.data)) {
                $.each(source.data, function(){
                    var item, row = this;
                    var li = document.createElement("li");

                    if (!Utils.isValue(that.itemTemplate)) {
                        return ;
                    }

                    item = Metro.template(that.itemTemplate, row, {
                        beginToken: o.templateBeginToken,
                        endToken: o.templateEndToken
                    });

                    li.innerHTML = item;
                    that.items.push(li);
                });
            }
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("list-top").addClass(o.clsListTop).insertBefore(element);
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("list-search-block").addClass(o.clsSearch).appendTo(top_block);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            search_input.input({
                prepend: o.listSearchTitle
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("list-rows-block").addClass(o.clsItemsCount).appendTo(top_block);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.itemsSteps.toArray(), function () {
                var option = $("<option>").attr("value", this === "all" ? -1 : this).text(this === "all" ? o.itemsAllTitle : this).appendTo(rows_select);
                if (parseInt(this) === parseInt(o.items)) {
                    option.attr("selected", "selected");
                }
            });
            rows_select.select({
                filter: false,
                prepend: o.listItemsCountTitle,
                onChange: function (val) {
                    if (parseInt(val) === parseInt(o.items)) {
                        return;
                    }
                    o.items = parseInt(val);
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showItemsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("list-bottom").addClass(o.clsListBottom).insertAfter(element);
            var info, pagination;

            info = $("<div>").addClass("list-info").addClass(o.clsListInfo).appendTo(bottom_block);
            if (o.showListInfo !== true) {
                info.hide();
            }

            pagination = $("<div>").addClass("list-pagination").addClass(o.clsListPagination).appendTo(bottom_block);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var list_component;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}

            if (!element.parent().hasClass("list-component")) {
                list_component = $("<div>").addClass("list-component").insertBefore(element);
                element.appendTo(list_component);
            } else {
                list_component = element.parent();
            }

            list_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("list-progress").appendTo(list_component);
            $("<div>").activity({
                type: o.activityType,
                style: o.activityStyle
            }).appendTo(this.activity);

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            // element.html("").addClass(o.clsList);
            element.addClass(o.clsList);

            this._createTopBlock();
            this._createBottomBlock();

            if (Utils.isValue(o.filterString)) {
                this.filterString = o.filterString;
            }

            var filter_func;

            if (Utils.isValue(o.filter)) {
                filter_func = Utils.isFunc(o.filter);
                if (filter_func === false) {
                    filter_func = Utils.func(o.filter);
                }
                that.filterIndex = that.addFilter(filter_func);
            }

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            if (o.sortInitial !== false)
                this.sorting(o.sortClass, o.sortDir, true);
            else
                this.draw();
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.on(Metro.events.inputchange, function(){
                that.filterString = this.value.trim().toLowerCase();
                if (that.filterString[that.filterString.length - 1] === ":") {
                    return ;
                }
                that.currentPage = 1;
                that._draw();
            });

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, function(){
                        that.filterString = this.value.trim().toLowerCase();
                        if (that.filterString[that.filterString.length - 1] === ":") {
                            return ;
                        }
                        that.currentPage = 1;
                        that._draw();
                    });
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.parent();
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".list-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.listInfoTitle;
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.parent();
            this.pagesCount = Math.ceil(length / o.items); // 
            Metro.pagination({
                length: length,
                rows: o.items,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".list-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle,
                nextTitle: o.paginationNextTitle,
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this,
                o = this.options,
                items, i, data, inset, c1, result;

            if (Utils.isValue(this.filterString) || this.filters.length > 0) {
                items = this.items.filter(function(item){
                    data = "";

                    if (Utils.isValue(o.filterClass)) {
                        inset = item.getElementsByClassName(o.filterClass);

                        if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                            data += inset[i].textContent;
                        }
                    } else {
                        data = item.textContent;
                    }

                    c1 = data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    result = Utils.isValue(that.filterString) ? c1.indexOf(that.filterString) > -1 : true;

                    if (result === true && that.filters.length > 0) {
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.exec(that.filters[i], [item]) !== true) {
                                result = false;
                                break;
                            }
                        }
                    }

                    if (result) {

                        that._fireEvent("filter-item-accepted", {
                            item: item
                        });

                    } else {

                        that._fireEvent("filter-item-declined", {
                            item: item
                        });

                    }

                    return result;
                });

                that._fireEvent("search", {
                    search: that.filterString,
                    items: items
                });

            } else {
                items = this.items;
            }

            return items;
        },

        _draw: function(cb){
            var element = this.element, o = this.options;
            var i;
            var start = o.items === -1 ? 0 : o.items * (this.currentPage - 1),
                stop = o.items === -1 ? this.items.length - 1 : start + o.items - 1;
            var items;

            items = this._filter();

            element.children(o.sortTarget).remove();

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    $(items[i]).addClass(o.clsListItem).appendTo(element);
                }

                this._fireEvent("draw-item", {
                    item: items[i]
                });

            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, [element], element[0])
            }
        },

        _getItemContent: function(item){
            var o = this.options, $item = $(item);
            var i, inset, data;
            var format, formatMask = Utils.isValue($item.data("formatMask")) ? $item.data("formatMask") : null;

            if (Utils.isValue(o.sortClass)) {
                data = "";
                inset = $(item).find("."+o.sortClass);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset.length > 0 ? inset[0].getAttribute("data-format") : "";
            } else {
                data = item.textContent;
                format = item.getAttribute("data-format");
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'integer', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = Utils.isValue(formatMask) ? data.toDate(formatMask) : new Date(data); break;
                    case "number": data = Number(data); break;
                    case "int":
                    case "integer": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        deleteItem: function(value){
            var i, deleteIndexes = [], item;
            var is_func = Utils.isFunc(value);

            for (i = 0; i < this.items.length; i++) {
                item = this.items[i];

                if (is_func) {
                    if (Utils.exec(value, [item])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (item.textContent.contains(value)) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            return this._draw();
        },

        sorting: function(source, dir, redraw){
            var that = this, o = this.options;

            if (Utils.isValue(source)) {
                o.sortClass = source;
            }
            if (Utils.isValue(dir) && ["asc", "desc"].indexOf(dir) > -1) {
                o.sortDir= dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = o.sortDir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = o.sortDir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            })

            if (redraw === true) {
                this._draw();
            }

            return this;
        },

        filter: function(val){
            this.filterString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
        },

        loadData: function(source){
            var that = this, element = this.element, o = this.options;

            if (Utils.isValue(source) !== true) {
                return ;
            }

            o.source = source;

            this._fireEvent("data-load", {
                source: o.source
            });

            $.json(o.source).then(function(data){

                that._fireEvent("data-loaded", {
                    source: o.source,
                    data: data
                });

                that._createItemsFromJSON(data);

                element.html("");

                if (Utils.isValue(o.filterString)) {
                    that.filterString = o.filterString;
                }

                var filter_func;

                if (Utils.isValue(o.filter)) {
                    filter_func = Utils.isFunc(o.filter);
                    if (filter_func === false) {
                        filter_func = Utils.func(o.filter);
                    }
                    that.filterIndex = that.addFilter(filter_func);
                }

                if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                    $.each(o.filters.toArray(), function(){
                        filter_func = Utils.isFunc(this);
                        if (filter_func !== false) {
                            that.filtersIndexes.push(that.addFilter(filter_func));
                        }
                    });
                }

                that.currentPage = 1;

                that.sorting(o.sortClass, o.sortDir, true);
            }, function(xhr){

                that._fireEvent("data-load-error", {
                    source: o.source,
                    xhr: xhr
                });

            });
        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
        },

        addFilter: function(f, redraw){
            var func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }
            this.filters.push(func);

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return this.filters.length - 1;
        },

        removeFilter: function(key, redraw){
            Utils.arrayDeleteByKey(this.filters, key);
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
        },

        getFilters: function(){
            return this.filters;
        },

        getFilterIndex: function(){
            return this.filterIndex;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function(){
                var dir = element.attr("data-sort-dir");
                if (!Utils.isValue(dir)) {
                    return ;
                }
                o.sortDir = dir;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeSortClass = function(){
                var target = element.attr("data-sort-source");
                if (!Utils.isValue(target)) {
                    return ;
                }
                o.sortClass = target;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeFilterString = function(){
                var filter = element.attr("data-filter-string");
                if (!Utils.isValue(filter)) {
                    return ;
                }
                o.filterString = filter;
                that.filter(o.filterString);
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-source": changeSortClass(); break;
                case "data-filter-string": changeFilterString(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.off(Metro.events.inputchange);
            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListViewDefaultConfig = {
        listviewDeferred: 0,
        selectable: false,
        checkStyle: 1,
        duration: 100,
        view: Metro.listView.LIST,
        selectCurrent: true,
        structure: {},
        onNodeInsert: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeClean: Metro.noop,
        onCollapseNode: Metro.noop,
        onExpandNode: Metro.noop,
        onGroupNodeClick: Metro.noop,
        onNodeClick: Metro.noop,
        onNodeDblclick: Metro.noop,
        onListViewCreate: Metro.noop
    };

    Metro.listViewSetup = function (options) {
        ListViewDefaultConfig = $.extend({}, ListViewDefaultConfig, options);
    };

    if (typeof window["metroListViewSetup"] !== undefined) {
        Metro.listViewSetup(window["metroListViewSetup"]);
    }

    Metro.Component('listview', {
        init: function( options, elem ) {
            this._super(elem, options, ListViewDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createView();
            this._createEvents();

            this._fireEvent("listview-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<div>").addClass("caption").html(data);
        },

        _createContent: function(data){
            return $("<div>").addClass("content").html(data);
        },

        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },

        _createNode: function(data){
            var that = this, o = this.options;
            var node;

            node = $("<li>");

            if (data.caption !== undefined || data.content !== undefined ) {
                var d = $("<div>").addClass("data");
                node.prepend(d);
                if (data.caption !== undefined) d.append(that._createCaption(data.caption));
                if (data.content !== undefined) d.append(that._createContent(data.content));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (Utils.objectLength(o.structure) > 0) $.each(o.structure, function(key, val){
                if (data[key] !== undefined) {
                    $("<div>").addClass("node-data item-data-"+key).addClass(data[val]).html(data[key]).appendTo(node);
                }
            });

            return node;
        },

        _createView: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");
            var struct_length = Utils.objectLength(o.structure);

            element.addClass("listview");
            element.find("ul").addClass("listview");

            $.each(nodes, function(){
                var node = $(this);

                if (node.data("caption") !== undefined || node.data("content") !== undefined) {
                    var data = $("<div>").addClass("data");
                    node.prepend(data);
                    if (node.data("caption") !== undefined) data.append(that._createCaption(node.data("caption")));
                    if (node.data("content") !== undefined) data.append(that._createContent(node.data("content")));
                }

                if (node.data('icon') !== undefined) {
                    node.prepend(that._createIcon(node.data('icon')));
                }

                if (node.children("ul").length > 0) {
                    node.addClass("node-group");
                    node.append(that._createToggle());
                    if (node.data("collapsed") !== true) node.addClass("expanded");
                } else {
                    node.addClass("node");
                }

                if (node.hasClass("node")) {
                    var cb = $("<input type='checkbox' data-role='checkbox' data-style='"+o.checkStyle+"'>");
                    cb.data("node", node);
                    node.prepend(cb);
                }

                if (struct_length > 0) $.each(o.structure, function(key){
                    if (node.data(key) !== undefined) {
                        $("<div>").addClass("node-data item-data-"+key).addClass(node.data(key)).html(node.data(key)).appendTo(node);
                    }
                });
            });

            this.toggleSelectable();

            this.view(o.view);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.dblclick, ".node", function(){
                var node = $(this);
                that._fireEvent("node-dblclick", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node", function(){
                var node = $(this);
                element.find(".node").removeClass("current");
                node.toggleClass("current");
                if (o.selectCurrent === true) {
                    element.find(".node").removeClass("current-select");
                    node.toggleClass("current-select");
                }
                that._fireEvent("node-click", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node-toggle", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);
            });

            element.on(Metro.events.click, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                element.find(".node-group").removeClass("current-group");
                node.addClass("current-group");

                that._fireEvent("group-node-click", {
                    node: node
                });

            });

            element.on(Metro.events.dblclick, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);

                that._fireEvent("node-dbl-click", {
                    node: node
                });
            });
        },

        view: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.view;
            }

            o.view = v;

            $.each(Metro.listView, function(i, v){
                element.removeClass("view-"+v);
                element.find("ul").removeClass("view-"+v);
            });

            element.addClass("view-" + o.view);
            element.find("ul").addClass("view-" + o.view);
        },

        toggleNode: function(node){
            var o = this.options;
            var func;

            node=$(node);

            if (!node.hasClass("node-group")) {
                return ;
            }

            node.toggleClass("expanded");

            func = node.hasClass("expanded") !== true ? "slideUp" : "slideDown";

            this._fireEvent("collapse-node", {
                node: node
            });

            node.children("ul")[func](o.duration);
        },

        toggleSelectable: function(){
            var element = this.element, o = this.options;
            var func = o.selectable === true ? "addClass" : "removeClass";
            element[func]("selectable");
            element.find("ul")[func]("selectable");
        },

        add: function(node, data){
            var element = this.element, o = this.options;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {

                node=$(node);

                if (!node.hasClass("node-group")) {
                    return ;
                }

                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").addClass("listview").addClass("view-"+o.view).appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.addClass("node").appendTo(target);

            var cb = $("<input type='checkbox'>");
            cb.data("node", new_node);
            new_node.prepend(cb);
            Metro.makePlugin(cb, "checkbox", {});

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: node,
                list: target
            });

            return new_node;
        },

        addGroup: function(data){
            var element = this.element, o = this.options;
            var node;

            delete data['icon'];

            node = this._createNode(data);
            node.addClass("node-group").appendTo(element);
            node.append(this._createToggle());
            node.addClass("expanded");
            node.append($("<ul>").addClass("listview").addClass("view-"+o.view));

            this._fireEvent("node-insert", {
                newNode: node,
                parentNode: null,
                list: element
            })

            return node;
        },

        insertBefore: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertBefore(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertAfter(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;

            node=$(node);

            if (!node.length) {return;}

            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");
            node.remove();
            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }

            this._fireEvent("node-delete", {
                node: node
            });
        },

        clean: function(node){
            node=$(node);

            if (!node.length) {return;}

            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node
            });
        },

        getSelected: function(){
            var element = this.element;
            var nodes = [];

            $.each(element.find(":checked"), function(){
                var check = $(this);
                nodes.push(check.closest(".node")[0])
            });

            return nodes;
        },

        clearSelected: function(){
            this.element.find(":checked").prop("checked", false);
            this.element.trigger('change');
        },

        selectAll: function(mode){
            this.element.find(".node > .checkbox input").prop("checked", mode !== false);
            this.element.trigger('change');
        },

        selectByAttribute: function(attributeName, attributeValue, select) {
            if (select !== false) {
                select = true;
            }
            this.element.find('li[' + attributeName + '="' + attributeValue + '"]' + ' > .checkbox input').prop("checked", select);
            this.element.trigger('change');
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeView = function(){
                var new_view = "view-"+element.attr("data-view");
                that.view(new_view);
            };

            var changeSelectable = function(){
                o.selectable = JSON.parse(element.attr("data-selectable")) === true;
                that.toggleSelectable();
            };

            switch (attributeName) {
                case "data-view": changeView(); break;
                case "data-selectable": changeSelectable(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node");
            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, ".node-group > .data > .caption");
            element.off(Metro.events.dblclick, ".node-group > .data > .caption");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MasterDefaultConfig = {
        masterDeferred: 0,
        effect: "slide", // slide, fade, switch, slowdown, custom
        effectFunc: "linear",
        duration: METRO_ANIMATION_DURATION,

        controlPrev: "<span class='default-icon-left-arrow'></span>",
        controlNext: "<span class='default-icon-right-arrow'></span>",
        controlTitle: "Master, page $1 of $2",
        backgroundImage: "",

        clsMaster: "",
        clsControls: "",
        clsControlPrev: "",
        clsControlNext: "",
        clsControlTitle: "",
        clsPages: "",
        clsPage: "",

        onBeforePage: Metro.noop_true,
        onBeforeNext: Metro.noop_true,
        onBeforePrev: Metro.noop_true,
        onNextPage: Metro.noop,
        onPrevPage: Metro.noop,
        onMasterCreate: Metro.noop
    };

    Metro.masterSetup = function (options) {
        MasterDefaultConfig = $.extend({}, MasterDefaultConfig, options);
    };

    if (typeof window["metroMasterSetup"] !== undefined) {
        Metro.masterSetup(window["metroMasterSetup"]);
    }

    Metro.Component('master', {
        init: function( options, elem ) {
            this._super(elem, options, MasterDefaultConfig, {
                pages: [],
                currentIndex: 0,
                isAnimate: false,
                id: Utils.elementId("master")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            element.addClass("master").addClass(o.clsMaster);
            element.css({
                backgroundImage: "url("+o.backgroundImage+")"
            });

            this._createControls();
            this._createPages();
            this._createEvents();

            this._fireEvent("master-create", {
                element: element
            });
        },

        _createControls: function(){
            var element = this.element, o = this.options;
            var controls_position = ['top', 'bottom'];
            var controls, title, pages = element.find(".page");

            title = String(o.controlTitle).replace("$1", "1");
            title = String(title).replace("$2", pages.length);

            $.each(controls_position, function(){
                controls = $("<div>").addClass("controls controls-"+this).addClass(o.clsControls).appendTo(element);
                $("<span>").addClass("prev").addClass(o.clsControlPrev).html(o.controlPrev).appendTo(controls);
                $("<span>").addClass("next").addClass(o.clsControlNext).html(o.controlNext).appendTo(controls);
                $("<span>").addClass("title").addClass(o.clsControlTitle).html(title).appendTo(controls);
            });

            this._enableControl("prev", false);
        },

        _enableControl: function(type, state){
            var control = this.element.find(".controls ." + type);
            if (state === true) {
                control.removeClass("disabled");
            } else {
                control.addClass("disabled");
            }
        },

        _setTitle: function(){
            var title = this.element.find(".controls .title");

            var title_str = this.options.controlTitle.replace("$1", this.currentIndex + 1);
            title_str = title_str.replace("$2", String(this.pages.length));

            title.html(title_str);
        },

        _createPages: function(){
            var that = this, element = this.element, o = this.options;
            var pages = element.find(".pages");
            var page = element.find(".page");

            if (pages.length === 0) {
                pages = $("<div>").addClass("pages").appendTo(element);
            }

            pages.addClass(o.clsPages);

            $.each(page, function(){
                var p = $(this);
                if (p.data("cover") !== undefined) {
                    element.css({
                        backgroundImage: "url("+p.data('cover')+")"
                    });
                } else {
                    element.css({
                        backgroundImage: "url("+o.backgroundImage+")"
                    });
                }

                p.css({
                    left: "100%"
                });

                p.addClass(o.clsPage).hide(0);

                that.pages.push(p);
            });

            page.appendTo(pages);

            this.currentIndex = 0;
            if (this.pages[this.currentIndex] !== undefined) {
                if (this.pages[this.currentIndex].data("cover") !== undefined ) {
                    element.css({
                        backgroundImage: "url("+this.pages[this.currentIndex].data('cover')+")"
                    });
                }
                this.pages[this.currentIndex].css("left", "0").show(0);
                setTimeout(function(){
                    pages.css({
                        height: that.pages[0].outerHeight(true) + 2
                    });
                }, 0);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".controls .prev", function(){
                if (that.isAnimate === true) {
                    return ;
                }
                if (
                    Utils.exec(o.onBeforePrev, [that.currentIndex, that.pages[that.currentIndex], element]) === true &&
                    Utils.exec(o.onBeforePage, ["prev", that.currentIndex, that.pages[that.currentIndex], element]) === true
                ) {
                    that.prev();
                }
            });

            element.on(Metro.events.click, ".controls .next", function(){
                if (that.isAnimate === true) {
                    return ;
                }
                if (
                    Utils.exec(o.onBeforeNext, [that.currentIndex, that.pages[that.currentIndex], element]) === true &&
                    Utils.exec(o.onBeforePage, ["next", that.currentIndex, that.pages[that.currentIndex], element]) === true
                ) {
                    that.next();
                }
            });

            $(window).on(Metro.events.resize, function(){
                element.find(".pages").height(that.pages[that.currentIndex].outerHeight(true) + 2);
            }, {ns: this.id});
        },

        _slideToPage: function(index){
            var current, next, to;

            if (this.pages[index] === undefined) {
                return ;
            }

            if (this.currentIndex === index) {
                return ;
            }

            to = index > this.currentIndex ? "next" : "prev";
            current = this.pages[this.currentIndex];
            next = this.pages[index];

            this.currentIndex = index;

            this._effect(current, next, to);
        },

        _slideTo: function(to){
            var current, next, forward = to.toLowerCase() === 'next';

            current = this.pages[this.currentIndex];

            if (forward ) {
                if (this.currentIndex + 1 >= this.pages.length) {
                    return ;
                }
                this.currentIndex++;
            } else {
                if (this.currentIndex - 1 < 0) {
                    return ;
                }
                this.currentIndex--;
            }

            next = this.pages[this.currentIndex];

            this._fireEvent(forward ? "next-page" : "prev-page", {
                current: current,
                next: next,
                forward: forward
            });

            this._effect(current, next, to);
        },

        _effect: function(current, next, to){
            var that = this, element = this.element, o = this.options;
            var out = element.width();
            var pages = element.find(".pages");

            this._setTitle();

            if (this.currentIndex === this.pages.length - 1) {
                this._enableControl("next", false);
            } else {
                this._enableControl("next", true);
            }

            if (this.currentIndex === 0) {
                this._enableControl("prev", false);
            } else {
                this._enableControl("prev", true);
            }

            this.isAnimate = true;

            setTimeout(function(){
                pages.animate({
                    draw: {
                        height: next.outerHeight(true) + 2
                    }
                });
            },0);

            pages.css("overflow", "hidden");

            function finish(){
                if (next.data("cover") !== undefined) {
                    element.css({
                        backgroundImage: "url("+next.data('cover')+")"
                    });
                } else {
                    element.css({
                        backgroundImage: "url("+o.backgroundImage+")"
                    });
                }
                pages.css("overflow", "initial");
                that.isAnimate = false;
            }

            function _slide(){
                current
                    .stop(true)
                    .animate({
                        draw: {
                            left: to === "next" ? -out : out
                        },
                        dur: o.duration,
                        ease: o.effectFunc,
                        onDone: function(){
                            current.hide(0);
                        }
                    });

                next
                    .stop(true)
                    .css({
                        left: to === "next" ? out : -out
                    })
                    .show(0)
                    .animate({
                        draw: {
                            left: 0
                        },
                        dur: o.duration,
                        ease: o.effectFunc,
                        onDone: function(){
                            finish();
                        }
                    });
            }

            function _switch(){
                current.hide();

                next.css({
                    top: 0,
                    left: 0,
                    opacity: 0
                }).show(function(){
                    finish();
                });
            }

            function _fade(){
                current.fadeOut(o.duration);

                next.css({
                    top: 0,
                    left: 0,
                    opacity: 0
                }).fadeIn(o.duration, "linear", function(){
                    finish();
                });
            }

            switch (o.effect) {
                case "fade": _fade(); break;
                case "switch": _switch(); break;
                default: _slide();
            }
        },

        toPage: function(index){
            this._slideToPage(index);
        },

        next: function(){
            this._slideTo("next");
        },

        prev: function(){
            this._slideTo("prev");
        },

        changeEffect: function(){
            this.options.effect = this.element.attr("data-effect");
        },

        changeEffectFunc: function(){
            this.options.effectFunc = this.element.attr("data-effect-func");
        },

        changeEffectDuration: function(){
            this.options.duration = this.element.attr("data-duration");
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-effect": this.changeEffect(); break;
                case "data-effect-func": this.changeEffectFunc(); break;
                case "data-duration": this.changeEffectDuration(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".controls .prev");
            element.off(Metro.events.click, ".controls .next");
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NavigationViewDefaultConfig = {
        navviewDeferred: 0,
        compact: "md",
        expand: "lg",
        toggle: null,
        activeState: false,
        onMenuItemClick: Metro.noop,
        onNavviewCreate: Metro.noop
    };

    Metro.navViewSetup = function (options) {
        NavigationViewDefaultConfig = $.extend({}, NavigationViewDefaultConfig, options);
    };

    if (typeof window["metroNavViewSetup"] !== undefined) {
        Metro.navViewSetup(window["metroNavViewSetup"]);
    }

    Metro.Component('nav-view', {
        init: function( options, elem ) {
            this._super(elem, options, NavigationViewDefaultConfig, {
                pane: null,
                content: null,
                paneToggle: null,
                id: Utils.elementId("navview"),
                menuScrollDistance: 0,
                menuScrollStep: 0
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("navview-create");
        },

        _calcMenuHeight: function(){
            var element = this.element, pane, menu_container;
            var elements_height = 0;

            pane = element.children(".navview-pane");
            if (pane.length === 0) {
                return;
            }

            menu_container = pane.children(".navview-menu-container");

            if (menu_container.length === 0) {
                return ;
            }

            $.each(menu_container.prevAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            $.each(menu_container.nextAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            menu_container.css({
                height: "calc(100% - "+(elements_height)+"px)"
            });

            this.menuScrollStep = 48;
            this.menuScrollDistance = Utils.nearest(menu_container[0].scrollHeight - menu_container.height(), 48);
        },

        _recalc: function(){
            var that = this, element = this.element;
            setTimeout(function(){
                if (that.pane.width() === 48) {
                    element.addClass("js-compact");
                } else {
                    element.removeClass("js-compact");
                }
                that._calcMenuHeight();
            }, 200);
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var pane, content, toggle, menu/*, menu_container, menu_h, menu_container_h*/;

            element
                .addClass("navview")
                .addClass(o.compact !== false ? "navview-compact-"+o.compact : "")
                .addClass(o.expand !== false ? "navview-expand-"+o.expand : "");

            pane = element.children(".navview-pane");
            content = element.children(".navview-content");
            toggle = $(o.toggle);
            menu = pane.children(".navview-menu");

            if (menu.length) {
                menu.prevAll().reverse().wrapAll($("<div>").addClass("navview-container"));
                menu.wrap($("<div>").addClass("navview-menu-container"));
            }

            this.pane = pane.length > 0 ? pane : null;
            this.content = content.length > 0 ? content : null;
            this.paneToggle = toggle.length > 0 ? toggle : null;

            this._recalc();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var menu_container = element.find(".navview-menu-container");
            var menu = menu_container.children(".navview-menu");

            menu_container.on("mousewheel", function(e){
                var pane_width = element.find(".navview-pane").width();
                var dir = e.deltaY > 0 ? -1 : 1;
                var step = that.menuScrollStep;
                var distance = that.menuScrollDistance;
                var top = parseInt(menu.css('top'));

                if (pane_width > 48 /*|| !element.hasClass("compacted") */) {
                    return false;
                }

                if(dir === -1 && Math.abs(top) <= distance) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }

                if(dir === 1 && top <= -step) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }
            });

            element.on(Metro.events.click, ".pull-button, .holder", function(){
                that.pullClick(this);
            });

            element.on(Metro.events.click, ".navview-menu li", function(){
                if (o.activeState === true) {
                    element.find(".navview-menu li").removeClass("active");
                    $(this).toggleClass("active");
                }
            });

            element.on(Metro.events.click, ".navview-menu li > a", function(){

                that._fireEvent("menu-item-click", {
                    item: this
                });

            });

            if (this.paneToggle !== null) {
                this.paneToggle.on(Metro.events.click, function(){
                    that.pane.toggleClass("open");
                })
            }

            $(window).on(Metro.events.resize, function(){
                var menu_h, menu_container_h,
                    menu_container = element.children(".navview-menu-container"),
                    menu;

                if (that.pane.hasClass("open")) {
                    that._recalc();
                    return ;
                }

                element.removeClass("expanded");
                that.pane.removeClass("open");

                if ($(this).width() <= Metro.media_sizes[(""+o.compact).toUpperCase()]) {
                    element.removeClass("compacted");
                }

                if (menu_container.length) {
                    menu = menu_container.children(".navview-menu");
                    setTimeout(function () {
                        menu_h = menu.height();
                        menu_container_h = menu_container.height();
                        that.menuScrollStep = menu.children(":not(.item-separator), :not(.item-header)")[0].clientHeight;
                        that.menuScrollDistance = menu_h > menu_container_h ? Utils.nearest(menu_h - menu_container_h, that.menuScrollStep) : 0;
                    }, 0);
                }

                that._recalc();

            }, {ns: this.id})
        },

        _togglePaneMode: function(){
            var element = this.element;
            var pane = this.pane;
            var pane_compact = pane.width() < 280;

            if ((pane_compact || element.hasClass("expanded")) && !element.hasClass("compacted")) {
                element.toggleClass("expanded");
            } else

            if (element.hasClass("compacted") || !pane_compact) {
                element.toggleClass("compacted");
            }

        },

        pullClick: function(el){
            var that = this;
            var input;

            var target = $(el);

            if (target && target.hasClass("holder")) {
                input = target.parent().find("input");
                setTimeout(function(){
                    input.focus();
                }, 200);
            }

            if (that.pane.hasClass("open")) {
                that.close();
            } else {
                this._togglePaneMode();
            }

            this._recalc();

            return true;
        },

        open: function(){
            this.pane.addClass("open");
        },

        close: function(){
            this.pane.removeClass("open");
        },

        toggle: function(){
            var pane = this.pane;
            pane.hasClass("open") ? pane.removeClass("open") : pane.addClass("open");
        },

        toggleMode: function(){
            this._togglePaneMode();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".pull-button, .holder");
            element.off(Metro.events.click, ".navview-menu li");
            element.off(Metro.events.click, ".navview-menu li > a");

            if (this.paneToggle !== null) {
                this.paneToggle.off(Metro.events.click);
            }

            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NotifyDefaultConfig = {
        container: null,
        width: 220,
        timeout: METRO_TIMEOUT,
        duration: METRO_ANIMATION_DURATION,
        distance: "max",
        animation: "linear",
        onClick: Metro.noop,
        onClose: Metro.noop,
        onShow: Metro.noop,
        onAppend: Metro.noop,
        onNotifyCreate: Metro.noop

    };

    Metro.notifySetup = function(options){
        NotifyDefaultConfig = $.extend({}, NotifyDefaultConfig, options);
    };

    if (typeof window["metroNotifySetup"] !== undefined) {
        Metro.notifySetup(window["metroNotifySetup"]);
    }

    var Notify = {

        container: null,

        options: {
        },

        notifies: [],

        setup: function(options){
            this.options = $.extend({}, NotifyDefaultConfig, options);

            return this;
        },

        reset: function(){
            var reset_options = {
                width: 220,
                timeout: METRO_TIMEOUT,
                duration: METRO_ANIMATION_DURATION,
                distance: "max",
                animation: "linear"
            };
            this.options = $.extend({}, NotifyDefaultConfig, reset_options);
        },

        _createContainer: function(){

            var container = $("<div>").addClass("notify-container");
            $("body").prepend(container);

            return container;
        },

        create: function(message, title, options){
            var notify, that = this, o = this.options;
            var m, t, id = Utils.elementId("notify");

            if (Utils.isNull(options)) {
                options = {};
            }

            if (!Utils.isValue(message)) {
                return false;
            }

            notify = $("<div>").addClass("notify").attr("id", id);
            notify.css({
                width: o.width
            });

            if (title) {
                t = $("<div>").addClass("notify-title").html(title);
                notify.prepend(t);
            }
            m = $("<div>").addClass("notify-message").html(message);
            m.appendTo(notify);

            // Set options
            /*
            * keepOpen, cls, width, callback
            * */
            if (options !== undefined) {
                if (options.cls !== undefined) {
                    notify.addClass(options.cls);
                }
                if (options.width !== undefined) {
                    notify.css({
                        width: options.width
                    });
                }
            }

            notify.on(Metro.events.click, function(){
                Utils.exec(Utils.isValue(options.onClick) ? options.onClick : o.onClick, null, this);
                that.kill($(this).closest(".notify"), Utils.isValue(options.onClose) ? options.onClose : o.onClose);
            });

            // Show
            if (Notify.container === null) {
                Notify.container = Notify._createContainer();
            }
            notify.appendTo(Notify.container);

            notify.hide(function(){

                Utils.exec(Utils.isValue(options.onAppend) ? options.onAppend : o.onAppend, null, notify[0]);

                var duration = Utils.isValue(options.duration) ? options.duration : o.duration;
                var animation = Utils.isValue(options.animation) ? options.animation : o.animation;
                var distance = Utils.isValue(options.distance) ? options.distance : o.distance;

                if (distance === "max" || isNaN(distance)) {
                    distance = $(window).height();
                }

                notify
                    .show()
                    .animate({
                        draw: {
                            marginTop: [distance, 4],
                            opacity: [0, 1]
                        },
                        dur: duration,
                        ease: animation,
                        onDone: function(){
                            Utils.exec(o.onNotifyCreate, null, this);

                            if (options !== undefined && options.keepOpen === true) {
                                /* eslint-disable-next-line */

                            } else {
                                setTimeout(function(){
                                    that.kill(notify, Utils.isValue(options.onClose) ? options.onClose : o.onClose);
                                }, o.timeout);
                            }

                            Utils.exec(Utils.isValue(options.onShow) ? options.onShow : o.onShow, null, notify[0]);
                        }
                    });

            });
        },

        kill: function(notify, callback){
            var that = this, o = this.options;
            notify.off(Metro.events.click);
            notify.fadeOut(o.duration, 'linear', function(){
                Utils.exec(Utils.isValue(callback) ? callback : that.options.onClose, null, notify[0]);
                notify.remove();
            });
        },

        killAll: function(){
            var that = this;
            var notifies = $(".notify");
            $.each(notifies, function(){
                that.kill($(this));
            });
        }
    };

    Metro['notify'] = Notify.setup();
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    Metro.pagination = function(c){
        var defConf = {
            length: 0,
            rows: 0,
            current: 0,
            target: "body",
            clsPagination: "",
            prevTitle: "Prev",
            nextTitle: "Next",
            distance: 5
        }, conf;
        var pagination;
        var pagination_wrapper;
        var i, prev, next;
        var shortDistance;

        conf = $.extend( {}, defConf, c);

        shortDistance = parseInt(conf.distance);
        pagination_wrapper = $(conf.target);
        pagination_wrapper.html("");
        pagination = $("<ul>").addClass("pagination").addClass(conf.clsPagination).appendTo(pagination_wrapper);

        if (conf.length === 0) {
            return ;
        }

        if (conf.rows === -1) {
            return ;
        }

        conf.pages = Math.ceil(conf.length / conf.rows);

        var add_item = function(item_title, item_type, data){
            var li, a;

            li = $("<li>").addClass("page-item").addClass(item_type);
            a  = $("<a>").addClass("page-link").html(item_title);
            a.data("page", data);
            a.appendTo(li);

            return li;
        };

        prev = add_item(conf.prevTitle, "service prev-page", "prev");
        pagination.append(prev);

        pagination.append(add_item(1, conf.current === 1 ? "active" : "", 1));

        if (shortDistance === 0 || conf.pages <= 7) {
            for (i = 2; i < conf.pages; i++) {
                pagination.append(add_item(i, i === conf.current ? "active" : "", i));
            }
        } else {
            if (conf.current < shortDistance) {
                for (i = 2; i <= shortDistance; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }

                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }
            } else if (conf.current <= conf.pages && conf.current > conf.pages - shortDistance + 1) {
                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }

                for (i = conf.pages - shortDistance + 1; i < conf.pages; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }
            } else {
                pagination.append(add_item("...", "no-link", null));

                pagination.append(add_item(conf.current - 1, "", conf.current - 1));
                pagination.append(add_item(conf.current, "active", conf.current));
                pagination.append(add_item(conf.current + 1, "", conf.current + 1));

                pagination.append(add_item("...", "no-link", null));
            }
        }

        if (conf.pages > 1 || conf.current < conf.pages) pagination.append(add_item(conf.pages, conf.current === conf.pages ? "active" : "", conf.pages));

        next = add_item(conf.nextTitle, "service next-page", "next");
        pagination.append(next);

        if (conf.current === 1) {
            prev.addClass("disabled");
        }

        if (conf.current === conf.pages) {
            next.addClass("disabled");
        }

        if (conf.length === 0) {
            pagination.addClass("disabled");
            pagination.children().addClass("disabled");
        }

        return pagination;
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PanelDefaultConfig = {
        panelDeferred: 0,
        id: null,
        titleCaption: "",
        titleIcon: "",
        collapsible: false,
        collapsed: false,
        collapseDuration: METRO_ANIMATION_DURATION,
        width: "auto",
        height: "auto",
        draggable: false,

        customButtons: null,
        clsCustomButton: "",

        clsPanel: "",
        clsTitle: "",
        clsTitleCaption: "",
        clsTitleIcon: "",
        clsContent: "",
        clsCollapseToggle: "",

        onCollapse: Metro.noop,
        onExpand: Metro.noop,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onPanelCreate: Metro.noop
    };

    Metro.panelSetup = function (options) {
        PanelDefaultConfig = $.extend({}, PanelDefaultConfig, options);
    };

    if (typeof window["metroPanelSetup"] !== undefined) {
        Metro.panelSetup(window["metroPanelSetup"]);
    }

    Metro.Component('panel', {
        init: function( options, elem ) {
            this._super(elem, options, PanelDefaultConfig);

            return this;
        },

        _addCustomButtons: function(buttons){
            var element = this.element, o = this.options;
            var title = element.closest(".panel").find(".panel-title");
            var buttonsContainer, customButtons = [];

            if (typeof buttons === "string" && buttons.indexOf("{") > -1) {
                customButtons = JSON.parse(buttons);
            } else if (typeof buttons === "string" && Utils.isObject(buttons)) {
                customButtons = Utils.isObject(buttons);
            } else if (typeof buttons === "object" && Utils.objectLength(buttons) > 0) {
                customButtons = buttons;
            } else {
                console.warn("Unknown format for custom buttons", buttons);
                return ;
            }

            if (title.length === 0) {
                console.warn("No place for custom buttons");
                return ;
            }

            buttonsContainer = title.find(".custom-buttons");

            if (buttonsContainer.length === 0) {
                buttonsContainer = $("<div>").addClass("custom-buttons").appendTo(title);
            } else {
                buttonsContainer.find(".btn-custom").off(Metro.events.click);
                buttonsContainer.html("");
            }

            $.each(customButtons, function(){
                var item = this;
                var customButton = $("<span>");

                customButton
                    .addClass("button btn-custom")
                    .addClass(o.clsCustomButton)
                    .addClass(item.cls)
                    .attr("tabindex", -1)
                    .html(item.html);

                if (item.attr && typeof item.attr === 'object') {
                    $.each(item.attr, function(k, v){
                        customButton.attr($.dashedName(k), v);
                    });
                }

                customButton.data("action", item.onclick);

                buttonsContainer.prepend(customButton);
            });

            title.on(Metro.events.click, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var panel = $("<div>").addClass("panel").addClass(o.clsPanel);
            var id = o.id ? o.id : Utils.elementId("panel");
            var original_classes = element[0].className;
            var title;

            panel.attr("id", id).addClass(original_classes);
            panel.insertBefore(element);
            element.appendTo(panel);

            element[0].className = '';
            element.addClass("panel-content").addClass(o.clsContent).appendTo(panel);

            if (o.titleCaption !== "" || o.titleIcon !== "" || o.collapsible === true) {
                title = $("<div>").addClass("panel-title").addClass(o.clsTitle);

                if (o.titleCaption !== "") {
                    $("<span>").addClass("caption").addClass(o.clsTitleCaption).html(o.titleCaption).appendTo(title)
                }

                if (o.titleIcon !== "") {
                    $(o.titleIcon).addClass("icon").addClass(o.clsTitleIcon).appendTo(title)
                }

                if (o.collapsible === true) {
                    var collapseToggle = $("<span>").addClass("dropdown-toggle marker-center active-toggle").addClass(o.clsCollapseToggle).appendTo(title);
                    Metro.makePlugin(element, "collapse", {
                        toggleElement: collapseToggle,
                        duration: o.collapseDuration,
                        onCollapse: o.onCollapse,
                        onExpand: o.onExpand
                    });

                    if (o.collapsed === true) {
                        this.collapse();
                    }
                }

                title.appendTo(panel);
            }

            if (title && Utils.isValue(o.customButtons)) {
                this._addCustomButtons(o.customButtons);
            }

            if (o.draggable === true) {
                var dragElement;

                if (title) {
                    dragElement = title.find(".caption, .icon");
                } else {
                    dragElement = panel;
                }

                Metro.makePlugin(panel, "draggable", {
                    dragContext: panel[0],
                    dragElement: dragElement,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            if (o.width !== "auto" && parseInt(o.width) >= 0) {
                panel.outerWidth(parseInt(o.width));
            }

            if (o.height !== "auto" && parseInt(o.height) >= 0) {
                panel.outerHeight(parseInt(o.height));
                element.css({overflow: "auto"});
            }

            this.panel = panel;

            this._fireEvent("panel-create", {
                element: element,
                panel: panel
            });
        },

        customButtons: function(buttons){
            return this._addCustomButtons(buttons);
        },

        collapse: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').collapse();
        },

        open: function(){
            this.expand();
        },

        close: function(){
            this.collapse();
        },

        expand: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').expand();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;

            if (o.collapsible === true) {
                Metro.getPlugin(element, "collapse").destroy();
            }

            if (o.draggable === true) {
                Metro.getPlugin(element, "draggable").destroy();
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PopoverDefaultConfig = {
        popoverDeferred: 0,
        popoverText: "",
        popoverHide: 3000,
        popoverTimeout: 10,
        popoverOffset: 10,
        popoverTrigger: Metro.popoverEvents.HOVER,
        popoverPosition: Metro.position.TOP,
        hideOnLeave: false,
        closeButton: true,
        clsPopover: "",
        clsPopoverContent: "",
        onPopoverShow: Metro.noop,
        onPopoverHide: Metro.noop,
        onPopoverCreate: Metro.noop
    };

    Metro.popoverSetup = function (options) {
        PopoverDefaultConfig = $.extend({}, PopoverDefaultConfig, options);
    };

    if (typeof window["metroPopoverSetup"] !== undefined) {
        Metro.popoverSetup(window["metroPopoverSetup"]);
    }

    Metro.Component('popover', {
        init: function( options, elem ) {
            this._super(elem, options, PopoverDefaultConfig, {
                popover: null,
                popovered: false,
                size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("popover")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("popover-create", {
                element: this.element
            })
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.on(event, function(){
                if (that.popover !== null || that.popovered === true) {
                    return ;
                }
                setTimeout(function(){
                    that.createPopover();

                    that._fireEvent("popover-show", {
                        popover: that.popover
                    });

                    if (o.popoverHide > 0) {
                        setTimeout(function(){
                            that.removePopover();
                        }, o.popoverHide);
                    }
                }, o.popoverTimeout);
            });

            if (o.hideOnLeave === true) {
                element.on(Metro.events.leave, function(){
                    that.removePopover();
                });
            }

            $(window).on(Metro.events.scroll, function(){
                if (that.popover !== null) that.setPosition();
            }, {ns: this.id});
        },

        setPosition: function(){
            var popover = this.popover, size = this.size, o = this.options, element = this.element;

            if (o.popoverPosition === Metro.position.BOTTOM) {
                popover.addClass('bottom');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            } else if (o.popoverPosition === Metro.position.RIGHT) {
                popover.addClass('right');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.popoverOffset
                });
            } else if (o.popoverPosition === Metro.position.LEFT) {
                popover.addClass('left');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - size.width - $(window).scrollLeft() - o.popoverOffset
                });
            } else {
                popover.addClass('top');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() - size.height - o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            }
        },

        createPopover: function(){
            var that = this, elem = this.elem, element = this.element, o = this.options;
            var popover;
            var neb_pos;
            var id = Utils.elementId("popover");
            var closeButton;

            if (this.popovered) {
                return ;
            }

            popover = $("<div>").addClass("popover neb").addClass(o.clsPopover);
            popover.attr("id", id);

            $("<div>").addClass("popover-content").addClass(o.clsPopoverContent).html(o.popoverText).appendTo(popover);

            if (o.popoverHide === 0 && o.closeButton === true) {
                closeButton = $("<button>").addClass("button square small popover-close-button bg-white").html("&times;").appendTo(popover);
                closeButton.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            switch (o.popoverPosition) {
                case Metro.position.TOP: neb_pos = "neb-s"; break;
                case Metro.position.BOTTOM: neb_pos = "neb-n"; break;
                case Metro.position.RIGHT: neb_pos = "neb-w"; break;
                case Metro.position.LEFT: neb_pos = "neb-e"; break;
            }

            popover.addClass(neb_pos);

            if (o.closeButton !== true) {
                popover.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            this.popover = popover;
            this.size = Utils.hiddenElementSize(popover);

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                element = wrp;
            }

            this.setPosition();

            popover.appendTo($('body'));

            this.popovered = true;

            this._fireEvent("popover-create", {
                popover: popover
            });
        },

        removePopover: function(){
            var that = this;
            var timeout = this.options.onPopoverHide === Metro.noop ? 0 : 300;
            var popover = this.popover;

            if (!this.popovered) {
                return ;
            }

            this._fireEvent("popover-hide", {
                popover: popover
            });

            setTimeout(function(){
                popover.hide(0, function(){
                    popover.remove();
                    that.popover = null;
                    that.popovered = false;
                });
            }, timeout);
        },

        show: function(){
            var that = this, o = this.options;

            if (this.popovered === true) {
                return ;
            }

            setTimeout(function(){
                that.createPopover();

                that._fireEvent("popover-show", {
                    popover: that.popover
                });

                if (o.popoverHide > 0) {
                    setTimeout(function(){
                        that.removePopover();
                    }, o.popoverHide);
                }
            }, o.popoverTimeout);
        },

        hide: function(){
            this.removePopover();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeText = function(){
                o.popoverText = element.attr("data-popover-text");
                if (that.popover) {
                    that.popover.find(".popover-content").html(o.popoverText);
                    that.setPosition();
                }
            };

            var changePosition = function(){
                o.popoverPosition = element.attr("data-popover-position");
                that.setPosition();
            };

            switch (attributeName) {
                case "data-popover-text": changeText(); break;
                case "data-popover-position": changePosition(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.off(event);

            if (o.hideOnLeave === true) {
                element.off(Metro.events.leave);
            }

            $(window).off(Metro.events.scroll,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ProgressDefaultConfig = {
        progressDeferred: 0,
        showValue: false,
        valuePosition: "free", // center, free
        showLabel: false,
        labelPosition: "before", // before, after
        labelTemplate: "",
        value: 0,
        buffer: 0,
        type: "bar",
        small: false,
        clsBack: "",
        clsBar: "",
        clsBuffer: "",
        clsValue: "",
        clsLabel: "",
        onValueChange: Metro.noop,
        onBufferChange: Metro.noop,
        onComplete: Metro.noop,
        onBuffered: Metro.noop,
        onProgressCreate: Metro.noop
    };

    Metro.progressSetup = function (options) {
        ProgressDefaultConfig = $.extend({}, ProgressDefaultConfig, options);
    };

    if (typeof window["metroProgressSetup"] !== undefined) {
        Metro.progressSetup(window["metroProgressSetup"]);
    }

    Metro.Component('progress', {
        init: function( options, elem ) {
            this._super(elem, options, ProgressDefaultConfig, {
                value: 0,
                buffer: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var value;

            if (typeof o.type === "string") o.type = o.type.toLowerCase();

            element
                .html("")
                .addClass("progress");

            function _progress(){
                $("<div>").addClass("bar").appendTo(element);
            }

            function _buffer(){
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
            }

            function _load(){
                element.addClass("with-load");
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
                $("<div>").addClass("load").appendTo(element);
            }

            function _line(){
                element.addClass("line");
            }

            switch (o.type) {
                case "buffer": _buffer(); break;
                case "load": _load(); break;
                case "line": _line(); break;
                default: _progress();
            }

            if (o.type !== 'line') {
                value = $("<span>").addClass("value").addClass(o.clsValue).appendTo(element);
                if (o.valuePosition === "center") value.addClass("centered");
                if (o.showValue === false) value.hide();
            }

            if (o.small === true) element.addClass("small");

            element.addClass(o.clsBack);
            element.find(".bar").addClass(o.clsBar);
            element.find(".buffer").addClass(o.clsBuffer);

            if (o.showLabel === true) {
                var label = $("<span>").addClass("progress-label").addClass(o.clsLabel).html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                if (o.labelPosition === 'before') {
                    label.insertBefore(element);
                } else {
                    label.insertAfter(element);
                }
            }

            this.val(o.value);
            this.buff(o.buffer);

            this._fireEvent("progress-create", {
                element: element
            });
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var value = element.find(".value");

            if (v === undefined) {
                return that.value;
            }

            var bar  = element.find(".bar");

            if (bar.length === 0) {
                return false;
            }

            this.value = parseInt(v, 10);

            bar.css("width", this.value + "%");
            value.html(this.value+"%");

            var diff = element.width() - bar.width();
            var valuePosition = value.width() > diff ? {left: "auto", right: diff + 'px'} : {left: v + '%'};

            if (o.valuePosition === "free") value.css(valuePosition);

            if (o.showLabel === true) {
                var label = element[o.labelPosition === "before" ? "prev" : "next"](".progress-label");
                if (label.length) {
                    label.html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                }
            }

            this._fireEvent("value-change", {
                val: this.value
            });

            if (this.value === 100) {

                this._fireEvent("complete", {
                    val: this.value
                });

            }
        },

        buff: function(v){
            var that = this, element = this.element;

            if (v === undefined) {
                return that.buffer;
            }

            var bar  = element.find(".buffer");

            if (bar.length === 0) {
                return false;
            }

            this.buffer = parseInt(v, 10);

            bar.css("width", this.buffer + "%");

            this._fireEvent("buffer-change", {
                val: this.buffer
            });

            if (this.buffer === 100) {
                this._fireEvent("buffered", {
                    val: this.buffer
                });
            }
        },

        changeValue: function(){
            this.val(this.element.attr('data-value'));
        },

        changeBuffer: function(){
            this.buff(this.element.attr('data-buffer'));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-value': this.changeValue(); break;
                case 'data-buffer': this.changeBuffer(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RadioDefaultConfig = {
        radioDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        clsRadio: "",
        clsCheck: "",
        clsCaption: "",
        onRadioCreate: Metro.noop
    };

    Metro.radioSetup = function (options) {
        RadioDefaultConfig = $.extend({}, RadioDefaultConfig, options);
    };

    if (typeof window["metroRadioSetup"] !== undefined) {
        Metro.radioSetup(window["metroRadioSetup"]);
    }

    Metro.Component('radio', {
        init: function( options, elem ) {
            this._super(elem, options, RadioDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("radio-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var radio = $("<label>").addClass("radio " + element[0].className).addClass(o.style === 2 ? "style2" : "");
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "radio");

            radio.insertBefore(element);
            element.appendTo(radio);
            check.appendTo(radio);
            caption.appendTo(radio);

            if (o.transition === true) {
                radio.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                radio.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            radio.addClass(o.clsRadio);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Colors = Metro.colors;
    var RatingDefaultConfig = {
        ratingDeferred: 0,
        label: "",
        static: false,
        title: null,
        value: 0,
        values: null,
        message: "",
        stars: 5,
        starColor: null,
        staredColor: null,
        roundFunc: "round", // ceil, floor, round
        half: true,
        clsRating: "",
        clsTitle: "",
        clsStars: "",
        clsResult: "",
        clsLabel: "",
        onStarClick: Metro.noop,
        onRatingCreate: Metro.noop
    };

    Metro.ratingSetup = function (options) {
        RatingDefaultConfig = $.extend({}, RatingDefaultConfig, options);
    };

    if (typeof window["metroRatingSetup"] !== undefined) {
        Metro.ratingSetup(window["metroRatingSetup"]);
    }

    Metro.Component('rating', {
        init: function( options, elem ) {
            this._super(elem, options, RatingDefaultConfig, {
                value: 0,
                originValue: 0,
                values: [],
                rate: 0,
                rating: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i;

            if (isNaN(o.value)) {
                o.value = 0;
            } else {
                o.value = parseFloat(o.value).toFixed(1);
            }

            if (o.values !== null) {
                if (Array.isArray(o.values)) {
                    this.values = o.values;
                } else if (typeof o.values === "string") {
                    this.values = o.values.toArray()
                }
            } else {
                for(i = 1; i <= o.stars; i++) {
                    this.values.push(i);
                }
            }

            this.originValue = o.value;
            this.value = o.value > 0 ? Math[o.roundFunc](o.value) : 0;

            if (o.starColor !== null) {
                if (!Utils.isColor(o.starColor)) {
                    o.starColor = Colors.color(o.starColor);
                }
            }

            if (o.staredColor !== null) {
                if (!Utils.isColor(o.staredColor)) {
                    o.staredColor = Colors.color(o.staredColor);
                }
            }

            this._createRating();
            this._createEvents();

            this._fireEvent("rating-create", {
                element: element
            });
        },

        _createRating: function(){
            var element = this.element, o = this.options;

            var id = Utils.elementId("rating");
            var rating = $("<div>").addClass("rating " + String(element[0].className).replace("d-block", "d-flex")).addClass(o.clsRating);
            var i, stars, result, li;
            var sheet = Metro.sheet;
            var value = o.static ? Math.floor(this.originValue) : this.value;

            element.val(this.value);

            rating.attr("id", id);

            rating.insertBefore(element);
            element.appendTo(rating);

            stars = $("<ul>").addClass("stars").addClass(o.clsStars).appendTo(rating);

            for(i = 1; i <= o.stars; i++) {
                li = $("<li>").data("value", this.values[i-1]).appendTo(stars);
                if (i <= value) {
                    li.addClass("on");
                }
            }

            result = $("<span>").addClass("result").addClass(o.clsResult).appendTo(rating);

            result.html(o.message);

            if (o.starColor !== null) {
                Utils.addCssRule(sheet, "#" + id + " .stars:hover li", "color: " + o.starColor + ";");
            }
            if (o.staredColor !== null) {
                Utils.addCssRule(sheet, "#"+id+" .stars li.on", "color: "+o.staredColor+";");
                Utils.addCssRule(sheet, "#"+id+" .stars li.half::after", "color: "+o.staredColor+";");
            }

            if (o.title !== null) {
                var title = $("<span>").addClass("title").addClass(o.clsTitle).html(o.title);
                rating.prepend(title);
            }

            if (o.static === true) {
                rating.addClass("static");
                if (o.half === true){
                    var dec = Math.round((this.originValue % 1) * 10);
                    if (dec > 0 && dec <= 9) {
                        rating.find('.stars li.on').last().next("li").addClass("half half-" + ( dec * 10));
                    }
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    rating.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(rating);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.rating = rating;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var rating = this.rating;

            rating.on(Metro.events.click, ".stars li", function(){

                if (o.static === true) {
                    return ;
                }

                var star = $(this);
                var value = star.data("value");
                star.addClass("scale");
                setTimeout(function(){
                    star.removeClass("scale");
                }, 300);
                element.val(value).trigger("change");
                star.addClass("on");
                star.prevAll().addClass("on");
                star.nextAll().removeClass("on");

                that._fireEvent("star-click", {
                    value: value,
                    star: star[0]
                });

            });
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var rating = this.rating;

            if (v === undefined) {
                return this.value;
            }

            this.value = v > 0 ? Math[o.roundFunc](v) : 0;
            element.val(this.value).trigger("change");

            var stars = rating.find(".stars li").removeClass("on");
            $.each(stars, function(){
                var star = $(this);
                if (star.data("value") <= that.value) {
                    star.addClass("on");
                }
            });

            return this;
        },

        msg: function(m){
            var rating = this.rating;
            if (m ===  undefined) {
                return ;
            }
            rating.find(".result").html(m);
            return this;
        },

        static: function (mode) {
            var o = this.options;
            var rating = this.rating;

            o.static = mode;

            if (mode === true) {
                rating.addClass("static");
            } else {
                rating.removeClass("static");
            }
        },

        changeAttributeValue: function(a){
            var element = this.element;
            var value = a === "value" ? element.val() : element.attr("data-value");
            this.val(value);
        },

        changeAttributeMessage: function(){
            var element = this.element;
            var message = element.attr("data-message");
            this.msg(message);
        },

        changeAttributeStatic: function(){
            var element = this.element;
            var isStatic = JSON.parse(element.attr("data-static")) === true;

            this.static(isStatic);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "value":
                case "data-value": this.changeAttributeValue(attributeName); break;
                case "disabled": this.toggleState(); break;
                case "data-message": this.changeAttributeMessage(); break;
                case "data-static": this.changeAttributeStatic(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var rating = this.rating;

            rating.off(Metro.events.click, ".stars li");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizableDefaultConfig = {
        resizableDeferred: 0,
        canResize: true,
        resizeElement: ".resize-element",
        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        preserveRatio: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onResizableCreate: Metro.noop
    };

    Metro.resizableSetup = function (options) {
        ResizableDefaultConfig = $.extend({}, ResizableDefaultConfig, options);
    };

    if (typeof window["metroResizableSetup"] !== undefined) {
        Metro.resizableSetup(window["metroResizableSetup"]);
    }

    Metro.Component('resizable', {
        init: function( options, elem ) {
            this._super(elem, options, ResizableDefaultConfig, {
                resizer: null,
                id: Utils.elementId("resizable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("resizable-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.data("canResize", true);
            element.addClass("resizable-element");

            if (Utils.isValue(o.resizeElement) && element.find(o.resizeElement).length > 0) {
                this.resizer = element.find(o.resizeElement);
            } else {
                this.resizer = $("<span>").addClass("resize-element").appendTo(element);
            }

            element.data("canResize", o.canResize);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            this.resizer.on(Metro.events.start, function(e){

                if (element.data('canResize') === false) {
                    return ;
                }

                var startXY = Utils.pageXY(e);
                var startWidth = parseInt(element.outerWidth());
                var startHeight = parseInt(element.outerHeight());
                var size = {width: startWidth, height: startHeight};

                element.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    size: size
                });

                $(document).on(Metro.events.move, function(e){
                    var moveXY = Utils.pageXY(e);
                    var size = {
                        width: startWidth + moveXY.x - startXY.x,
                        height: startHeight + moveXY.y - startXY.y
                    };

                    if (o.maxWidth > 0 && size.width > o.maxWidth) {return true;}
                    if (o.minWidth > 0 && size.width < o.minWidth) {return true;}

                    if (o.maxHeight > 0 && size.height > o.maxHeight) {return true;}
                    if (o.minHeight > 0 && size.height < o.minHeight) {return true;}

                    element.css(size);

                    that._fireEvent("resize", {
                        size: size
                    })

                }, {ns: that.id});

                $(document).on(Metro.events.stop, function(){
                    element.removeClass("stop-pointer");

                    $(document).off(Metro.events.move, {ns: that.id});
                    $(document).off(Metro.events.stop, {ns: that.id});

                    var size = {
                        width: parseInt(element.outerWidth()),
                        height: parseInt(element.outerHeight())
                    };

                    that._fireEvent("resize-stop", {
                        size: size
                    });

                }, {ns: that.id});

                e.preventDefault();
                e.stopPropagation();
            });

        },

        off: function(){
            this.element.data("canResize", false);
        },

        on: function(){
            this.element.data("canResize", true);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            var canResize = function(){
                o.canResize = JSON.parse(element.attr('data-can-resize')) === true;
            };

            switch (attributeName) {
                case "data-can-resize": canResize(); break;
            }
        },

        destroy: function(){
            this.resizer.off(Metro.events.start);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizerDefaultConfig = {
        resizerDeferred: 0,
        onMediaPoint: Metro.noop,
        onMediaPointEnter: Metro.noop,
        onMediaPointLeave: Metro.noop,
        onWindowResize: Metro.noop,
        onElementResize: Metro.noop,
        onResizerCreate: Metro.noop
    };

    Metro.resizerSetup = function (options) {
        ResizerDefaultConfig = $.extend({}, ResizerDefaultConfig, options);
    };

    if (typeof window["metroResizerSetup"] !== undefined) {
        Metro.resizerSetup(window["metroResizerSetup"]);
    }

    Metro.Component('resizer', {
        init: function( options, elem ) {
            this._super(elem, options, ResizerDefaultConfig, {
                size: {width: 0, height: 0},
                media: window.METRO_MEDIA,
                id: Utils.elementId("resizer")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this.size = {
                width: element.width(),
                height: element.height()
            };

            this._createStructure();
            this._createEvents();

            this._fireEvent("resizer-create", {
                element: element
            });
        },

        _createStructure: function(){
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var win = $.window();

            win.on("resize", function(){
                var windowWidth = win.width(), windowHeight = win.height();
                var elementWidth = element.width(), elementHeight = element.height();
                var oldSize = that.size;
                var point;

                that._fireEvent("window-resize", {
                    width: windowWidth,
                    height: windowHeight,
                    media: window.METRO_MEDIA
                });

                if (that.size.width !== elementWidth || that.size.height !== elementHeight) {
                    that.size = {
                        width: elementWidth,
                        height: elementHeight
                    };

                    that._fireEvent("element-resize", {
                        width: elementWidth,
                        height: elementHeight,
                        oldSize: oldSize,
                        media: window.METRO_MEDIA
                    });

                }

                if (that.media.length !== window.METRO_MEDIA.length) {
                    if (that.media.length > window.METRO_MEDIA.length) {
                        point = that.media.filter(function(x){
                            return !window.METRO_MEDIA.contains(x);
                        });

                        that._fireEvent("media-point-leave", {
                            point: point,
                            media: window.METRO_MEDIA
                        });

                    } else {
                        point = window.METRO_MEDIA.filter(function(x){
                            return !that.media.contains(x);
                        });

                        that._fireEvent("media-point-enter", {
                            point: point,
                            media: window.METRO_MEDIA
                        });
                    }

                    that.media = window.METRO_MEDIA;

                    that._fireEvent("media-point", {
                        point: point,
                        media: window.METRO_MEDIA
                    });
                }
            }, {ns: this.id});
        },

        changeAttribute: function(){
        },

        destroy: function(){
            $(window).off("resize", {ns: this.id});
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RibbonMenuDefaultConfig = {
        ribbonmenuDeferred: 0,
        onStatic: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTab: Metro.noop,
        onRibbonMenuCreate: Metro.noop
    };

    Metro.ribbonMenuSetup = function (options) {
        RibbonMenuDefaultConfig = $.extend({}, RibbonMenuDefaultConfig, options);
    };

    if (typeof window["metroRibbonMenuSetup"] !== undefined) {
        Metro.ribbonMenuSetup(window["metroRibbonMenuSetup"]);
    }

    Metro.Component('ribbon-menu', {
        init: function( options, elem ) {
            this._super(elem, options, RibbonMenuDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("ribbon-menu-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element;

            element.addClass("ribbon-menu");

            var tabs = element.find(".tabs-holder li:not(.static)");
            var active_tab = element.find(".tabs-holder li.active");
            if (active_tab.length > 0) {
                this.open($(active_tab[0]));
            } else {
                if (tabs.length > 0) {
                    this.open($(tabs[0]));
                }
            }

            var fluentGroups = element.find(".ribbon-toggle-group");
            $.each(fluentGroups, function(){
                var g = $(this);
                g.buttongroup({
                    clsActive: "active"
                });

                var gw = 0;
                var btns = g.find(".ribbon-icon-button");
                $.each(btns, function(){
                    var b = $(this);
                    var w = b.outerWidth(true);
                    if (w > gw) gw = w;
                });

                g.css("width", gw * Math.ceil(btns.length / 3) + 4);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".tabs-holder li a", function(e){
                var link = $(this);
                var tab = $(this).parent("li");

                if (tab.hasClass("static")) {
                    if (o.onStatic === Metro.noop && link.attr("href") !== undefined) {
                        document.location.href = link.attr("href");
                    } else {
                        that._fireEvent("static", {
                            tab: tab[0]
                        });
                    }
                } else {
                    if (Utils.exec(o.onBeforeTab, [tab[0]], element[0]) === true) {
                        that.open(tab[0]);
                    }
                }
                e.preventDefault();
            })
        },

        open: function(tab){
            var element = this.element;
            var $tab = $(tab);
            var tabs = element.find(".tabs-holder li");
            var sections = element.find(".content-holder .section");
            var target = $tab.children("a").attr("href");
            var target_section = target !== "#" ? element.find(target) : null;

            tabs.removeClass("active");
            $tab.addClass("active");

            sections.removeClass("active");
            if (target_section) target_section.addClass("active");

            this._fireEvent("tab", {
                tab: $tab[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".tabs-holder li a");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RippleDefaultConfig = {
        rippleDeferred: 0,
        rippleColor: "#fff",
        rippleAlpha: .4,
        rippleTarget: "default",
        onRippleCreate: Metro.noop
    };

    Metro.rippleSetup = function (options) {
        RippleDefaultConfig = $.extend({}, RippleDefaultConfig, options);
    };

    if (typeof window["metroRippleSetup"] !== undefined) {
        Metro.rippleSetup(window["metroRippleSetup"]);
    }

    var getRipple = function(target, color, alpha, event){
        var el = $(target);
        var rect = Utils.rect(el[0]);
        var x, y;

        if (el.length === 0) {
            return ;
        }

        if (!Utils.isValue(color)) {
            color = "#fff";
        }

        if (!Utils.isValue(alpha)) {
            alpha = .4;
        }

        if (el.css('position') === 'static') {
            el.css('position', 'relative');
        }

        el.css({
            overflow: 'hidden'
        });

        $(".ripple").remove();

        var size = Math.max(el.outerWidth(), el.outerHeight());

        // Add the element
        var ripple = $("<span class='ripple'></span>").css({
            width: size,
            height: size
        });

        el.prepend(ripple);

        if (event) {
            // Get touch point x, y
            x = event.pageX - el.offset().left - ripple.width()/2;
            y = event.pageY - el.offset().top - ripple.height()/2;
        } else {
            // Get the center of the element
            x = rect.width / 2 - ripple.width()/2;
            y = rect.height / 2 - ripple.height()/2;
        }

        ripple.css({
            background: Utils.hex2rgba(color, alpha),
            width: size,
            height: size,
            top: y + 'px',
            left: x + 'px'
        }).addClass("rippleEffect");

        setTimeout(function(){
            ripple.remove();
        }, 400);
    };

    Metro.Component('ripple', {
        init: function( options, elem ) {
            this._super(elem, options, RippleDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;

            element.on(Metro.events.click, target, function(e){
                getRipple(this, o.rippleColor, o.rippleAlpha, e);
            });

            this._fireEvent("riopple-create", {
                element: element
            });
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            function changeColor(){
                var color = element.attr("data-ripple-color");
                if (!Utils.isColor(color)) {
                    return;
                }
                o.rippleColor = color;
            }

            function changeAlpha(){
                var alpha = +element.attr("data-ripple-alpha");
                if (isNaN(alpha)) {
                    return;
                }
                o.rippleColor = alpha;
            }

            switch (attributeName) {
                case "data-ripple-color": changeColor(); break;
                case "data-ripple-alpha": changeAlpha(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;
            element.off(Metro.events.click, target);
        }
    });

    Metro.ripple = getRipple;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SelectDefaultConfig = {
        label: "",
        size: "normal",
        selectDeferred: 0,
        clearButton: false,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        usePlaceholder: false,
        placeholder: "",
        addEmptyValue: false,
        emptyValue: "",
        duration: 0,
        prepend: "",
        append: "",
        filterPlaceholder: "Search...",
        filter: true,
        copyInlineStyles: false,
        dropHeight: 200,
        checkDropUp: true,
        dropUp: false,

        clsSelect: "",
        clsSelectInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsOption: "",
        clsOptionActive: "",
        clsOptionGroup: "",
        clsDropList: "",
        clsDropContainer: "",
        clsSelectedItem: "",
        clsSelectedItemRemover: "",
        clsLabel: "",

        onChange: Metro.noop,
        onUp: Metro.noop,
        onDrop: Metro.noop,
        onItemSelect: Metro.noop,
        onItemDeselect: Metro.noop,
        onSelectCreate: Metro.noop
    };

    Metro.selectSetup = function (options) {
        SelectDefaultConfig = $.extend({}, SelectDefaultConfig, options);
    };

    if (typeof window["metroSelectSetup"] !== undefined) {
        Metro.selectSetup(window["metroSelectSetup"]);
    }

    Metro.Component('select', {
        init: function( options, elem ) {
            this._super(elem, options, SelectDefaultConfig, {
                list: null,
                placeholder: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createSelect();
            this._createEvents();

            this._fireEvent("select-create", {
                element: element
            });
        },

        _setPlaceholder: function(){
            var element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            if (o.usePlaceholder === true && (!Utils.isValue(element.val()) || element.val() == o.emptyValue)) {
                input.html(this.placeholder);
            }
        },

        _addTag: function(val, data){
            var element = this.element, o = this.options;
            var tag, tagSize, container = element.closest(".select");
            tag = $("<div>").addClass("tag").addClass(o.clsSelectedItem).html("<span class='title'>"+val+"</span>").data("option", data);
            $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            tag.addClass(tagSize);

            return tag;
        },

        _addOption: function(item, parent, input, multiple){
            var option = $(item);
            var l, a;
            var element = this.element, o = this.options;
            var html = Utils.isValue(option.attr('data-template')) ? option.attr('data-template').replace("$1", item.text):item.text;

            l = $("<li>").addClass(o.clsOption).data("option", item).attr("data-text", item.text).attr('data-value', item.value ? item.value : "");
            a = $("<a>").html(html);

            l.addClass(item.className);

            if (option.is(":disabled")) {
                l.addClass("disabled");
            }

            if (option.is(":selected")) {
                if (multiple) {
                    l.addClass("d-none");
                    input.append(this._addTag(html, l));
                } else {
                    element.val(item.value);
                    input.html(html);
                    element.fire("change", {
                        val: item.value
                    });
                    l.addClass("active");
                }
            }

            l.append(a).appendTo(parent);
        },

        _addOptionGroup: function(item, parent, input, multiple){
            var that = this;
            var group = $(item);

            $("<li>").html(item.label).addClass("group-title").appendTo(parent);

            $.each(group.children(), function(){
                that._addOption(this, parent, input, multiple);
            })
        },

        _createOptions: function(){
            var that = this, element = this.element, o = this.options, select = element.parent();
            var list = select.find("ul").empty();
            var selected = element.find("option[selected]").length > 0;
            var multiple = element[0].multiple;
            var input = element.siblings(".select-input");

            element.siblings(".select-input").empty();

            if (o.addEmptyValue === true) {
                element.prepend($("<option "+(!selected ? 'selected' : '')+" value='"+o.emptyValue+"' class='d-none'></option>"));
            }

            $.each(element.children(), function(){
                if (this.tagName === "OPTION") {
                    that._addOption(this, list, input, multiple);
                } else if (this.tagName === "OPTGROUP") {
                    that._addOptionGroup(this, list, input, multiple);
                }
            });
        },

        _createSelect: function(){
            var that = this, element = this.element, o = this.options;

            var container = $("<label>").addClass("select " + element[0].className).addClass(o.clsSelect);
            var multiple = element[0].multiple;
            var select_id = Utils.elementId("select");
            var buttons = $("<div>").addClass("button-group");
            var input, drop_container, drop_container_input, list, filter_input, dropdown_toggle;
            var checkboxID = Utils.elementId("select-focus-trigger");
            var checkbox = $("<input type='checkbox'>").addClass("select-focus-trigger").attr("id", checkboxID);

            this.placeholder = $("<span>").addClass("placeholder").html(o.placeholder);

            container.attr("id", select_id).attr("for", checkboxID);
            container.addClass("input-" + o.size);

            dropdown_toggle = $("<span>").addClass("dropdown-toggle");
            dropdown_toggle.appendTo(container);

            if (multiple) {
                container.addClass("multiple");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            checkbox.appendTo(container);

            input = $("<div>").addClass("select-input").addClass(o.clsSelectInput).attr("name", "__" + select_id + "__");
            drop_container = $("<div>").addClass("drop-container").addClass(o.clsDropContainer);
            drop_container_input = $("<div>").appendTo(drop_container);
            list = $("<ul>").addClass("option-list").addClass(o.clsDropList).css({
                "max-height": o.dropHeight
            });
            filter_input = $("<input type='text' data-role='input'>").attr("placeholder", o.filterPlaceholder).appendTo(drop_container_input);

            container.append(input);
            container.append(drop_container);

            drop_container.append(drop_container_input);

            if (o.filter !== true) {
                drop_container_input.hide();
            }

            drop_container.append(list);

            this._createOptions();

            this._setPlaceholder();

            Metro.makePlugin(drop_container, "dropdown", {
                dropFilter: ".select",
                duration: o.duration,
                toggleElement: [container],
                checkDropUp: o.checkDropUp,
                dropUp: o.dropUp,
                onDrop: function(){
                    var dropped, target;
                    dropdown_toggle.addClass("active-toggle");
                    dropped = $(".select .drop-container");
                    $.each(dropped, function(){
                        var drop = $(this);
                        if (drop.is(drop_container)) {
                            return ;
                        }
                        var dataDrop = Metro.getPlugin(drop, 'dropdown');
                        if (dataDrop && dataDrop.close) {
                            dataDrop.close();
                        }
                    });

                    filter_input.val("").trigger(Metro.events.keyup);//.focus();

                    target = list.find("li.active").length > 0 ? $(list.find("li.active")[0]) : undefined;
                    if (target !== undefined) {
                        list[0].scrollTop = target.position().top - ( (list.height() - target.height() )/ 2);
                    }

                    that._fireEvent("drop", {
                        list: list[0]
                    });
                },
                onUp: function(){
                    dropdown_toggle.removeClass("active-toggle");

                    that._fireEvent("up", {
                        list: list[0]
                    });
                }
            });

            this.list = list;

            if (o.clearButton === true && !element[0].readOnly) {
                var clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            } else {
                buttons.addClass("d-none");
            }

            if (o.prepend !== "" && !multiple) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "" && !multiple) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");
            var checkbox = container.find(".select-focus-trigger");

            checkbox.on("focus", function(){
                container.addClass("focused");
            });

            checkbox.on("blur", function(){
                container.removeClass("focused");
            });

            clearButton.on(Metro.events.click, function(e){
                element.val(o.emptyValue);
                if (element[0].multiple) {
                    list.find("li").removeClass("d-none");
                    input.clear();
                }
                that._setPlaceholder();
                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.change, function(){
                that._setPlaceholder();
            });

            container.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            input.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            list.on(Metro.events.click, "li", function(e){
                if ($(this).hasClass("group-title")) {
                    e.preventDefault();
                    e.stopPropagation();
                    return ;
                }
                var leaf = $(this);
                var val = leaf.data('value');
                var html = leaf.children('a').html();
                var selected;
                var option = leaf.data("option");
                var options = element.find("option");

                if (element[0].multiple) {
                    leaf.addClass("d-none");
                    input.append(that._addTag(html, leaf));
                } else {
                    list.find("li.active").removeClass("active").removeClass(o.clsOptionActive);
                    leaf.addClass("active").addClass(o.clsOptionActive);
                    input.html(html);
                    Metro.getPlugin(drop_container, "dropdown").close();
                }

                $.each(options, function(){
                    if (this === option) {
                        this.selected = true;
                    }
                });

                that._fireEvent("item-select", {
                    val: val,
                    option: option,
                    leaf: leaf[0]
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });
            });

            input.on("click", ".tag .remover", function(e){
                var item = $(this).closest(".tag");
                var leaf = item.data("option");
                var option = leaf.data('option');
                var selected;

                leaf.removeClass("d-none");
                $.each(element.find("option"), function(){
                    if (this === option) {
                        this.selected = false;
                    }
                });
                item.remove();

                that._fireEvent("item-deselect", {
                    option: option
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });

                e.preventDefault();
                e.stopPropagation();
            });

            filter_input.on(Metro.events.keyup, function(){
                var filter = this.value.toUpperCase();
                var li = list.find("li");
                var i, a;
                for (i = 0; i < li.length; i++) {
                    if ($(li[i]).hasClass("group-title")) continue;
                    a = li[i].getElementsByTagName("a")[0];
                    if (a.innerHTML.toUpperCase().indexOf(filter) > -1) {
                        li[i].style.display = "";
                    } else {
                        li[i].style.display = "none";
                    }
                }
            });

            filter_input.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });

            drop_container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.closest(".select").addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.closest(".select").removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        reset: function(to_default){
            var element = this.element;
            var options = element.find("option");
            var select = element.closest('.select');
            var selected;

            $.each(options, function(){
                this.selected = !Utils.isNull(to_default) ? this.defaultSelected : false;
            });

            this.list.find("li").remove();
            select.find(".select-input").html('');

            this._createOptions();

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        getSelected: function(){
            var element = this.element;
            var result = [];

            element.find("option").each(function(){
                if (this.selected) result.push(this.value);
            });

            return result;
        },

        val: function(val){
            var element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            var options = element.find("option");
            var list_items = this.list.find("li");
            var result = [];
            var multiple = element.attr("multiple") !== undefined;
            var option;
            var i, html, list_item, option_value, tag, selected;

            if (Utils.isNull(val)) {
                $.each(options, function(){
                    if (this.selected) result.push(this.value);
                });
                return multiple ? result : result[0];
            }

            $.each(options, function(){
                this.selected = false;
            });
            list_items.removeClass("active");
            input.html('');

            if (Array.isArray(val) === false) {
                val  = [val];
            }

            $.each(val, function(){
                for (i = 0; i < options.length; i++) {
                    option = options[i];
                    html = Utils.isValue(option.getAttribute('data-template')) ? option.getAttribute('data-template').replace("$1", option.text) : option.text;
                    if (""+option.value === ""+this) {
                        option.selected = true;
                        break;
                    }
                }

                for(i = 0; i < list_items.length; i++) {
                    list_item = $(list_items[i]);
                    option_value = list_item.attr("data-value");
                    if (""+option_value === ""+this) {
                        if (multiple) {
                            list_item.addClass("d-none");
                            tag = $("<div>").addClass("tag").addClass(o.clsSelectedItem).html("<span class='title'>"+html+"</span>").appendTo(input);
                            tag.data("option", list_item);
                            $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);
                        } else {
                            list_item.addClass("active");
                            input.html(html);
                        }
                        break;
                    }
                }
            });

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        data: function(op, selected, delimiter){
            var element = this.element;
            var option_group, _selected;
            var _delimiter = delimiter || ",";


            if (typeof selected === "string") {
                _selected = selected.toArray(_delimiter).map(function(v){
                    return +v;
                });
            } else if (Array.isArray(selected)) {
                _selected = selected.slice().map(function(v){
                    return +v;
                });
            } else {
                _selected = [];
            }

            element.empty();

            if (typeof op === 'string') {
                element.html(op);
            } else if (Utils.isObject(op)) {
                $.each(op, function(key, val){
                    if (Utils.isObject(val)) {
                        option_group = $("<optgroup label=''>").attr("label", key).appendTo(element);
                        $.each(val, function(key2, val2){
                            var op = $("<option>").attr("value", key2).text(val2).appendTo(option_group);
                            if (_selected.indexOf(+key2) > -1) {
                                op.prop("selected", true);
                            }
                        });
                    } else {
                        var op = $("<option>").attr("value", key).text(val).appendTo(element);
                        if (_selected.indexOf(+key) > -1) {
                            op.prop("selected", true);
                        }
                    }
                });
            }

            this._createOptions();
        },

        changeAttribute: function(attributeName){
            if (attributeName === 'disabled') {
                this.toggleState();
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");

            container.off(Metro.events.click);
            container.off(Metro.events.click, ".input-clear-button");
            input.off(Metro.events.click);
            filter_input.off(Metro.events.blur);
            filter_input.off(Metro.events.focus);
            list.off(Metro.events.click, "li");
            filter_input.off(Metro.events.keyup);
            drop_container.off(Metro.events.click);
            clearButton.off(Metro.events.click);

            drop_container.data("dropdown").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".select").removeClass("focused");
    }, {ns: "blur-select-elements"});
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SidebarDefaultConfig = {
        menuScrollbar: false,
        sidebarDeferred: 0,
        shadow: true,
        position: "left",
        size: 290,
        shift: null,
        staticShift: null,
        toggle: null,
        duration: METRO_ANIMATION_DURATION,
        static: null,
        menuItemClick: true,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onToggle: Metro.noop,
        onStaticSet: Metro.noop,
        onStaticLoss: Metro.noop,
        onSidebarCreate: Metro.noop
    };

    Metro.sidebarSetup = function (options) {
        SidebarDefaultConfig = $.extend({}, SidebarDefaultConfig, options);
    };

    if (typeof window["metroSidebarSetup"] !== undefined) {
        Metro.sidebarSetup(window["metroSidebarSetup"]);
    }

    Metro.Component('sidebar', {
        init: function( options, elem ) {
            this._super(elem, options, SidebarDefaultConfig, {
                toggle_element: null,
                id: Utils.elementId('sidebar')
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();
            $(window).resize();
            this._checkStatic();

            this._fireEvent("sidebar-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var header = element.find(".sidebar-header");
            var sheet = Metro.sheet;
            var menu = element.find(".sidebar-menu");

            element.addClass("sidebar").addClass("on-"+o.position);

            if (o.menuScrollbar === false) {
                menu.addClass("hide-scroll");
            }

            if (o.size !== 290) {
                Utils.addCssRule(sheet, ".sidebar", "width: " + o.size + "px;");

                if (o.position === "left") {
                    Utils.addCssRule(sheet, ".sidebar.on-left", "left: " + -o.size + "px;");
                } else {
                    Utils.addCssRule(sheet, ".sidebar.on-right", "right: " + -o.size + "px;");
                }
            }

            if (o.shadow === true) {
                element.addClass("sidebar-shadow");
            }

            if (o.toggle !== null && $(o.toggle).length > 0) {
                this.toggle_element = $(o.toggle);
            }

            if (header.length > 0) {
                if (header.data("image") !== undefined) {
                    header.css({
                        backgroundImage: "url("+header.data("image")+")"
                    });
                }
            }

            if (o.static !== null) {
                if (o.staticShift !== null) {
                    if (o.position === 'left') {
                        Utils.addCssRule(sheet, "@media screen and " + Metro.media_queries[o.static.toUpperCase()], o.staticShift + "{margin-left: " + o.size + "px; width: calc(100% - " + o.size + "px);}");
                    } else {
                        Utils.addCssRule(sheet, "@media screen and " + Metro.media_queries[o.static.toUpperCase()], o.staticShift + "{margin-right: " + o.size + "px; width: calc(100% - " + o.size + "px);}");
                    }
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var toggle = this.toggle_element;

            if (toggle !== null) {
                toggle.on(Metro.events.click, function(e){
                    that.toggle();
                    e.stopPropagation();
                });
            } else if (o.toggle) {
                $.document().on("click", o.toggle, function (e) {
                    that.toggle();
                    e.stopPropagation();
                })
            }

            if (o.static !== null && ["fs", "sm", "md", "lg", "xl", "xxl"].indexOf(o.static) > -1) {
                $(window).on(Metro.events.resize,function(){
                    that._checkStatic();
                }, {ns: this.id});
            }

            if (o.menuItemClick === true) {
                element.on(Metro.events.click, ".sidebar-menu li > a", function(e){
                    that.close();
                    e.stopPropagation();
                });
            }

            element.on(Metro.events.click, ".sidebar-menu .js-sidebar-close", function(e){
                that.close();
                e.stopPropagation();
            });

            element.on(Metro.events.click, function(e){
                e.stopPropagation();
            });
        },

        _checkStatic: function(){
            var element = this.element, o = this.options;
            if (Utils.mediaExist(o.static) && !element.hasClass("static")) {
                element.addClass("static");
                element.data("opened", false).removeClass('open');
                if (o.shift !== null) {
                    $.each(o.shift.split(","), function(){
                        $(this)
                            .animate({
                                draw: {
                                    left: 0
                                },
                                dur: o.duration
                            })
                    });
                }

                this._fireEvent("static-set");
            }
            if (!Utils.mediaExist(o.static)) {
                element.removeClass("static");
                this._fireEvent("static-loss");
            }
        },

        isOpen: function(){
            return this.element.data("opened") === true;
        },

        open: function(){
            var element = this.element, o = this.options;

            if (element.hasClass("static")) {
                return ;
            }

            element.data("opened", true).addClass('open');

            if (o.shift !== null) {
                $(o.shift)
                    .animate({
                        draw: {
                            left: element.outerWidth()
                        },
                        dur: o.duration
                    });
            }

            this._fireEvent("open");
        },

        close: function(){
            var element = this.element, o = this.options;

            if (element.hasClass("static")) {
                return ;
            }

            element.data("opened", false).removeClass('open');

            if (o.shift !== null) {
                $(o.shift)
                    .animate({
                        draw: {
                            left: 0
                        },
                        dur: o.duration
                    });
            }

            this._fireEvent("close");
        },

        toggle: function(){
            if (this.isOpen()) {
                this.close();
            } else {
                this.open();
            }

            this._fireEvent("toggle");
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var toggle = this.toggle_element;

            if (toggle !== null) {
                toggle.off(Metro.events.click);
            }

            if (o.static !== null && ["fs", "sm", "md", "lg", "xl", "xxl"].indexOf(o.static) > -1) {
                $(window).off(Metro.events.resize, {ns: this.id});
            }

            if (o.menuItemClick === true) {
                element.off(Metro.events.click, ".sidebar-menu li > a");
            }

            element.off(Metro.events.click, ".sidebar-menu .js-sidebar-close");

            return element;
        }
    });

    Metro['sidebar'] = {
        isSidebar: function(el){
            return Utils.isMetroObject(el, "sidebar");
        },

        open: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").open();
        },

        close: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").close();
        },

        toggle: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").toggle();
        },

        isOpen: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            return Metro.getPlugin(el, "sidebar").isOpen();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SliderDefaultConfig = {
        sliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        value: 0,
        buffer: 0,
        hint: false,
        hintAlways: false,
        hintPosition: Metro.position.TOP,
        hintMask: "$1",
        vertical: false,
        target: null,
        returnType: "value", // value or percent
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsBuffer: "",
        clsMarker: "",
        clsHint: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onSliderClick: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onChangeBuffer: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onSliderCreate: Metro.noop
    };

    Metro.sliderSetup = function (options) {
        SliderDefaultConfig = $.extend({}, SliderDefaultConfig, options);
    };

    if (typeof window["metroSliderSetup"] !== undefined) {
        Metro.sliderSetup(window["metroSliderSetup"]);
    }

    Metro.Component('slider', {
        init: function( options, elem ) {
            this._super(elem, options, SliderDefaultConfig, {
                slider: null,
                value: 0,
                percent: 0,
                pixel: 0,
                buffer: 0,
                keyInterval: false,
                id: Utils.elementId('slider')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createSlider();
            this._createEvents();
            this.buff(o.buffer);
            this.val(o.value);

            this._fireEvent("slider-create", {
                element: element
            });
        },

        _createSlider: function(){
            var element = this.element, o = this.options;

            var prev = element.prev();
            var parent = element.parent();
            var slider = $("<div>").addClass("slider " + element[0].className).addClass(o.clsSlider);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var buffer = $("<div>").addClass("buffer").addClass(o.clsBuffer);
            var marker = $("<button>").attr("type", "button").addClass("marker").addClass(o.clsMarker);
            var hint = $("<div>").addClass("hint").addClass(o.hintPosition + "-side").addClass(o.clsHint);
            var i;

            if (o.size > 0) {
                if (o.vertical === true) {
                    slider.outerHeight(o.size);
                } else {
                    slider.outerWidth(o.size);
                }
            }

            if (o.vertical === true) {
                slider.addClass("vertical-slider");
            }

            if (prev.length === 0) {
                parent.prepend(slider);
            } else {
                slider.insertAfter(prev);
            }

            if (o.hintAlways === true) {
                hint.css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            element.appendTo(slider);
            backside.appendTo(slider);
            complete.appendTo(slider);
            buffer.appendTo(slider);
            marker.appendTo(slider);
            hint.appendTo(marker);

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");
            var hint = slider.find(".hint");

            marker.on(Metro.events.startAll, function(){
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    that._move(e);

                    that._fireEvent("move", {
                        val: that.value,
                        percent: that.percent
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        val: that.value,
                        percent: that.percent
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.keydown, function(e){

                var key = e.keyCode ? e.keyCode : e.which;

                if ([37,38,39,40].indexOf(key) === -1) {
                    return;
                }

                var step = o.accuracy === 0 ? 1 : o.accuracy;

                if (that.keyInterval) {
                    return ;
                }
                that.keyInterval = setInterval(function(){

                    var val = that.value;

                    if (e.keyCode === 37 || e.keyCode === 40) { // left, down
                        if (val - step < o.min) {
                            val = o.min;
                        } else {
                            val -= step;
                        }
                    }

                    if (e.keyCode === 38 || e.keyCode === 39) { // right, up
                        if (val + step > o.max) {
                            val = o.max;
                        } else {
                            val += step;
                        }
                    }

                    that.value = that._correct(val);
                    that.percent = that._convert(that.value, 'val2prc');
                    that.pixel = that._convert(that.percent, 'prc2pix');

                    that._redraw();
                }, 100);

                e.preventDefault();
            });

            marker.on(Metro.events.keyup, function(){
                clearInterval(that.keyInterval);
                that.keyInterval = false;
            });

            slider.on(Metro.events.click, function(e){
                that._move(e);

                that._fireEvent("slider-click", {
                    val: that.value,
                    percent: that.percent
                });

                that._fireEvent("stop", {
                    val: that.value,
                    percent: that.percent
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.value);
                that.buff(that.buffer);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = (o.vertical === true ? slider.outerHeight() : slider.outerWidth()) - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(Utils.decCount(accuracy));
        },

        _move: function(e){
            var slider = this.slider, o = this.options;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                length = o.vertical === true ? slider.outerHeight() : slider.outerWidth(),
                cPos, cPix, cStart = 0, cStop = length - marker_size;

            cPos = o.vertical === true ? Utils.pageXY(e).y - offset.top : Utils.pageXY(e).x - offset.left;
            cPix = o.vertical === true ? length - cPos - marker_size / 2 : cPos - marker_size / 2;

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this.value = this._correct(this._convert(cPix, 'pix2val'));
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        _hint: function(){
            var o = this.options, slider = this.slider, hint = slider.find(".hint");
            var value = +this.value || 0;
            var percent = +this.percent || 0;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
            }

            hint.text(o.hintMask.replace("$1", value).replace("$2", percent));
        },

        _value: function(){
            var element = this.element, o = this.options;
            var value = o.returnType === 'value' ? this.value : this.percent;
            var percent = this.percent;
            var buffer = this.buffer;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
                buffer = (Utils.isValue(buffer) ? +buffer : 0).toFixed(Utils.decCount(o.accuracy));
            }

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value,
                percent: percent,
                buffer: buffer
            });
        },

        _marker: function(){
            var slider = this.slider, o = this.options;
            var marker = slider.find(".marker"), complete = slider.find(".complete");
            var length = o.vertical === true ? slider.outerHeight() : slider.outerWidth();
            var marker_size = parseInt(Utils.getStyleOne(marker, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                marker.css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (o.vertical === true) {
                if (slider_visible) {
                    marker.css('top', length - this.pixel);
                } else {
                    marker.css('top', (100 - this.percent) + "%");
                    marker.css('margin-top', marker_size / 2);
                }
                complete.css('height', this.percent+"%");
            } else {
                if (slider_visible) {
                    marker.css('left', this.pixel);
                } else {
                    marker.css('left', this.percent + "%");
                    marker.css('margin-left', this.percent === 0 ? 0 : -1 * marker_size / 2);
                }
                complete.css('width', this.percent+"%");
            }
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        _buffer: function(){
            var element = this.element, o = this.options;
            var buffer = this.slider.find(".buffer");

            if (o.vertical === true) {
                buffer.css("height", this.buffer + "%");
            } else {
                buffer.css("width", this.buffer + "%");
            }

            this._fireEvent("change-buffer", {
                val: this.buffer
            });

            this._fireEvent("change", {
                val: element.val(),
                percent: this.percent,
                buffer: this.buffer
            });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined || isNaN(v)) {
                return this.value;
            }

            if (v < o.min) {
                v = o.min;
            }

            if (v > o.max) {
                v = o.max;
            }

            this.value = this._correct(v);
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        buff: function(v){
            var slider = this.slider;
            var buffer = slider.find(".buffer");

            if (v === undefined || isNaN(v)) {
                return this.buffer;
            }

            if (buffer.length === 0) {
                return false;
            }

            v = parseInt(v);

            if (v > 100) {
                v = 100;
            }

            if (v < 0) {
                v = 0;
            }

            this.buffer = v;
            this._buffer();
        },

        changeValue: function(){
            var element = this.element, o = this.options;
            var val = element.attr("data-value");
            if (val < o.min) {
                val = o.min
            }
            if (val > o.max) {
                val = o.max
            }
            this.val(val);
        },

        changeBuffer: function(){
            var element = this.element;
            var val = parseInt(element.attr("data-buffer"));
            if (val < 0) {
                val = 0
            }
            if (val > 100) {
                val = 100
            }
            this.buff(val);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value": this.changeValue(); break;
                case "data-buffer": this.changeBuffer(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SorterDefaultConfig = {
        sorterDeferred: 0,
        thousandSeparator: ",",
        decimalSeparator: ",",
        sortTarget: null,
        sortSource: null,
        sortDir: "asc",
        sortStart: true,
        saveInitial: true,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSorterCreate: Metro.noop
    };

    Metro.sorterSetup = function (options) {
        SorterDefaultConfig = $.extend({}, SorterDefaultConfig, options);
    };

    if (typeof window["metroSorterSetup"] !== undefined) {
        Metro.sorterSetup(window["metroSorterSetup"]);
    }

    Metro.Component('sorter', {
        init: function( options, elem ) {
            this._super(elem, options, SorterDefaultConfig, {
                initial: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();

            this._fireEvent("sorter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            if (o.sortTarget === null) {
                o.sortTarget = element.children()[0].tagName;
            }

            this.initial = element.find(o.sortTarget).get();

            if (o.sortStart === true) {
                this.sort(o.sortDir);
            }
        },

        _getItemContent: function(item){
            var o = this.options;
            var data, inset, i, format;

            if (Utils.isValue(o.sortSource)) {
                data = "";
                inset = item.getElementsByClassName(o.sortSource);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset[0].dataset.format;
            } else {
                data = item.textContent;
                format = item.dataset.format;
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = Utils.isDate(data) ? new Date(data) : ""; break;
                    case "number": data = Number(data); break;
                    case "int": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        sort: function(dir){
            var that = this, element = this.element, o = this.options;
            var items;
            var id = Utils.elementId("temp");
            var prev;

            if (dir !== undefined) {
                o.sortDir = dir;
            }

            items = element.find(o.sortTarget).get();

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            this._fireEvent("sort-start", {
                items: items
            });

            items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2 ) {
                    result = -1;
                }

                if (c1 > c2 ) {
                    result = 1;
                }

                if (result !== 0) {
                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            if (o.sortDir === "desc") {
                items.reverse();
            }

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();

            this._fireEvent("sort-stop", {
                items: items
            });
        },

        reset: function(){
            var element = this.element, o = this.options;
            var items;
            var id = Utils.elementId('sorter');
            var prev;

            items = this.initial;

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function() {
                var dir = element.attr("data-sort-dir").trim();
                if (dir === "") return;
                o.sortDir = dir;
                that.sort();
            };

            var changeSortContent = function(){
                var content = element.attr("data-sort-content").trim();
                if (content === "") return ;
                o.sortContent = content;
                that.sort();
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-content": changeSortContent(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['sorter'] = {
        create: function(el, op){
            return Utils.$()(el).sorter(op);
        },

        isSorter: function(el){
            return Utils.isMetroObject(el, "sorter");
        },

        sort: function(el, dir){
            if (!this.isSorter(el)) {
                return false;
            }
            if (dir === undefined) {
                dir = "asc";
            }
            Metro.getPlugin(el, "sorter").sort(dir);
        },

        reset: function(el){
            if (!this.isSorter(el)) {
                return false;
            }
            Metro.getPlugin(el, "sorter").reset();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SpinnerDefaultConfig = {
        spinnerDeferred: 0,
        label: "",
        step: 1,
        plusIcon: "<span class='default-icon-plus'></span>",
        minusIcon: "<span class='default-icon-minus'></span>",
        buttonsPosition: "default",
        defaultValue: 0,
        minValue: null,
        maxValue: null,
        fixed: 0,
        repeatThreshold: 1000,
        hideCursor: false,
        clsSpinner: "",
        clsSpinnerInput: "",
        clsSpinnerButton: "",
        clsSpinnerButtonPlus: "",
        clsSpinnerButtonMinus: "",
        clsLabel: "",
        onBeforeChange: Metro.noop_true,
        onChange: Metro.noop,
        onPlusClick: Metro.noop,
        onMinusClick: Metro.noop,
        onArrowUp: Metro.noop,
        onArrowDown: Metro.noop,
        onButtonClick: Metro.noop,
        onArrowClick: Metro.noop,
        onSpinnerCreate: Metro.noop
    };

    Metro.spinnerSetup = function (options) {
        SpinnerDefaultConfig = $.extend({}, SpinnerDefaultConfig, options);
    };

    if (typeof window["metroSpinnerSetup"] !== undefined) {
        Metro.spinnerSetup(window["metroSpinnerSetup"]);
    }

    Metro.Component('spinner', {
        init: function( options, elem ) {
            this._super(elem, options, SpinnerDefaultConfig, {
                repeat_timer: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("spinner-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var spinner = $("<div>").addClass("spinner").addClass("buttons-"+o.buttonsPosition).addClass(element[0].className).addClass(o.clsSpinner);
            var button_plus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-plus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonPlus).html(o.plusIcon);
            var button_minus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-minus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonMinus).html(o.minusIcon);
            var init_value = element.val().trim();

            if (!Utils.isValue(init_value)) {
                element.val(0);
            }

            element[0].className = '';

            spinner.insertBefore(element);
            element.appendTo(spinner).addClass(o.clsSpinnerInput);

            element.addClass("original-input");

            button_plus.appendTo(spinner);
            button_minus.appendTo(spinner);

            if (o.hideCursor === true) {
                spinner.addClass("hide-cursor");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(spinner);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (o.disabled === true || element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");

            var spinnerButtonClick = function(plus, threshold){
                var curr = element.val();

                var val = Number(element.val());
                var step = Number(o.step);

                if (plus) {
                    val += step;
                } else {
                    val -= step;
                }

                that._setValue(val.toFixed(o.fixed), true);

                that._fireEvent(plus ? "plus-click" : "minus-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val()
                });

                that._fireEvent(plus ? "arrow-up" : "arrow-down", {
                    curr: curr,
                    val: val,
                    elementVal: element.val()
                });

                that._fireEvent("button-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val(),
                    button: plus ? "plus" : "minus"
                });

                that._fireEvent("arrow-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val(),
                    button: plus ? "plus" : "minus"
                });

                setTimeout(function(){
                    if (that.repeat_timer) {
                        spinnerButtonClick(plus, 100);
                    }
                }, threshold);
            };

            spinner.on(Metro.events.click, function(e){
                $(".focused").removeClass("focused");
                spinner.addClass("focused");
                e.preventDefault();
                e.stopPropagation();
            });

            spinner_buttons.on(Metro.events.start, function(e){
                var plus = $(this).closest(".spinner-button").hasClass("spinner-button-plus");
                e.preventDefault();
                that.repeat_timer = true;
                spinnerButtonClick(plus, o.repeatThreshold);
            });

            spinner_buttons.on(Metro.events.stop, function(){
                that.repeat_timer = false;
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.UP_ARROW || e.keyCode === Metro.keyCode.DOWN_ARROW) {
                    that.repeat_timer = true;
                    spinnerButtonClick(e.keyCode === Metro.keyCode.UP_ARROW, o.repeatThreshold);
                }
            });

            spinner.on(Metro.events.keyup, function(){
                that.repeat_timer = false;
            });
        },

        _setValue: function(val, trigger_change){
            var element = this.element, o = this.options;

            if (Utils.exec(o.onBeforeChange, [val], element[0]) !== true) {
                return ;
            }

            if (Utils.isValue(o.maxValue) && val > Number(o.maxValue)) {
                val =  Number(o.maxValue);
            }

            if (Utils.isValue(o.minValue) && val < Number(o.minValue)) {
                val =  Number(o.minValue);
            }

            element.val(val);

            this._fireEvent("change", {val: val}, false, true);

            if (trigger_change === true) {
                element.fire("change", {
                    val: val
                });
            }
        },

        val: function(val){
            var that = this, element = this.element, o = this.options;
            if (!Utils.isValue(val)) {
                return element.val();
            }

            that._setValue(val.toFixed(o.fixed), true);
        },

        toDefault: function(){
            var o = this.options;
            var val = Utils.isValue(o.defaultValue) ? Number(o.defaultValue) : 0;
            this._setValue(val.toFixed(o.fixed), true);

            this._fireEvent("change", {
                val: val
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            var changeValue = function(){
                var val = element.attr('value').trim();
                if (Utils.isValue(val)) {
                    that._setValue(Number(val), false);
                }
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'value': changeValue(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");

            spinner.off(Metro.events.click);
            spinner_buttons.off(Metro.events.start);
            spinner_buttons.off(Metro.events.stop);
            element.off(Metro.events.keydown);
            spinner.off(Metro.events.keyup);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".spinner").removeClass("focused");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Storage = Metro.storage;
    var SplitterDefaultConfig = {
        splitterDeferred: 0,
        splitMode: "horizontal", // horizontal or vertical
        splitSizes: null,
        gutterSize: 4,
        minSizes: null,
        children: "*",
        gutterClick: "expand", // TODO expand or collapse
        saveState: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResizeSplit: Metro.noop,
        onResizeWindow: Metro.noop,
        onSplitterCreate: Metro.noop
    };

    Metro.splitterSetup = function (options) {
        SplitterDefaultConfig = $.extend({}, SplitterDefaultConfig, options);
    };

    if (typeof window["metroSplitterSetup"] !== undefined) {
        Metro.splitterSetup(window["metroSplitterSetup"]);
    }

    Metro.Component('splitter', {
        init: function( options, elem ) {
            this._super(elem, options, SplitterDefaultConfig, {
                storage: Utils.isValue(Storage) ? Storage : null,
                storageKey: "SPLITTER:",
                id: Utils.elementId("splitter")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("splitter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var children = element.children(o.children).addClass("split-block");
            var i, children_sizes = [];
            var resizeProp = o.splitMode === "horizontal" ? "width" : "height";

            element.addClass("splitter");
            if (o.splitMode.toLowerCase() === "vertical") {
                element.addClass("vertical");
            }

            for (i = 0; i < children.length - 1; i++) {
                $("<div>").addClass("gutter").css(resizeProp, o.gutterSize).insertAfter($(children[i]));
            }

            this._setSize();

            if (Utils.isValue(o.minSizes)) {
                if (String(o.minSizes).contains(",")) {
                    children_sizes = o.minSizes.toArray();
                    for (i = 0; i < children_sizes.length; i++) {
                        $(children[i]).data("min-size", children_sizes[i]);
                        children[i].style.setProperty('min-'+resizeProp, String(children_sizes[i]).contains("%") ? children_sizes[i] : String(children_sizes[i]).replace("px", "")+"px", 'important');
                    }
                } else {
                    $.each(children, function(){
                        this.style.setProperty('min-'+resizeProp, String(o.minSizes).contains("%") ? o.minSizes : String(o.minSizes).replace("px", "")+"px", 'important');
                    });
                }
            }

            if (o.saveState && this.storage !== null) {
                this._getSize();
            }
        },

        _setSize: function(){
            var element = this.element, o = this.options;
            var gutters, children_sizes, i;
            var children = element.children(".split-block");

            gutters = element.children(".gutter");

            if (!Utils.isValue(o.splitSizes)) {
                children.css({
                    flexBasis: "calc("+(100/children.length)+"% - "+(gutters.length * o.gutterSize)+"px)"
                })
            } else {
                children_sizes = o.splitSizes.toArray();
                for(i = 0; i < children_sizes.length; i++) {
                    $(children[i]).css({
                        flexBasis: "calc("+children_sizes[i]+"% - "+(gutters.length * o.gutterSize)+"px)"
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var gutters = element.children(".gutter");

            gutters.on(Metro.events.startAll, function(e){
                var w = o.splitMode === "horizontal" ? element.width() : element.height();
                var gutter = $(this);
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");
                var prev_block_size = 100 * (o.splitMode === "horizontal" ? prev_block.outerWidth(true) : prev_block.outerHeight(true)) / w;
                var next_block_size = 100 * (o.splitMode === "horizontal" ? next_block.outerWidth(true) : next_block.outerHeight(true)) / w;
                var start_pos = Utils.getCursorPosition(element[0], e);

                gutter.addClass("active");

                prev_block.addClass("stop-pointer");
                next_block.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    pos: start_pos,
                    gutter: gutter[0],
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

                $(window).on(Metro.events.moveAll, function(e){
                    var pos = Utils.getCursorPosition(element[0], e);
                    var new_pos;

                    if (o.splitMode === "horizontal") {
                        new_pos = (pos.x * 100 / w) - (start_pos.x * 100 / w);

                    } else {
                        new_pos = (pos.y * 100 / w) - (start_pos.y * 100 / w);
                    }

                    prev_block.css("flex-basis", "calc(" + (prev_block_size + new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");
                    next_block.css("flex-basis", "calc(" + (next_block_size - new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");

                    that._fireEvent("resize-split", {
                        pos: pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id});

                $(window).on(Metro.events.stopAll, function(e){
                    var cur_pos;

                    prev_block.removeClass("stop-pointer");
                    next_block.removeClass("stop-pointer");

                    that._saveSize();

                    gutter.removeClass("active");

                    $(window).off(Metro.events.moveAll,{ns: that.id});
                    $(window).off(Metro.events.stopAll,{ns: that.id});

                    cur_pos = Utils.getCursorPosition(element[0], e);

                    that._fireEvent("resize-stop", {
                        pos: cur_pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id})
            });

            $(window).on(Metro.events.resize, function(){
                var gutter = element.children(".gutter");
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");

                that._fireEvent("resize-window", {
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

            }, {ns: that.id});
        },

        _saveSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                $.each(element.children(".split-block"), function(){
                    var item = $(this);
                    itemsSize.push(item.css("flex-basis"));
                });

                if (storage)
                    storage.setItem(this.storageKey + id, itemsSize);
            }

        },

        _getSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                itemsSize = storage.getItem(this.storageKey + id);

                $.each(element.children(".split-block"), function(i, v){
                    var item = $(v);
                    if (Utils.isValue(itemsSize) && Utils.isValue(itemsSize[i])) item.css("flex-basis", itemsSize[i]);
                });
            }
        },

        size: function(size){
            var that = this, o = this.options;
            if (Utils.isValue(size)) {
                o.splitSizes = size;
                that._setSize();
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            function changeSize(){
                var size = element.attr("data-split-sizes");
                that.size(size);
            }

            if (attributeName === 'data-split-sizes') {
                changeSize();
            }
        },

        destroy: function(){
            var element = this.element;
            var gutters = element.children(".gutter");
            gutters.off(Metro.events.start);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var StepperDefaultConfig = {
        stepperDeferred: 0,
        view: Metro.stepperView.SQUARE, // square, cycle, diamond
        steps: 3,
        step: 1,
        stepClick: false,
        clsStepper: "",
        clsStep: "",
        clsComplete: "",
        clsCurrent: "",
        onStep: Metro.noop,
        onStepClick: Metro.noop,
        onStepperCreate: Metro.noop
    };

    Metro.stepperSetup = function (options) {
        StepperDefaultConfig = $.extend({}, StepperDefaultConfig, options);
    };

    if (typeof window["metroStepperSetup"] !== undefined) {
        Metro.stepperSetup(window["metroStepperSetup"]);
    }

    Metro.Component('stepper', {
        init: function( options, elem ) {
            this._super(elem, options, StepperDefaultConfig, {
                current: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.step <= 0) {
                o.step = 1;
            }

            this._createStepper();
            this._createEvents();

            this._fireEvent("stepper-create", {
                element: element
            });
        },

        _createStepper: function(){
            var element = this.element, o = this.options;
            var i;

            element.addClass("stepper").addClass(o.view).addClass(o.clsStepper);

            for(i = 1; i <= o.steps; i++) {
                $("<span>").addClass("step").addClass(o.clsStep).data("step", i).html("<span>"+i+"</span>").appendTo(element);
            }

            this.current = 1;
            this.toStep(o.step);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".step", function(){
                var step = $(this).data("step");
                if (o.stepClick === true) {
                    that.toStep(step);

                    that._fireEvent("step-click", {
                        step: step
                    });
                }
            });
        },

        next: function(){
            var element = this.element;
            var steps = element.find(".step");

            if (this.current + 1 > steps.length) {
                return ;
            }

            this.current++;

            this.toStep(this.current);
        },

        prev: function(){
            if (this.current - 1 === 0) {
                return ;
            }

            this.current--;

            this.toStep(this.current);
        },

        last: function(){
            var element = this.element;

            this.toStep(element.find(".step").length);
        },

        first: function(){
            this.toStep(1);
        },

        toStep: function(step){
            var element = this.element, o = this.options;
            var target = $(element.find(".step").get(step - 1));
            var prevStep = this.current;

            if (target.length === 0) {
                return ;
            }

            this.current = step;

            element.find(".step")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            this._fireEvent("step", {
                step: this.current,
                prev: prevStep
            });

        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".step");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro) {
    'use strict';
    var Utils = Metro.utils;

    var MetroStorage = function(type){
        return new MetroStorage.init(type);
    };

    MetroStorage.prototype = {
        setKey: function(key){
            this.key = key
        },

        getKey: function(){
            return this.key;
        },

        setItem: function(key, value){
            this.storage.setItem(this.key + ":" + key, JSON.stringify(value));
        },

        getItem: function(key, default_value, reviver){
            var result, value;

            value = this.storage.getItem(this.key + ":" + key);

            try {
                result = JSON.parse(value, reviver);
            } catch (e) {
                result = null;
            }
            return Utils.nvl(result, default_value);
        },

        getItemPart: function(key, sub_key, default_value, reviver){
            var i;
            var val = this.getItem(key, default_value, reviver);

            sub_key = sub_key.split("->");
            for(i = 0; i < sub_key.length; i++) {
                val = val[sub_key[i]];
            }
            return val;
        },

        delItem: function(key){
            this.storage.removeItem(this.key + ":" + key)
        },

        size: function(unit){
            var divider;
            switch (unit) {
                case 'm':
                case 'M': {
                    divider = 1024 * 1024;
                    break;
                }
                case 'k':
                case 'K': {
                    divider = 1024;
                    break;
                }
                default: divider = 1;
            }
            return JSON.stringify(this.storage).length / divider;
        }
    };

    MetroStorage.init = function(type){

        this.key = "";
        this.storage = type ? type : window.localStorage;

        return this;
    };

    MetroStorage.init.prototype = MetroStorage.prototype;

    Metro.storage = MetroStorage(window.localStorage);
    Metro.session = MetroStorage(window.sessionStorage);
}(Metro));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var StreamerDefaultConfig = {
        streamerDeferred: 0,
        wheel: true,
        wheelStep: 20,
        duration: METRO_ANIMATION_DURATION,
        defaultClosedIcon: "",
        defaultOpenIcon: "",
        changeUri: true,
        encodeLink: true,
        closed: false,
        chromeNotice: false,
        startFrom: null,
        slideToStart: true,
        startSlideSleep: 1000,
        source: null,
        data: null,
        eventClick: "select",
        selectGlobal: true,
        streamSelect: false,
        excludeSelectElement: null,
        excludeClickElement: null,
        excludeElement: null,
        excludeSelectClass: "",
        excludeClickClass: "",
        excludeClass: "",

        onDataLoad: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadError: Metro.noop,

        onDrawEvent: Metro.noop,
        onDrawGlobalEvent: Metro.noop,
        onDrawStream: Metro.noop,

        onStreamClick: Metro.noop,
        onStreamSelect: Metro.noop,
        onEventClick: Metro.noop,
        onEventSelect: Metro.noop,
        onEventsScroll: Metro.noop,
        onStreamerCreate: Metro.noop
    };

    Metro.streamerSetup = function (options) {
        StreamerDefaultConfig = $.extend({}, StreamerDefaultConfig, options);
    };

    if (typeof window["metroStreamerSetup"] !== undefined) {
        Metro.streamerSetup(window["metroStreamerSetup"]);
    }

    Metro.Component('streamer', {
        init: function( options, elem ) {
            this._super(elem, options, StreamerDefaultConfig, {
                data: null,
                scroll: 0,
                scrollDir: "left",
                events: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            element.addClass("streamer");

            if (element.attr("id") === undefined) {
                element.attr("id", Utils.elementId("streamer"));
            }

            if (o.source === null && o.data === null) {
                return false;
            }

            $("<div>").addClass("streams").appendTo(element);
            $("<div>").addClass("events-area").appendTo(element);

            if (o.source !== null) {

                this._fireEvent("data-load", {
                    source: o.source
                });

                $.json(o.source).then(function(data){

                    that._fireEvent("data-loaded", {
                        source: o.source,
                        data: data
                    });

                    that.data = data;
                    that.build();
                }, function(xhr){

                    that._fireEvent("data-load-error", {
                        source: o.source,
                        xhr: xhr
                    });

                });
            } else {
                this.data = o.data;
                this.build();
            }

            if (o.chromeNotice === true && Utils.detectChrome() === true && Utils.isTouchDevice() === false) {
                $("<p>").addClass("text-small text-muted").html("*) In Chrome browser please press and hold Shift and turn the mouse wheel.").insertAfter(element);
            }
        },

        build: function(){
            var that = this, element = this.element, o = this.options, data = this.data;
            var streams = element.find(".streams").html("");
            var events_area = element.find(".events-area").html("");
            var fake_timeline;
            var timeline = $("<ul>").addClass("streamer-timeline").html("").appendTo(events_area);
            var streamer_events = $("<div>").addClass("streamer-events").appendTo(events_area);
            var event_group_main = $("<div>").addClass("event-group").appendTo(streamer_events);
            var StreamerIDS = Utils.getURIParameter(null, "StreamerIDS");

            if (StreamerIDS !== null && o.encodeLink === true) {
                StreamerIDS = atob(StreamerIDS);
            }

            var StreamerIDS_i = StreamerIDS ? StreamerIDS.split("|")[0] : null;
            var StreamerIDS_a = StreamerIDS ? StreamerIDS.split("|")[1].split(",") : [];

            if (data.actions !== undefined) {
                var actions = $("<div>").addClass("streamer-actions").appendTo(streams);
                $.each(data.actions, function(){
                    var item = this;
                    var button = $("<button>").addClass("streamer-action").addClass(item.cls).html(item.html);
                    if (item.onclick !== undefined) button.on(Metro.events.click, function(){
                        Utils.exec(item.onclick, [element]);
                    });
                    button.appendTo(actions);
                });
            }

            // Create timeline

            timeline.html("");

            if (data.timeline === undefined) {
                data.timeline = {
                    start: "09:00",
                    stop: "18:00",
                    step: 20
                }
            }

            var start = new Date(), stop = new Date();
            var start_time_array = data.timeline.start ? data.timeline.start.split(":") : [9,0];
            var stop_time_array = data.timeline.stop ? data.timeline.stop.split(":") : [18,0];
            var step = data.timeline.step ? parseInt(data.timeline.step) * 60 : 1200;

            start.setHours(start_time_array[0]);
            start.setMinutes(start_time_array[1]);
            start.setSeconds(0);

            stop.setHours(stop_time_array[0]);
            stop.setMinutes(stop_time_array[1]);
            stop.setSeconds(0);

            var i, t, h, v, m, j, fm, li, fli, fli_w;

            for (i = start.getTime()/1000; i <= stop.getTime()/1000; i += step) {
                t = new Date(i * 1000);
                h = t.getHours();
                m = t.getMinutes();
                v = (h < 10 ? "0"+h : h) + ":" + (m < 10 ? "0"+m : m);

                li = $("<li>").data("time", v).addClass("js-time-point-" + v.replace(":", "-")).html("<em>"+v+"</em>").appendTo(timeline);

                fli_w = li.width() / parseInt(data.timeline.step);
                fake_timeline = $("<ul>").addClass("streamer-fake-timeline").html("").appendTo(li);
                for(j = 0; j < parseInt(data.timeline.step); j++) {
                    fm = m + j;
                    v = (h < 10 ? "0"+h : h) + ":" + (fm < 10 ? "0"+fm : fm);
                    fli = $("<li>").data("time", v).addClass("js-fake-time-point-" + v.replace(":", "-")).html("|").appendTo(fake_timeline);
                    fli.css({
                        width: fli_w
                    })
                }
            }

            // -- End timeline creator

            if (data.streams !== undefined) {
                $.each(data.streams, function(stream_index){
                    var stream_height = 75, rows = 0;
                    var stream_item = this;
                    var stream = $("<div>").addClass("stream").addClass(this.cls).appendTo(streams);
                    stream
                        .addClass(stream_item.cls)
                        .data("one", false)
                        .data("data", stream_item.data);

                    $("<div>").addClass("stream-title").html(stream_item.title).appendTo(stream);
                    $("<div>").addClass("stream-secondary").html(stream_item.secondary).appendTo(stream);
                    $(stream_item.icon).addClass("stream-icon").appendTo(stream);

                    var bg = Utils.computedRgbToHex(Utils.getStyleOne(stream, "background-color"));
                    var fg = Utils.computedRgbToHex(Utils.getStyleOne(stream, "color"));

                    var stream_events = $("<div>").addClass("stream-events")
                        .data("background-color", bg)
                        .data("text-color", fg)
                        .appendTo(event_group_main);

                    if (stream_item.events !== undefined) {
                        $.each(stream_item.events, function(event_index){
                            var event_item = this;
                            var row = event_item.row === undefined ? 1 : parseInt(event_item.row);
                            var _icon;
                            var sid = stream_index+":"+event_index;
                            var custom_html = event_item.custom !== undefined ? event_item.custom : "";
                            var custom_html_open = event_item.custom_open !== undefined ? event_item.custom_open : "";
                            var custom_html_close = event_item.custom_close !== undefined ? event_item.custom_close : "";
                            var event;

                            if (event_item.skip !== undefined && Utils.bool(event_item.skip)) {
                                return ;
                            }

                            event = $("<div>")
                                .data("origin", event_item)
                                .data("sid", sid)
                                .data("data", event_item.data)
                                .data("time", event_item.time)
                                .data("target", event_item.target)
                                .addClass("stream-event")
                                .addClass("size-"+event_item.size+(["half", "one-third"].contains(event_item.size) ? "" : "x"))
                                .addClass(event_item.cls)
                                .appendTo(stream_events);


                            var time_point = timeline.find(".js-fake-time-point-"+this.time.replace(":", "-"));
                            var left = time_point.offset().left - stream_events.offset().left;
                            var top = 75 * (row - 1);

                            if (row > rows) {
                                rows = row;
                            }

                            event.css({
                                position: "absolute",
                                left: left,
                                top: top
                            });


                            if (Utils.isNull(event_item.html)) {

                                var slide = $("<div>").addClass("stream-event-slide").appendTo(event);
                                var slide_logo = $("<div>").addClass("slide-logo").appendTo(slide);
                                var slide_data = $("<div>").addClass("slide-data").appendTo(slide);

                                if (event_item.icon !== undefined) {
                                    if (Utils.isTag(event_item.icon)) {
                                        $(event_item.icon).addClass("icon").appendTo(slide_logo);
                                    } else {
                                        $("<img>").addClass("icon").attr("src", event_item.icon).appendTo(slide_logo);
                                    }
                                }

                                $("<span>").addClass("time").css({
                                    backgroundColor: bg,
                                    color: fg
                                }).html(event_item.time).appendTo(slide_logo);

                                $("<div>").addClass("title").html(event_item.title).appendTo(slide_data);
                                $("<div>").addClass("subtitle").html(event_item.subtitle).appendTo(slide_data);
                                $("<div>").addClass("desc").html(event_item.desc).appendTo(slide_data);

                                if (o.closed === false && (element.attr("id") === StreamerIDS_i && StreamerIDS_a.indexOf(sid) !== -1) || event_item.selected === true || parseInt(event_item.selected) === 1) {
                                    event.addClass("selected");
                                }

                                if (o.closed === true || event_item.closed === true || parseInt(event_item.closed) === 1) {
                                    _icon = event_item.closedIcon !== undefined ? Utils.isTag(event_item.closedIcon) ? event_item.closedIcon : "<span>" + event_item.closedIcon + "</span>" : Utils.isTag(o.defaultClosedIcon) ? o.defaultClosedIcon : "<span>" + o.defaultClosedIcon + "</span>";
                                    $(_icon).addClass("state-icon").addClass(event_item.clsClosedIcon).appendTo(slide);
                                    event
                                        .data("closed", true)
                                        .data("target", event_item.target);
                                    event.append(custom_html_open);
                                } else {
                                    _icon = event_item.openIcon !== undefined ? Utils.isTag(event_item.openIcon) ? event_item.openIcon : "<span>" + event_item.openIcon + "</span>" : Utils.isTag(o.defaultOpenIcon) ? o.defaultOpenIcon : "<span>" + o.defaultOpenIcon + "</span>";
                                    $(_icon).addClass("state-icon").addClass(event_item.clsOpenIcon).appendTo(slide);
                                    event
                                        .data("closed", false);
                                    event.append(custom_html_close);
                                }

                                event.append(custom_html);
                            } else {
                                event.html(event_item.html);
                            }

                            that._fireEvent("draw-event", {
                                event: event[0]
                            });

                        });

                        var last_child = stream_events.find(".stream-event").last();
                        if (last_child.length > 0) stream_events.outerWidth(last_child[0].offsetLeft + last_child.outerWidth());
                    }

                    stream_events.css({
                        height: stream_height * rows
                    });

                    element.find(".stream").eq(stream_events.index()).css({
                        height: stream_height * rows
                    });

                    that._fireEvent("draw-stream", {
                        stream: stream[0]
                    });

                });
            }

            if (data.global !== undefined) {
                var streamer_events_left = streamer_events.offset().left;
                $.each(['before', 'after'], function(){
                    var global_item = this;
                    if (data.global[global_item] !== undefined) {
                        $.each(data.global[global_item], function(){
                            var event_item = this;
                            var group = $("<div>").addClass("event-group").addClass("size-"+event_item.size+(["half", "one-third"].contains(event_item.size) ? "" : "x"));
                            var events = $("<div>").addClass("stream-events global-stream").appendTo(group);
                            var event = $("<div>").addClass("stream-event").appendTo(events);
                            event
                                .addClass("global-event")
                                .addClass(event_item.cls)
                                .data("time", event_item.time)
                                .data("origin", event_item)
                                .data("data", event_item.data);

                            $("<div>").addClass("event-title").html(event_item.title).appendTo(event);
                            $("<div>").addClass("event-subtitle").html(event_item.subtitle).appendTo(event);
                            $("<div>").addClass("event-html").html(event_item.html).appendTo(event);

                            var left, t = timeline.find(".js-fake-time-point-"+this.time.replace(":", "-"));

                            if (t.length > 0) {
                                // left = t[0].offsetLeft - streams.find(".stream").outerWidth();
                                left = t.offset().left - streamer_events_left;
                            }
                            group.css({
                                position: "absolute",
                                left: left,
                                height: "100%"
                            }).appendTo(streamer_events);

                            that._fireEvent("draw-global-event", {
                                event: event[0]
                            });

                        });
                    }
                });
            }

            element.data("stream", -1);
            element.find(".events-area").scrollLeft(0);

            this.events = element.find(".stream-event");

            this._createEvents();

            if (o.startFrom !== null && o.slideToStart === true) {
                setTimeout(function(){
                    that.slideTo(o.startFrom);
                }, o.startSlideSleep);
            }

            this._fireEvent("streamer-create");

            this._fireScroll();
        },

        _fireScroll: function(){
            var that = this, element = this.element;
            var scrollable = element.find(".events-area");
            var oldScroll = this.scroll;

            if (scrollable.length === 0) {
                return undefined;
            }

            this.scrollDir = this.scroll < scrollable[0].scrollLeft ? "left" : "right";
            this.scroll = scrollable[0].scrollLeft;

            this._fireEvent("events-scroll", {
                scrollLeft: scrollable[0].scrollLeft,
                oldScroll: oldScroll,
                scrollDir: that.scrollDir,
                events: $.toArray(this.events)
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            function disableScroll() {
                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                window.onscroll = function() {
                    window.scrollTo(scrollLeft, scrollTop);
                };
            }

            function enableScroll() {
                window.onscroll = function() {};
            }

            element.off(Metro.events.click, ".stream-event").on(Metro.events.click, ".stream-event", function(e){
                var event = $(this);

                if (o.excludeClass !== "" && event.hasClass(o.excludeClass)) {
                    return ;
                }

                if (o.excludeElement !== null && $(e.target).is(o.excludeElement)) {
                    return ;
                }

                if (o.closed === false && event.data("closed") !== true && o.eventClick === 'select') {
                    if (o.excludeSelectClass !== "" && event.hasClass(o.excludeSelectClass)) {
                        /* eslint-disable-next-line */

                    } else {
                        if (o.excludeSelectElement !== null && $(e.target).is(o.excludeSelectElement)) {
                            /* eslint-disable-next-line */

                        } else {
                            if (event.hasClass("global-event")) {
                                if (o.selectGlobal === true) {
                                    event.toggleClass("selected");
                                }
                            } else {
                                event.toggleClass("selected");
                            }
                            if (o.changeUri === true) {
                                that._changeURI();
                            }

                            that._fireEvent("event-select", {
                                event: event[0],
                                selected: event.hasClass("selected")
                            });
                        }
                    }
                } else {
                    if (o.excludeClickClass !== "" && event.hasClass(o.excludeClickClass)) {
                        /* eslint-disable-next-line */

                    } else {

                        if (o.excludeClickElement !== null && $(e.target).is(o.excludeClickElement)) {
                            /* eslint-disable-next-line */

                        } else {

                            that._fireEvent("event-click", {
                                event: event[0]
                            });

                            if (o.closed === true || event.data("closed") === true) {
                                var target = event.data("target");
                                if (target) {
                                    window.location.href = target;
                                }
                            }

                        }
                    }
                }
            });

            element.off(Metro.events.click, ".stream").on(Metro.events.click, ".stream", function(){
                var stream = $(this);
                var index = stream.index();

                if (o.streamSelect === false) {
                    return;
                }

                if (element.data("stream") === index) {
                    element.find(".stream-event").removeClass("disabled");
                    element.data("stream", -1);
                } else {
                    element.data("stream", index);
                    element.find(".stream-event").addClass("disabled");
                    that.enableStream(stream);
                    that._fireEvent("stream-select", {
                        stream: stream
                    });
                }

                that._fireEvent("stream-click", {
                    stream: stream
                });
            });

            if (o.wheel === true) {
                element.find(".events-area")
                    .off(Metro.events.mousewheel)
                    .on(Metro.events.mousewheel, function(e) {

                    if (e.deltaY === undefined) {
                        return ;
                    }

                    var scroll, scrollable = $(this);
                    var dir = e.deltaY > 0 ? -1 : 1;
                    var step = o.wheelStep;


                    scroll = scrollable.scrollLeft() - ( dir * step);
                    scrollable.scrollLeft(scroll);

                });

                element.find(".events-area").off("mouseenter").on("mouseenter", function() {
                    disableScroll();
                });

                element.find(".events-area").off("mouseleave").on("mouseleave", function() {
                    enableScroll();
                });
            }

            element.find(".events-area").last().off("scroll").on("scroll", function(){
                that._fireScroll();
            });

            if (Utils.isTouchDevice() === true) {
                element.off(Metro.events.click, ".stream").on(Metro.events.click, ".stream", function(){
                    var stream = $(this);
                    stream.toggleClass("focused");
                    $.each(element.find(".stream"), function () {
                        if ($(this).is(stream)) return ;
                        $(this).removeClass("focused");
                    })
                })
            }
        },

        _changeURI: function(){
            var link = this.getLink();
            history.pushState({}, document.title, link);
        },

        slideTo: function(time){
            var element = this.element, o = this.options;
            var target;
            if (time === undefined) {
                target = $(element.find(".streamer-timeline li")[0]);
            } else {
                target = $(element.find(".streamer-timeline .js-time-point-" + time.replace(":", "-"))[0]);
            }

            element
                .find(".events-area")
                .animate({
                    draw: {
                        scrollLeft: target[0].offsetLeft - element.find(".streams .stream").outerWidth()
                    },
                    dur: o.duration
                });
        },

        enableStream: function(stream){
            var element = this.element;
            var index = stream.index()-1;
            stream.removeClass("disabled").data("streamDisabled", false);
            element.find(".stream-events").eq(index).find(".stream-event").removeClass("disabled");
        },

        disableStream: function(stream){
            var element = this.element;
            var index = stream.index()-1;
            stream.addClass("disabled").data("streamDisabled", true);
            element.find(".stream-events").eq(index).find(".stream-event").addClass("disabled");
        },

        toggleStream: function(stream){
            if (stream.data("streamDisabled") === true) {
                this.enableStream(stream);
            } else {
                this.disableStream(stream);
            }
        },

        getLink: function(){
            var element = this.element, o = this.options;
            var events = element.find(".stream-event");
            var a = [];
            var link;
            var origin = window.location.href;

            $.each(events, function(){
                var event = $(this);
                if (event.data("sid") === undefined || !event.hasClass("selected")) {
                    return;
                }

                a.push(event.data("sid"));
            });

            link = element.attr("id") + "|" + a.join(",");

            if (o.encodeLink === true) {
                link = btoa(link);
            }

            return Utils.updateURIParameter(origin, "StreamerIDS", link);
        },

        getTimes: function(){
            var element = this.element;
            var times = element.find(".streamer-timeline > li");
            var result = [];
            $.each(times, function(){
                result.push($(this).data("time"));
            });
            return result;
        },

        getEvents: function(event_type, include_global){
            var element = this.element;
            var items, events = [];

            switch (event_type) {
                case "selected": items = element.find(".stream-event.selected"); break;
                case "non-selected": items = element.find(".stream-event:not(.selected)"); break;
                default: items = element.find(".stream-event");
            }

            $.each(items, function(){
                var item = $(this);
                var origin;

                if (include_global !== true && item.parent().hasClass("global-stream")) return ;

                origin = item.data("origin");

                events.push(origin);
            });

            return events;
        },

        source: function(s){
            var element = this.element;

            if (s === undefined) {
                return this.options.source;
            }

            element.attr("data-source", s);

            this.options.source = s;
            this.changeSource();
        },

        dataSet: function(s){
            if (s === undefined) {
                return this.options.data;
            }

            this.options.data = s;
            this.changeData(s);
        },

        getStreamerData: function(){
            return this.data;
        },

        toggleEvent: function(event){
            var o = this.options;
            event = $(event);

            if (event.hasClass("global-event") && o.selectGlobal !== true) {
                return ;
            }

            if (event.hasClass("selected")) {
                this.selectEvent(event, false);
            } else {
                this.selectEvent(event, true);
            }
        },

        selectEvent: function(event, state){
            var that = this, o = this.options;
            if (state === undefined) {
                state = true;
            }
            event = $(event);

            if (event.hasClass("global-event") && o.selectGlobal !== true) {
                return ;
            }

            if (state === true) event.addClass("selected"); else event.removeClass("selected");

            if (o.changeUri === true) {
                that._changeURI();
            }

            this._fireEvent("event-select", {
                event: event[0],
                selected: state
            });
        },

        changeSource: function(){
            var that = this, element = this.element, o = this.options;
            var new_source = element.attr("data-source");

            if (String(new_source).trim() === "") {
                return ;
            }

            o.source = new_source;

            this._fireEvent("data-load", {
                source: o.source
            });

            $.json(o.source).then(function(data){

                that._fireEvent("data-loaded", {
                    source: o.source,
                    data: data
                });

                that.data = data;
                that.build();
            }, function(xhr){

                that._fireEvent("data-load-error", {
                    source: o.source,
                    xhr: xhr
                });
            });

            this._fireEvent("source-change");
        },

        changeData: function(data){
            var element = this.element, o = this.options;
            var old_data = this.data;

            o.data =  typeof data === 'object' ? data : JSON.parse(element.attr("data-data"));

            this.data = o.data;

            this.build();

            this._fireEvent("data-change", {
                oldData: old_data,
                newData: o.data
            });
        },

        changeStreamSelectOption: function(){
            var element = this.element, o = this.options;

            o.streamSelect = element.attr("data-stream-select").toLowerCase() === "true";
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-source': this.changeSource(); break;
                case 'data-data': this.changeData(); break;
                case 'data-stream-select': this.changeStreamSelectOption(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".stream-event");
            element.off(Metro.events.click, ".stream");
            element.find(".events-area").off(Metro.events.mousewheel);
            element.find(".events-area").last().off("scroll");
            // element.off(Metro.events.click, ".stream");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SwitchDefaultConfig = {
        switchDeferred: 0,
        material: false,
        transition: true,
        caption: "",
        captionPosition: "right",
        clsSwitch: "",
        clsCheck: "",
        clsCaption: "",
        onSwitchCreate: Metro.noop
    };

    Metro.switchSetup = function (options) {
        SwitchDefaultConfig = $.extend({}, SwitchDefaultConfig, options);
    };

    if (typeof window["metroSwitchSetup"] !== undefined) {
        Metro.switchSetup(window["metroSwitchSetup"]);
    }

    Metro.Component('switch', {
        init: function( options, elem ) {
            this._super(elem, options, SwitchDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var container ;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            container = element.wrap(
                $("<label>").addClass((o.material === true ? " switch-material " : " switch ") + element[0].className)
            );

            check.appendTo(container);
            caption.appendTo(container);

            if (element.attr("data-on")) check.attr("data-on", element.attr("data-on"));
            if (element.attr("data-off")) check.attr("data-off", element.attr("data-off"));

            if (o.transition === true) {
                container.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                container.addClass("caption-left");
            }

            element[0].className = '';

            container.addClass(o.clsSwitch);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            this._fireEvent("switch-create");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                element.prop("checked", v === 1);
            }

            return this;
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Export = Metro.export;
    var TableDefaultConfig = {
        tableDeferred: 0,
        emptyTableTitle: "Nothing to show",
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,

        locale: METRO_LOCALE,

        horizontalScroll: false,
        horizontalScrollStop: null,
        check: false,
        checkType: "checkbox",
        checkStyle: 1,
        checkColIndex: 0,
        checkName: null,
        checkStoreKey: "TABLE:$1:KEYS",
        rownum: false,
        rownumTitle: "#",

        filters: null,
        filtersOperator: "and",

        head: null,
        body: null,
        static: false,
        source: null,

        searchMinLength: 1,
        searchThreshold: 500,
        searchFields: null,

        showRowsSteps: true,
        showSearch: true,
        showTableInfo: true,
        showPagination: true,
        paginationShortMode: true,
        showActivity: true,
        muteTable: true,
        showSkip: false,

        rows: 10,
        rowsSteps: "10,25,50,100",

        staticView: false,
        viewSaveMode: "client",
        viewSavePath: "TABLE:$1:OPTIONS",

        sortDir: "asc",
        decimalSeparator: ".",
        thousandSeparator: ",",

        tableRowsCountTitle: "Show entries:",
        tableSearchTitle: "Search:",
        tableInfoTitle: "Showing $1 to $2 of $3 entries",
        paginationPrevTitle: "Prev",
        paginationNextTitle: "Next",
        allRecordsTitle: "All",
        inspectorTitle: "Inspector",
        tableSkipTitle: "Go to page",

        activityType: "cycle",
        activityStyle: "color",
        activityTimeout: 100,

        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        skipWrapper: null,

        cellWrapper: false,

        clsComponent: "",
        clsTableContainer: "",
        clsTable: "",

        clsHead: "",
        clsHeadRow: "",
        clsHeadCell: "",

        clsBody: "",
        clsBodyRow: "",
        clsBodyCell: "",
        clsCellWrapper: "",

        clsFooter: "",
        clsFooterRow: "",
        clsFooterCell: "",

        clsTableTop: "",
        clsRowsCount: "",
        clsSearch: "",

        clsTableBottom: "",
        clsTableInfo: "",
        clsTablePagination: "",

        clsPagination: "",
        clsTableSkip: "",
        clsTableSkipInput: "",
        clsTableSkipButton: "",

        clsEvenRow: "",
        clsOddRow: "",
        clsRow: "",

        clsEmptyTableTitle: "",

        onDraw: Metro.noop,
        onDrawRow: Metro.noop,
        onDrawCell: Metro.noop,
        onAppendRow: Metro.noop,
        onAppendCell: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoadError: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataSaveError: Metro.noop,
        onFilterRowAccepted: Metro.noop,
        onFilterRowDeclined: Metro.noop,
        onCheckClick: Metro.noop,
        onCheckClickAll: Metro.noop,
        onCheckDraw: Metro.noop,
        onViewSave: Metro.noop,
        onViewGet: Metro.noop,
        onViewCreated: Metro.noop,
        onTableCreate: Metro.noop,
        onSkip: Metro.noop
    };

    Metro.tableSetup = function(options){
        TableDefaultConfig = $.extend({}, TableDefaultConfig, options);
    };

    if (typeof window["metroTableSetup"] !== undefined) {
        Metro.tableSetup(window["metroTableSetup"]);
    }

    Metro.Component('table', {
        init: function( options, elem ) {
            this._super(elem, options, TableDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                searchString: "",
                data: null,
                activity: null,
                loadActivity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                wrapperSkip: null,
                filterIndex: null,
                filtersIndexes: [],
                component: null,
                inspector: null,
                view: {},
                viewDefault: {},
                locale: Metro.locales["en-US"],
                input_interval: null,
                searchFields: [],
                id: Utils.elementId('table'),
                sort: {
                    dir: "asc",
                    colIndex: 0
                },
                service: [],
                heads: [],
                items: [],
                foots: [],
                filteredItems: [],
                index: {}
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var id = Utils.elementId("table");
            var table_component, table_container, activity;

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", id);
            }

            if (Utils.isValue(Metro.locales[o.locale])) {
                this.locale = Metro.locales[o.locale];
            }

            if (Utils.isValue(o.searchFields)) {
                this.searchFields = o.searchFields.toArray();
            }

            if (Utils.isValue(o.head)) {
                var _head = o.head;
                o.head = Utils.isObject(o.head);
                if (!o.head) {
                    console.warn("Head "+_head+" defined but not exists!");
                    o.head = null;
                }
            }

            if (Utils.isValue(o.body)) {
                var _body = o.body;
                o.body = Utils.isObject(o.body);
                if (!o.body) {
                    console.warn("Body "+_body+" defined but not exists!");
                    o.body = null;
                }
            }

            if (o.static === true) {
                o.showPagination = false;
                o.showRowsSteps = false;
                o.showSearch = false;
                o.showTableInfo = false;
                o.showSkip = false;
                o.rows = -1;
            }

            table_component = $("<div>").addClass("table-component");
            table_component.insertBefore(element);

            table_container = $("<div>").addClass("table-container").addClass(o.clsTableContainer).appendTo(table_component);
            element.appendTo(table_container);

            if (o.horizontalScroll === true) {
                table_container.addClass("horizontal-scroll");
            }
            if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                table_container.removeClass("horizontal-scroll");
            }

            table_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("table-progress").appendTo(table_component);

            activity = $("<div>").appendTo(this.activity);
            Metro.makePlugin(activity, "activity", {
                type: o.activityType,
                style: o.activityStyle
            });

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            this.component = table_component[0];

            if (o.source !== null) {

                this._fireEvent("data-load", {
                    source: o.source
                });

                var objSource = Utils.isObject(o.source);

                if (objSource !== false && $.isPlainObject(objSource)) {
                    that._build(objSource);
                } else {
                    this.activity.show(function () {
                        $.json(o.source).then(function (data) {
                            that.activity.hide();
                            if (typeof data !== "object") {
                                throw new Error("Data for table is not a object");
                            }

                            that._fireEvent("data-loaded", {
                                source: o.source,
                                data: data
                            });

                            that._build(data);
                        }, function (xhr) {
                            that.activity.hide();

                            that._fireEvent("data-load-error", {
                                source: o.source,
                                xhr: xhr
                            });
                        });
                    });
                }
            } else {
                that._build();
            }
        },

        _createIndex: function(){
            var that = this, colIndex = this.options.checkColIndex;
            setImmediate(function(){
                that.items.forEach(function(v, i){
                    that.index[v[colIndex]] = i;
                });
            });
        },

        _build: function(data){
            var that = this, element = this.element, o = this.options;
            var view, id = element.attr("id"), viewPath;

            o.rows = parseInt(o.rows);

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            // Create index
            this._createIndex();

            this.view = this._createView();
            this.viewDefault = Utils.objectClone(this.view);

            viewPath = o.viewSavePath.replace("$1", id);

            if (o.viewSaveMode.toLowerCase() === "client") {

                view = Metro.storage.getItem(viewPath);
                if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(this.view)) {
                    this.view = view;

                    this._fireEvent("view-get", {
                        source: "client",
                        view: view
                    });
                }
                this._final();

            } else {

                $.json(viewPath, (viewPath !== o.viewSavePath ? null : {id: id}))
                .then(function(view){
                    if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(that.view)) {
                        that.view = view;
                        that._fireEvent("view-get", {
                            source: "server",
                            view: view
                        });
                    }
                    that._final();
                }, function(){
                    that._final();
                    console.warn("Warning! Error loading view for table " + element.attr('id') + " ");
                });

            }
        },

        _final: function(){
            var element = this.element, o = this.options;
            var id = element.attr("id");

            Metro.storage.delItem(o.checkStoreKey.replace("$1", id));

            this._service();
            this._createStructure();
            this._createInspector();
            this._createEvents();

            this._fireEvent("table-create", {
                element: element
            });
        },

        _service: function(){
            var o = this.options;

            this.service = [
                {
                    // Rownum
                    title: o.rownumTitle,
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    cls: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rownum"
                },
                {
                    // Check
                    title: o.checkType === "checkbox" ? "<input type='checkbox' data-role='checkbox' class='table-service-check-all' data-style='"+o.checkStyle+"'>" : "",
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "check-cell " + (o.check !== true ? "d-none" : ""),
                    cls: "check-cell "+(o.check !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rowcheck"
                }
            ];
        },

        _createView: function(){
            var view;

            view = {};

            $.each(this.heads, function(i){

                if (Utils.isValue(this.cls)) {this.cls = this.cls.replace("hidden", "");}
                if (Utils.isValue(this.clsColumn)) {this.clsColumn = this.clsColumn.replace("hidden", "");}

                view[i] = {
                    "index": i,
                    "index-view": i,
                    "show": !Utils.isValue(this.show) ? true : this.show,
                    "size": Utils.isValue(this.size) ? this.size : ""
                }
            });

            this._fireEvent("view-created", {
                view: view
            });

            return view;
        },

        _createInspectorItems: function(table){
            var that = this, o = this.options;
            var j, tds = [], row;
            var cells = this.heads;

            table.html("");

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(i){
                row = $("<tr>");
                row.data('index', i);
                row.data('index-view', i);
                $("<td>").html("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='column_show_check[]' value='"+i+"' "+(Utils.bool(that.view[i]['show']) ? "checked" : "")+">").appendTo(row);
                $("<td>").html(this.title).appendTo(row);
                $("<td>").html("<input type='number' data-role='spinner' name='column_size' value='"+that.view[i]['size']+"' data-index='"+i+"'>").appendTo(row);
                $("<td>").html("" +
                    "<button class='button square js-table-inspector-field-up' type='button'><span class='mif-arrow-up'></span></button>" +
                    "<button class='button square js-table-inspector-field-down' type='button'><span class='mif-arrow-down'></span></button>" +
                    "").appendTo(row);
                tds[that.view[i]['index-view']] = row;
            });

            //
            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(table);
            }
        },

        _createInspector: function(){
            var o = this.options;
            var inspector, table_wrap, table, tbody, actions;

            inspector = $("<div data-role='draggable' data-drag-element='.table-inspector-header' data-drag-area='body'>").addClass("table-inspector");
            inspector.attr("for", this.element.attr("id"));

            $("<div class='table-inspector-header'>"+o.inspectorTitle+"</div>").appendTo(inspector);

            table_wrap = $("<div>").addClass("table-wrap").appendTo(inspector);

            table = $("<table>").addClass("table subcompact");
            tbody = $("<tbody>").appendTo(table);

            table.appendTo(table_wrap);

            this._createInspectorItems(tbody);

            actions = $("<div class='table-inspector-actions'>").appendTo(inspector);
            $("<button class='button primary js-table-inspector-save' type='button'>").html(this.locale.buttons.save).appendTo(actions);
            $("<button class='button secondary js-table-inspector-reset ml-2 mr-2' type='button'>").html(this.locale.buttons.reset).appendTo(actions);
            $("<button class='button link js-table-inspector-cancel place-right' type='button'>").html(this.locale.buttons.cancel).appendTo(actions);

            inspector.data("open", false);
            this.inspector = inspector;

            $("body").append(inspector);

            this._createInspectorEvents();
        },

        _resetInspector: function(){
            var inspector = this.inspector;
            var table = inspector.find("table tbody");
            this._createInspectorItems(table);
            this._createInspectorEvents();
        },

        _createHeadsFromHTML: function(){
            var that = this, element = this.element;
            var head = element.find("thead");

            if (head.length > 0) $.each(head.find("tr > *"), function(){
                var item = $(this);
                var dir, head_item, item_class;

                if (Utils.isValue(item.data('sort-dir'))) {
                    dir = item.data('sort-dir');
                } else {
                    if (item.hasClass("sort-asc")) {
                        dir = "asc";
                    } else if (item.hasClass("sort-desc")) {
                        dir = "desc"
                    } else {
                        dir = undefined;
                    }
                }

                item_class = item[0].className.replace("sortable-column", "");
                item_class = item_class.replace("sort-asc", "");
                item_class = item_class.replace("sort-desc", "");
                item_class = item_class.replace("hidden", "");

                head_item = {
                    type: "data",
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : item.text().replace(" ", "_"),
                    sortable: item.hasClass("sortable-column") || (Utils.isValue(item.data('sortable')) && JSON.parse(item.data('sortable') === true)),
                    sortDir: dir,
                    format: Utils.isValue(item.data("format")) ? item.data("format") : "string",
                    formatMask: Utils.isValue(item.data("format-mask")) ? item.data("format-mask") : null,
                    clsColumn: Utils.isValue(item.data("cls-column")) ? item.data("cls-column") : "",
                    cls: item_class,
                    colspan: item.attr("colspan"),
                    size: Utils.isValue(item.data("size")) ? item.data("size") : "",
                    show: !(item.hasClass("hidden") || (Utils.isValue(item.data('show')) && JSON.parse(item.data('show')) === false)),

                    required: Utils.isValue(item.data("required")) ? JSON.parse(item.data("required")) === true  : false,
                    field: Utils.isValue(item.data("field")) ? item.data("field") : "input",
                    fieldType: Utils.isValue(item.data("field-type")) ? item.data("field-type") : "text",
                    validator: Utils.isValue(item.data("validator")) ? item.data("validator") : null,

                    template: Utils.isValue(item.data("template")) ? item.data("template") : null
                };
                that.heads.push(head_item);
            });
        },

        _createFootsFromHTML: function(){
            var that = this, element = this.element;
            var foot = element.find("tfoot");

            if (foot.length > 0) $.each(foot.find("tr > *"), function(){
                var item = $(this);
                var foot_item;

                foot_item = {
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : false,
                    cls: item[0].className,
                    colspan: item.attr("colspan")
                };

                that.foots.push(foot_item);
            });
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element;
            var body = element.find("tbody");

            if (body.length > 0) $.each(body.find("tr"), function(){
                var row = $(this);
                var tr = [];
                $.each(row.children("td"), function(){
                    var td = $(this);
                    tr.push(td.html());
                });
                that.items.push(tr);
            });

            this._createHeadsFromHTML();
            this._createFootsFromHTML();
        },

        _createItemsFromJSON: function(source){
            var that = this;

            if (typeof source === "string") {
                source = JSON.parse(source);
            }

            if (source.header !== undefined) {
                that.heads = source.header;
            } else {
                this._createHeadsFromHTML();
            }

            if (source.data !== undefined) {
                $.each(source.data, function(){
                    var row = this;
                    var tr = [];
                    $.each(row, function(){
                        var td = this;
                        tr.push(td);
                    });
                    that.items.push(tr);
                });
            }

            if (source.footer !== undefined) {
                this.foots = source.footer;
            } else {
                this._createFootsFromHTML();
            }
        },

        _createTableHeader: function(){
            var element = this.element, o = this.options;
            var head = $("<thead>").html('');
            var tr, th, tds = [], j, cells;
            var view = o.staticView ? this._createView() : this.view;

            element.find("thead").remove();

            head.addClass(o.clsHead);

            if (this.heads.length === 0) {
                return head;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(head);

            $.each(this.service, function(){
                var item = this, classes = [];
                th = $("<th>").appendTo(tr);
                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.size)) {th.css({width: item.size});}
                if (Utils.isValue(item.cls)) {classes.push(item.cls);}
                classes.push(o.clsHeadCell);
                th.addClass(classes.join(" "));
            });

            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                var classes = [];

                th = $("<th>");
                th.data("index", cell_index);

                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.format)) {th.attr("data-format", item.format);}
                if (Utils.isValue(item.name)) {th.attr("data-name", item.name);}
                if (Utils.isValue(item.colspan)) {th.attr("colspan", item.colspan);}
                if (Utils.isValue(view[cell_index]['size'])) {th.css({width: view[cell_index]['size']});}
                if (item.sortable === true) {
                    classes.push("sortable-column");

                    if (Utils.isValue(item.sortDir)) {
                        classes.push("sort-" + item.sortDir);
                    }
                }
                if (Utils.isValue(item.cls)) {
                    $.each(item.cls.toArray(), function () {
                        classes.push(this);
                    });
                }
                if (Utils.bool(view[cell_index]['show']) === false) {
                    if (classes.indexOf('hidden') === -1) classes.push("hidden");
                }

                classes.push(o.clsHeadCell);

                if (Utils.bool(view[cell_index]['show'])) {
                    Utils.arrayDelete(classes, "hidden");
                }

                th.addClass(classes.join(" "));

                tds[view[cell_index]['index-view']] = th;
            });

            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(tr);
            }

            element.prepend(head);
        },

        _createTableBody: function(){
            var body, head, element = this.element;

            head  = element.find("thead");
            element.find("tbody").remove();
            body = $("<tbody>").addClass(this.options.clsBody);
            body.insertAfter(head);
        },

        _createTableFooter: function(){
            var element = this.element, o = this.options;
            var foot = $("<tfoot>").addClass(o.clsFooter);
            var tr, th;

            element.find("tfoot").remove();

            if (this.foots.length === 0) {
                element.append(foot);
                return;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(foot);
            $.each(this.foots, function(){
                var item = this;
                th = $("<th>").appendTo(tr);

                if (item.title !== undefined) {
                    th.html(item.title);
                }

                if (item.name !== undefined) {
                    th.addClass("foot-column-name-" + item.name);
                }

                if (item.cls !== undefined) {
                    th.addClass(item.cls);
                }

                if (Utils.isValue(item.colspan)) {
                    th.attr("colspan", item.colspan);
                }

                th.appendTo(tr);
            });

            element.append(foot);
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("table-top").addClass(o.clsTableTop).insertBefore(element.parent());
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("table-search-block").addClass(o.clsSearch).appendTo(top_block);
            search_block.addClass(o.clsSearch);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            Metro.makePlugin(search_input, "input", {
                prepend: o.tableSearchTitle
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("table-rows-block").appendTo(top_block);
            rows_block.addClass(o.clsRowsCount);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.rowsSteps.toArray(), function () {
                var val = parseInt(this);
                var option = $("<option>").attr("value", val).text(val === -1 ? o.allRecordsTitle : val).appendTo(rows_select);
                if (val === parseInt(o.rows)) {
                    option.attr("selected", "selected");
                }
            });
            Metro.makePlugin(rows_select, "select",{
                filter: false,
                prepend: o.tableRowsCountTitle,
                onChange: function (val) {
                    val = parseInt(val);
                    if (val === parseInt(o.rows)) {
                        return;
                    }
                    o.rows = val;
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showRowsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("table-bottom").addClass(o.clsTableBottom).insertAfter(element.parent());
            var info, pagination, skip;

            info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : $("<div>").addClass("table-info").appendTo(bottom_block);
            info.addClass(o.clsTableInfo);
            if (o.showTableInfo !== true) {
                info.hide();
            }

            pagination = Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : $("<div>").addClass("table-pagination").appendTo(bottom_block);
            pagination.addClass(o.clsTablePagination);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            skip = Utils.isValue(this.wrapperSkip) ? this.wrapperSkip : $("<div>").addClass("table-skip").appendTo(bottom_block);
            skip.addClass(o.clsTableSkip);

            $("<input type='text'>").addClass("input table-skip-input").addClass(o.clsTableSkipInput).appendTo(skip);
            $("<button>").addClass("button table-skip-button").addClass(o.clsTableSkipButton).html(o.tableSkipTitle).appendTo(skip);

            if (o.showSkip !== true) {
                skip.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var columns;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper),
                w_skip = $(o.skipWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}
            if (w_skip.length > 0) {this.wrapperSkip = w_skip;}

            element.html("").addClass(o.clsTable);

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            this._createTopBlock();
            this._createBottomBlock();

            var need_sort = false;
            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                columns = element.find("thead th");
                this._resetSortClass(columns);
                $(columns.get(this.sort.colIndex + that.service.length)).addClass("sort-"+this.sort.dir);
                this.sorting();
            }

            var filter_func;

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            this._draw();
        },

        _resetSortClass: function(el){
            $(el).removeClass("sort-asc sort-desc");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var table_container = component.find(".table-container");
            var search = component.find(".table-search-block input");
            var skip_button = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-button') : component.find(".table-skip-button");
            var skip_input = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-input') : component.find(".table-skip-input");
            var customSearch;
            var id = element.attr("id");

            skip_button.on(Metro.events.click, function(){
                var skipTo = parseInt(skip_input.val().trim());

                if (isNaN(skipTo) || skipTo <=0 || skipTo > that.pagesCount) {
                    skip_input.val('');
                    return false;
                }

                skip_input.val('');

                that._fireEvent("skip", {
                    skipTo: skipTo,
                    skipFrom: that.currentPage
                });

                that.page(skipTo);
            });

            $(window).on(Metro.events.resize, function(){
                if (o.horizontalScroll === true) {
                    if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                        table_container.removeClass("horizontal-scroll");
                    } else {
                        table_container.addClass("horizontal-scroll");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, ".sortable-column", function(){

                if (o.muteTable === true) element.addClass("disabled");

                if (that.busy) {
                    return false;
                }
                that.busy = true;

                var col = $(this);

                that.activity.show(function(){
                    setImmediate(function(){
                        that.currentPage = 1;
                        that.sort.colIndex = col.data("index");
                        if (!col.hasClass("sort-asc") && !col.hasClass("sort-desc")) {
                            that.sort.dir = o.sortDir;
                        } else {
                            if (col.hasClass("sort-asc")) {
                                that.sort.dir = "desc";
                            } else {
                                that.sort.dir = "asc";
                            }
                        }
                        that._resetSortClass(element.find(".sortable-column"));
                        col.addClass("sort-"+that.sort.dir);
                        that.sorting();
                        that._draw(function(){
                            that.busy = false;
                            if (o.muteTable === true) element.removeClass("disabled");
                        });
                    });
                });
            });

            element.on(Metro.events.click, ".table-service-check input", function(){
                var check = $(this);
                var status = check.is(":checked");
                var val = ""+check.val();
                var store_key = o.checkStoreKey.replace("$1", id);
                var storage = Metro.storage;
                var data = storage.getItem(store_key);
                var is_radio = check.attr('type') === 'radio';

                if (is_radio) {
                    data = [];
                }

                if (status) {
                    if (!Utils.isValue(data)) {
                        data = [val];
                    } else {
                        if (Array(data).indexOf(val) === -1) {
                            data.push(val);
                        }
                    }
                } else {
                    if (Utils.isValue(data)) {
                        Utils.arrayDelete(data, val);
                    } else {
                        data = [];
                    }
                }

                storage.setItem(store_key, data);

                that._fireEvent("check-click", {
                    check: this,
                    status: status,
                    data: data
                });
            });

            element.on(Metro.events.click, ".table-service-check-all input", function(){
                var status = $(this).is(":checked");
                var store_key = o.checkStoreKey.replace("$1", id);
                var data = [];
                var storage = Metro.storage;

                if (status) {
                    $.each(that.filteredItems, function(){
                        if (data.indexOf(this[o.checkColIndex]) !== -1) return ;
                        data.push(""+this[o.checkColIndex]);
                    });
                } else {
                    data = [];
                }

                storage.setItem(store_key, data);

                that._draw();

                that._fireEvent("check-click-all", {
                    check: this,
                    status: status,
                    data: data
                });
            });

            var _search = function(){
                that.searchString = this.value.trim().toLowerCase();

                clearInterval(that.input_interval); that.input_interval = false;
                if (!that.input_interval) that.input_interval = setTimeout(function(){
                    that.currentPage = 1;
                    that._draw();
                    clearInterval(that.input_interval); that.input_interval = false;
                }, o.searchThreshold);
            };

            search.on(Metro.events.inputchange, _search);

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, _search);
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();
                if (that.filteredItems.length === 0) {
                    return ;
                }

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }

            this._createInspectorEvents();

            element.on(Metro.events.click, ".js-table-crud-button", function(){

            });
        },

        _createInspectorEvents: function(){
            var that = this, inspector = this.inspector;
            // Inspector event

            this._removeInspectorEvents();

            inspector.on(Metro.events.click, ".js-table-inspector-field-up", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_prev = tr.prev("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_prev.length === 0) {
                    return ;
                }
                tr.insertBefore(tr_prev);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.nextAll(), function(){
                    var t = $(this);
                    index_view++;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-field-down", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_next = tr.next("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_next.length === 0) {
                    return ;
                }
                tr.insertAfter(tr_next);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.prevAll(), function(){
                    var t = $(this);
                    index_view--;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var status = check.is(":checked");
                var index = check.val();
                var op = ['cls', 'clsColumn'];

                if (status) {
                    $.each(op, function(){
                        var a;
                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        Utils.arrayDelete(a, "hidden");
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = true;
                    });
                } else {
                    $.each(op, function(){
                        var a;

                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        if (a.indexOf("hidden") === -1) {
                            a.push("hidden");
                        }
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = false;
                    });
                }

                that._createTableHeader();
                that._draw();
            });

            inspector.find("input[type=number]").on(Metro.events.inputchange, function(){
                var input = $(this);
                var index = input.attr("data-index");
                var val = parseInt(input.val());

                that.view[index]['size'] = val === 0 ? "" : val;

                that._createTableHeader();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-save", function(){
                that._saveTableView();
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-cancel", function(){
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-reset", function(){
                that.resetView();
            });
        },

        _removeInspectorEvents: function(){
            var inspector = this.inspector;
            inspector.off(Metro.events.click, ".js-table-inspector-field-up");
            inspector.off(Metro.events.click, ".js-table-inspector-field-down");
            inspector.off(Metro.events.click, "input[type=checkbox]");
            inspector.off(Metro.events.click, ".js-table-inspector-save");
            inspector.off(Metro.events.click, ".js-table-inspector-cancel");
            inspector.off(Metro.events.click, ".js-table-inspector-reset");
            inspector.find("input[type=number]").off(Metro.events.inputchange);
        },

        _saveTableView: function(){
            var that = this, element = this.element, o = this.options;
            var view = this.view;
            var id = element.attr("id");
            var viewPath = o.viewSavePath.replace("$1", id);
            var storage = Metro.storage;

            if (o.viewSaveMode.toLowerCase() === "client") {
                storage.setItem(viewPath, view);

                this._fireEvent("view-save", {
                    target: "client",
                    path: o.viewSavePath,
                    view: view
                });
            } else {
                var post_data = {
                    id : element.attr("id"),
                    view : view
                };
                $.post(viewPath, post_data)
                    .then(function(data){

                        that._fireEvent("view-save", {
                            target: "server",
                            path: o.viewSavePath,
                            view: view,
                            post_data: post_data,
                            response: data
                        });

                    }, function(xhr){

                        that._fireEvent("data-save-error", {
                            source: o.viewSavePath,
                            xhr: xhr,
                            post_data: post_data
                        });

                    });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".table-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.tableInfoTitle;
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            this.pagesCount = Math.ceil(length / o.rows); // 
            Metro.pagination({
                length: length,
                rows: o.rows,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".table-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle,
                nextTitle: o.paginationNextTitle,
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this, o = this.options;
            var items;
            if ((Utils.isValue(this.searchString) && that.searchString.length >= o.searchMinLength) || this.filters.length > 0) {
                items = this.items.filter(function(row){

                    var row_data = "", result, search_result, i, j = 0;

                    if (that.filters.length > 0) {

                        result = o.filtersOperator.toLowerCase() === "and";
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.isNull(that.filters[i])) continue;
                            j++;
                            result = o.filtersOperator.toLowerCase() === "and" ?
                                result && Utils.exec(that.filters[i], [row, that.heads]) :
                                result || Utils.exec(that.filters[i], [row, that.heads])
                            ;
                        }

                        if (j === 0) result = true;
                    } else {
                        result = true;
                    }

                    if (that.searchFields.length > 0) {
                        $.each(that.heads, function(i, v){
                            if (that.searchFields.indexOf(v.name) > -1) {
                                row_data += ""+row[i];
                            }
                        })
                    } else {
                        row_data = row.join("");
                    }

                    row_data = row_data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    search_result = Utils.isValue(that.searchString) && that.searchString.length >= o.searchMinLength ? ~row_data.indexOf(that.searchString) : true;

                    result = result && search_result;

                    if (result) {
                        that._fireEvent("filter-row-accepted", {
                            row: row
                        });
                    } else {
                        that._fireEvent("filter-row-declined", {
                            row: row
                        });
                    }

                    return result;
                });

            } else {
                items = this.items;
            }

            this._fireEvent("search", {
                search: that.searchString,
                items: items
            });

            this.filteredItems = items;

            return items;
        },

        _draw: function(cb){
            var that = this, element = this.element, o = this.options;
            var body = element.find("tbody");
            var i, j, tr, td, check, cells, tds, is_even_row;
            var start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1),
                stop = parseInt(o.rows) === -1 ? this.items.length - 1 : start + o.rows - 1;
            var items;
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr('id')));

            var view = o.staticView ? this.viewDefault : this.view;

            body.html("");

            if (!this.heads.length) {
                console.warn("Heads is not defined for table ID " + element.attr("id"));
                return ;
            }

            items = this._filter();

            if (items.length > 0) {
                for (i = start; i <= stop; i++) {
                    cells = items[i];
                    tds = [];
                    if (!Utils.isValue(cells)) {continue;}
                    tr = $("<tr>").addClass(o.clsBodyRow);
                    tr.data('original', cells);

                    // Rownum

                    is_even_row = i % 2 === 0;

                    td = $("<td>").html(i + 1);
                    if (that.service[0].clsColumn !== undefined) {
                        td.addClass(that.service[0].clsColumn);
                    }
                    td.appendTo(tr);

                    // Checkbox
                    td = $("<td>");
                    if (o.checkType === "checkbox") {
                        check = $("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "[]' value='" + items[i][o.checkColIndex] + "'>");
                    } else {
                        check = $("<input type='radio' data-style='"+o.checkStyle+"' data-role='radio' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "' value='" + items[i][o.checkColIndex] + "'>");
                    }

                    if (Utils.isValue(stored_keys) && Array.isArray(stored_keys) && stored_keys.indexOf(""+items[i][o.checkColIndex]) > -1) {
                        check.prop("checked", true);
                    }

                    check.addClass("table-service-check");

                    this._fireEvent("check-draw", {
                        check: check
                    });

                    check.appendTo(td);
                    if (that.service[1].clsColumn !== undefined) {
                        td.addClass(that.service[1].clsColumn);
                    }
                    td.appendTo(tr);

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        var val = this;
                        var td = $("<td>");

                        if (Utils.isValue(that.heads[cell_index].template)) {
                            val = that.heads[cell_index].template.replace(/%VAL%/g, val);
                        }

                        td.html(val);

                        td.addClass(o.clsBodyCell);
                        if (Utils.isValue(that.heads[cell_index].clsColumn)) {
                            td.addClass(that.heads[cell_index].clsColumn);
                        }

                        if (Utils.bool(view[cell_index].show) === false) {
                            td.addClass("hidden");
                        }

                        if (Utils.bool(view[cell_index].show)) {
                            td.removeClass("hidden");
                        }

                        td.data('original',this);

                        tds[view[cell_index]['index-view']] = td;

                        that._fireEvent("draw-cell", {
                            td: td,
                            val: val,
                            cellIndex: cell_index,
                            head: that.heads[cell_index],
                            items: cells
                        });

                        if (o.cellWrapper === true) {
                            val = $("<div>").addClass("data-wrapper").addClass(o.clsCellWrapper).html(td.html());
                            td.html('').append(val);
                        }
                    });

                    for (j = 0; j < cells.length; j++){
                        tds[j].appendTo(tr);

                        that._fireEvent("append-cell", {
                            td: tds[j],
                            tr: tr,
                            index: j
                        });
                    }

                    that._fireEvent("draw-row", {
                        tr: tr,
                        view: that.view,
                        heads: that.heads,
                        items: cells
                    });

                    tr.addClass(o.clsRow).addClass(is_even_row ? o.clsEvenRow : o.clsOddRow).appendTo(body);

                    that._fireEvent("append-row", {
                        tr: tr
                    });
                }

            } else {
                j = 0;
                $.each(view, function(){
                    if (this.show) j++;
                });
                if (o.check === true) {
                    j++;
                }
                if (o.rownum === true) {
                    j++;
                }
                tr = $("<tr>").addClass(o.clsBodyRow).appendTo(body);
                td = $("<td>").attr("colspan", j).addClass("text-center").html($("<span>").addClass(o.clsEmptyTableTitle).html(o.emptyTableTitle));
                td.appendTo(tr);
            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            if (this.activity) this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, null, element[0])
            }
        },

        _getItemContent: function(row){
            var o = this.options;
            var result, col = row[this.sort.colIndex];
            var format = this.heads[this.sort.colIndex].format;
            var formatMask = !Utils.isNull(this.heads) && !Utils.isNull(this.heads[this.sort.colIndex]) && Utils.isValue(this.heads[this.sort.colIndex]['formatMask']) ? this.heads[this.sort.colIndex]['formatMask'] : "%Y-%m-%d";
            var thousandSeparator = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["thousandSeparator"] ? this.heads[this.sort.colIndex]["thousandSeparator"] : o.thousandSeparator;
            var decimalSeparator  = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["decimalSeparator"] ? this.heads[this.sort.colIndex]["decimalSeparator"] : o.decimalSeparator;

            result = (""+col).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(result) && Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1) {
                    result = Utils.parseNumber(result, thousandSeparator, decimalSeparator);
                }

                switch (format) {
                    case "date": result = Utils.isValue(formatMask) ? result.toDate(formatMask) : new Date(result); break;
                    case "number": result = Number(result); break;
                    case "int": result = parseInt(result); break;
                    case "float": result = parseFloat(result); break;
                    case "money": result = Utils.parseMoney(result); break;
                    case "card": result = Utils.parseCard(result); break;
                    case "phone": result = Utils.parsePhone(result); break;
                }
            }

            return result;
        },

        addItem: function(item, redraw){
            if (!Array.isArray(item)) {
                console.warn("Item is not an array and can't be added");
                return this;
            }
            this.items.push(item);
            if (redraw !== false) this.draw();
        },

        addItems: function(items, redraw){
            if (!Array.isArray(items)) {
                console.warn("Items is not an array and can't be added");
                return this;
            }
            items.forEach(function(item){
                if (Array.isArray(item))
                    this.items.push(item, false);
            });
            this.draw();
            if (redraw !== false) this.draw();
        },

        updateItem: function(key, field, value){
            var item = this.items[this.index[key]];
            var fieldIndex = null;
            if (Utils.isNull(item)) {
                console.warn('Item is undefined for update');
                return this;
            }
            if (isNaN(field)) {
                this.heads.forEach(function(v, i){
                    if (v['name'] === field) {
                        fieldIndex = i;
                    }
                });
            }
            if (Utils.isNull(fieldIndex)) {
                console.warn('Item is undefined for update. Field ' + field + ' not found in data structure');
                return this;
            }

            item[fieldIndex] = value;
            this.items[this.index[key]] = item;
            return this;
        },

        getItem: function(key){
            return this.items[this.index[key]];
        },

        deleteItem: function(fieldIndex, value){
            var i, deleteIndexes = [];
            var is_func = Utils.isFunc(value);
            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        deleteItemByName: function(fieldName, value){
            var i, fieldIndex, deleteIndexes = [];
            var is_func = Utils.isFunc(value);

            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i]['name'] === fieldName) {
                    fieldIndex = i;
                    break;
                }
            }

            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            this._draw();
            return this;
        },

        sorting: function(dir){
            var that = this;

            if (Utils.isValue(dir)) {
                this.sort.dir = dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = that.sort.dir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = that.sort.dir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            });

            return this;
        },

        search: function(val){
            this.searchString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
            return this;
        },

        _rebuild: function(review){
            var that = this, element = this.element;
            var need_sort = false, sortable_columns;

            this._createIndex();

            if (review === true) {
                this.view = this._createView();
            }

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                sortable_columns = element.find(".sortable-column");
                this._resetSortClass(sortable_columns);
                $(sortable_columns.get(that.sort.colIndex)).addClass("sort-"+that.sort.dir);
                this.sorting();
            }

            that.currentPage = 1;

            that._draw();
        },

        setHeads: function(data){
            this.heads = data;
            return this;
        },

        setHeadItem: function(name, data){
            var i, index;
            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i].name === name) {
                    index = i;
                    break;
                }
            }
            this.heads[index] = data;
            return this;
        },

        setItems: function(data){
            this.items = data;
            return this;
        },

        setData: function(/*obj*/ data){
            var o = this.options;

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            this._createItemsFromJSON(data);

            this._rebuild(true);

            return this;
        },

        loadData: function(source, review){
            var that = this, element = this.element, o = this.options;

            if (!Utils.isValue(review)) {
                review = true;
            }

            element.html("");

            if (!Utils.isValue(source)) {

                this._rebuild(review);

            } else {
                o.source = source;

                this._fireEvent("data-load", {
                    source: o.source
                });

                that.activity.show(function(){
                    $.json(o.source).then(function(data){
                        that.activity.hide();
                        that.items = [];
                        that.heads = [];
                        that.foots = [];

                        that._fireEvent("data-loaded", {
                            source: o.source,
                            data: data
                        });

                        if (Array.isArray(o.head)) {
                            that.heads = o.head;
                        }

                        if (Array.isArray(o.body)) {
                            that.items = o.body;
                        }

                        that._createItemsFromJSON(data);
                        that._rebuild(review);
                    }, function(xhr){
                        that.activity.hide();
                        that._fireEvent("data-load-error", {
                            source: o.source,
                            xhr: xhr
                        });
                    });
                });

            }
        },

        reload: function(review){
            this.loadData(this.options.source, review);
        },

        clear: function(){
            this.items = [];
            return this.draw();
        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
            return this;
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
            return this;
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
            return this;
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
            return this;
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
            return this;
        },

        addFilter: function(f, redraw){
            var filterIndex = null, i, func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }

            for(i = 0; i < this.filters.length; i++) {
                if (Utils.isNull(this.filters[i])) {
                    filterIndex = i;
                    this.filters[i] = func;
                    break;
                }
            }

            if (Utils.isNull(filterIndex)) {
                this.filters.push(func);
                filterIndex = this.filters.length - 1;
            }

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return filterIndex
        },

        removeFilter: function(key, redraw){
            this.filters[key] = null;
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        getItems: function(){
            return this.items;
        },

        getHeads: function(){
            return this.heads;
        },

        getView: function(){
            return this.view;
        },

        getFilteredItems: function(){
            return this.filteredItems.length > 0 ? this.filteredItems : this.items;
        },

        getSelectedItems: function(){
            var element = this.element, o = this.options;
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")));
            var selected = [];

            if (!Utils.isValue(stored_keys)) {
                return [];
            }

            $.each(this.items, function(){
                if (stored_keys.indexOf(""+this[o.checkColIndex]) !== -1) {
                    selected.push(this);
                }
            });
            return selected;
        },

        getStoredKeys: function(){
            var element = this.element, o = this.options;
            return Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
        },

        clearSelected: function(redraw){
            var element = this.element, o = this.options;
            Metro.storage.setItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
            element.find("table-service-check-all input").prop("checked", false);
            if (redraw === true) this._draw();
        },

        getFilters: function(){
            return this.filters;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        openInspector: function(mode){
            var ins = this.inspector;
            if (mode) {
                ins.show(0, function(){
                    ins.css({
                        top: ($(window).height()  - ins.outerHeight(true)) / 2 + pageYOffset,
                        left: ($(window).width() - ins.outerWidth(true)) / 2 + pageXOffset
                    }).data("open", true);
                });
            } else {
                ins.hide().data("open", false);
            }
        },

        closeInspector: function(){
            this.openInspector(false);
        },

        toggleInspector: function(){
            this.openInspector(!this.inspector.data("open"));
        },

        resetView: function(){

            this.view = this._createView();

            this._createTableHeader();
            this._createTableFooter();
            this._draw();

            this._resetInspector();
            this._saveTableView();
        },

        rebuildIndex: function(){
            this._createIndex();
        },

        getIndex: function(){
            return this.index;
        },

        export: function(to, mode, filename, options){
            var that = this, o = this.options;
            var table = document.createElement("table");
            var head = $("<thead>").appendTo(table);
            var body = $("<tbody>").appendTo(table);
            var i, j, cells, tds = [], items, tr, td;
            var start, stop;

            if (typeof Export.tableToCSV !== 'function') {
                return ;
            }

            mode = Utils.isValue(mode) ? mode.toLowerCase() : "all-filtered";
            filename = Utils.isValue(filename) ? filename : Utils.elementId("table")+"-export.csv";

            // Create table header
            tr = $("<tr>");
            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                if (Utils.bool(that.view[cell_index]['show']) === false) {
                    return ;
                }
                td = $("<th>");
                if (Utils.isValue(item.title)) {
                    td.html(item.title);
                }
                tds[that.view[cell_index]['index-view']] = td;
            });

            for (j = 0; j < cells.length; j++){
                if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
            }
            tr.appendTo(head);

            // Create table data
            if (mode === "checked") {
                items = this.getSelectedItems();
                start = 0; stop = items.length - 1;
            } else if (mode === "view") {
                items = this._filter();
                start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1);
                stop = parseInt(o.rows) === -1 ? items.length - 1 : start + o.rows - 1;
            } else if (mode === "all") {
                items = this.items;
                start = 0; stop = items.length - 1;
            } else {
                items = this._filter();
                start = 0; stop = items.length - 1;
            }

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    tr = $("<tr>");

                    cells = items[i];

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        if (Utils.bool(that.view[cell_index].show) === false) {
                            return ;
                        }
                        td = $("<td>").html(this);
                        tds[that.view[cell_index]['index-view']] = td;
                    });

                    for (j = 0; j < cells.length; j++){
                        if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
                    }

                    tr.appendTo(body);
                }
            }

            // switch (to) {
            //     default: Export.tableToCSV(table, filename, options);
            // }
            Export.tableToCSV(table, filename, options);
            table.remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            function dataCheck(){
                o.check = Utils.bool(element.attr("data-check"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            function dataRownum(){
                o.rownum = Utils.bool(element.attr("data-rownum"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            switch (attributeName) {
                case "data-check": dataCheck(); break;
                case "data-rownum": dataRownum(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.closest(".table-component");
            var search_input = component.find("input");
            var rows_select = component.find("select");

            search_input.data("input").destroy();
            rows_select.data("select").destroy();

            $(window).off(Metro.events.resize, {ns: this.id});

            element.off(Metro.events.click, ".sortable-column");

            element.off(Metro.events.click, ".table-service-check input");

            element.off(Metro.events.click, ".table-service-check-all input");

            search_input.off(Metro.events.inputchange);

            if (Utils.isValue(this.wrapperSearch)) {
                var customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");
            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }
            element.off(Metro.events.click, ".js-table-crud-button");

            this._removeInspectorEvents();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MaterialTabsDefaultConfig = {
        materialtabsDeferred: 0,
        deep: false,
        fixedTabs: false,
        duration: 300,
        appBar: false,

        clsComponent: "",
        clsTabs: "",
        clsTab: "",
        clsTabActive: "",
        clsMarker: "",

        onBeforeTabOpen: Metro.noop_true,
        onTabOpen: Metro.noop,
        onTabsScroll: Metro.noop,
        onTabsCreate: Metro.noop
    };

    Metro.materialTabsSetup = function (options) {
        MaterialTabsDefaultConfig = $.extend({}, MaterialTabsDefaultConfig, options);
    };

    if (typeof window["metroMaterialTabsSetup"] !== undefined) {
        Metro.materialTabsSetup(window["metroMaterialTabsSetup"]);
    }

    Metro.Component('material-tabs', {
        init: function( options, elem ) {
            this._super(elem, options, MaterialTabsDefaultConfig, {
                marker: null,
                scroll: 0,
                scrollDir: "left"
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("tabs-create", {
                element: element
            });
        },

        _applyColor: function(to, color, option){

            to = $(to);

            if (Utils.isValue(color)) {
                if (Utils.isColor(color)) {
                    to.css(option, color);
                } else {
                    to.addClass(color);
                }
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var tabs = element.find("li"), active_tab = element.find("li.active");
            var wrapper = $("<div>").addClass("tabs-material-wrapper").addClass(o.clsComponent).insertBefore(element);

            if (o.appBar === true) {
                wrapper.addClass("app-bar-present");
            }
            if (o.appBar === "more") {
                wrapper.addClass("app-bar-present-more");
            }

            element.appendTo(wrapper);
            element.addClass("tabs-material").addClass(o.clsTabs);
            tabs.addClass(o.clsTab);

            if (o.deep === true) {
                element.addClass("deep");
            }

            if (o.fixedTabs === true) {
                element.addClass("fixed-tabs");
            }

            this.marker = element.find(".tab-marker");

            if (this.marker.length === 0) {
                this.marker = $("<span>").addClass("tab-marker").addClass(o.clsMarker).appendTo(element);
            }

            this.openTab(active_tab.length === 0 ? tabs[0] : active_tab[0]);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, "li", function(e){
                var tab = $(this);
                var active_tab = element.find("li.active");
                var tab_next = tab.index() > active_tab.index();
                var target = tab.children("a").attr("href");

                if (Utils.isValue(target) && target[0] === "#") {
                    if (tab.hasClass("active")) return;
                    if (tab.hasClass("disabled")) return;
                    if (Utils.exec(o.onBeforeTabOpen, [tab, target, tab_next], this) === false) return;
                    that.openTab(tab, tab_next);
                    e.preventDefault();
                }
            });

            element.on(Metro.events.scroll, function(){
                var oldScroll = that.scroll;

                that.scrollDir = that.scroll < element[0].scrollLeft ? "left" : "right";
                that.scroll = element[0].scrollLeft;

                that._fireEvent("tabs-scroll", {
                    scrollLeft: element[0].scrollLeft,
                    oldScroll: oldScroll,
                    scrollDir: that.scrollDir
                });

            });
        },

        openTab: function(tab, tab_next){
            var element = this.element, o = this.options;
            var tabs = element.find("li");
            var magic = 52, shift, width, tab_width, target, tab_left, scroll, scrollLeft;

            tab = $(tab);

            $.each(tabs, function(){
                var target = $(this).find("a").attr("href");
                if (!Utils.isValue(target)) return;
                if (target[0] === "#" && target.length > 1) {
                    $(target).hide();
                }
            });

            width = element.width();
            scroll = element.scrollLeft();
            tab_left = tab.position().left;
            tab_width = tab.width();
            shift = tab_left + tab_width;

            tabs.removeClass("active").removeClass(o.clsTabActive);
            tab.addClass("active").addClass(o.clsTabActive);

            if (shift + magic > width + scroll) {
                scrollLeft = scroll + (magic * 2);
            } else if (tab_left < scroll) {
                scrollLeft = tab_left - magic * 2;
            } else {
                scrollLeft = scroll;
            }

            element.animate({
                draw: {
                    scrollLeft: scrollLeft
                },
                dur: o.duration
            });

            this.marker.animate({
                draw: {
                    left: tab_left,
                    width: tab_width
                },
                dur: o.duration
            });

            target = tab.find("a").attr("href");
            if (Utils.isValue(target)) {
                if (target[0] === "#" && target.length > 1) {
                    $(target).show();
                }
            }

            this._fireEvent("tab-open", {
                tab: tab[0],
                target: target,
                tab_next: tab_next
            });
        },

        open: function(tab_num){
            var element = this.element;
            var tabs = element.find("li");
            var active_tab = element.find("li.active");
            var tab = tabs.eq(tab_num - 1);
            var tab_next = tabs.index(tab) > tabs.index(active_tab);
            this.openTab(tab, tab_next);
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, "li");
            element.off(Metro.events.scroll);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Colors = Metro.colors;
    var TabsDefaultConfig = {
        tabsDeferred: 0,
        expand: false,
        expandPoint: null,
        tabsPosition: "top",
        tabsType: "default",

        clsTabs: "",
        clsTabsList: "",
        clsTabsListItem: "",
        clsTabsListItemActive: "",

        onTab: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTabsCreate: Metro.noop
    };

    Metro.tabsSetup = function (options) {
        TabsDefaultConfig = $.extend({}, TabsDefaultConfig, options);
    };

    if (typeof window["metroTabsSetup"] !== undefined) {
        Metro.tabsSetup(window["metroTabsSetup"]);
    }

    Metro.Component('tabs', {
        init: function( options, elem ) {
            this._super(elem, options, TabsDefaultConfig, {
                _targets: [],
                id: Utils.elementId('tabs')
            });

            return this;
        },

        _create: function(){
            var element = this.element;
            var tab = element.find(".active").length > 0 ? $(element.find(".active")[0]) : undefined;

            this._createStructure();
            this._createEvents();
            this._open(tab);

            this._fireEvent("tabs-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var parent = element.parent();
            var right_parent = parent.hasClass("tabs");
            var container = right_parent ? parent : $("<div>").addClass("tabs tabs-wrapper");
            var expandTitle, hamburger;

            container.addClass(o.tabsPosition.replace(["-", "_", "+"], " "));

            element.addClass("tabs-list");
            if (o.tabsType !== "default") {
                element.addClass("tabs-"+o.tabsType);
            }
            if (!right_parent) {
                container.insertBefore(element);
                element.appendTo(container);
            }

            element.data('expanded', false);

            expandTitle = $("<div>").addClass("expand-title"); container.prepend(expandTitle);
            hamburger = container.find(".hamburger");
            if (hamburger.length === 0) {
                hamburger = $("<button>").attr("type", "button").addClass("hamburger menu-down").appendTo(container);
                for(var i = 0; i < 3; i++) {
                    $("<span>").addClass("line").appendTo(hamburger);
                }

                if (Colors.isLight(Utils.computedRgbToHex(Utils.getStyleOne(container, "background-color"))) === true) {
                    hamburger.addClass("dark");
                }
            }

            container.addClass(o.clsTabs);
            element.addClass(o.clsTabsList);
            element.children("li").addClass(o.clsTabsListItem);

            if (o.expand === true && !o.tabsPosition.contains("vertical")) {
                container.addClass("tabs-expand");
            } else {
                if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.contains("vertical")) {
                    container.addClass("tabs-expand");
                }
            }

            if (o.tabsPosition.contains("vertical")) {
                container.addClass("tabs-expand");
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();

            $(window).on(Metro.events.resize, function(){

                if (o.tabsPosition.contains("vertical")) {
                    return ;
                }

                if (o.expand === true && !o.tabsPosition.contains("vertical")) {
                    container.addClass("tabs-expand");
                } else {
                    if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.contains("vertical")) {
                        if (!container.hasClass("tabs-expand")) container.addClass("tabs-expand");
                    } else {
                        if (container.hasClass("tabs-expand")) container.removeClass("tabs-expand");
                    }
                }
            }, {ns: this.id});

            container.on(Metro.events.click, ".hamburger, .expand-title", function(){
                if (element.data('expanded') === false) {
                    element.addClass("expand");
                    element.data('expanded', true);
                    container.find(".hamburger").addClass("active");
                } else {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }
            });

            element.on(Metro.events.click, "a", function(e){
                var link = $(this);
                var href = link.attr("href").trim();
                var tab = link.parent("li");

                if (tab.hasClass("active")) {
                    e.preventDefault();
                }

                if (element.data('expanded') === true) {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }

                if (Utils.exec(o.onBeforeTab, [tab, element], tab[0]) !== true) {
                    return false;
                }

                if (Utils.isValue(href) && href[0] === "#") {
                    that._open(tab);
                    e.preventDefault();
                }
            });
        },

        _collectTargets: function(){
            var that = this, element = this.element;
            var tabs = element.find("li");

            this._targets = [];

            $.each(tabs, function(){
                var target = $(this).find("a").attr("href").trim();
                if (target.length > 1 && target[0] === "#") {
                    that._targets.push(target);
                }
            });
        },

        _open: function(tab){
            var element = this.element, o = this.options;
            var tabs = element.find("li");
            var expandTitle = element.siblings(".expand-title");


            if (tabs.length === 0) {
                return;
            }

            this._collectTargets();

            if (tab === undefined) {
                tab = $(tabs[0]);
            }

            var target = tab.find("a").attr("href");

            if (target === undefined) {
                return;
            }

            tabs.removeClass("active").removeClass(o.clsTabsListItemActive);
            if (tab.parent().hasClass("d-menu")) {
                tab.parent().parent().addClass("active");
            } else {
                tab.addClass("active");
            }

            $.each(this._targets, function(){
                var t = $(this);
                if (t.length > 0) t.hide();
            });

            if (target !== "#" && target[0] === "#") {
                $(target).show();
            }

            expandTitle.html(tab.find("a").html());

            tab.addClass(o.clsTabsListItemActive);

            this._fireEvent("tab", {
                tab: tab[0]
            });
        },

        next: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.next("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        prev: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.prev("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        open: function(tab){
            var element = this.element;
            var tabs = element.find("li");

            if (!Utils.isValue(tab)) {
                tab = 1;
            }

            if (Utils.isInt(tab)) {
                if (Utils.isValue(tabs[tab-1])) this._open($(tabs[tab-1]));
            } else {
                this._open($(tab));
            }
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();

            $(window).off(Metro.events.resize,{ns: this.id});

            container.off(Metro.events.click, ".hamburger, .expand-title");

            element.off(Metro.events.click, "a");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Colors = Metro.colors;
    var Utils = Metro.utils;
    var TagInputDefaultConfig = {
        label: "",
        size: "normal",
        taginputDeferred: 0,
        static: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",

        randomColor: false,
        maxTags: 0,
        tagSeparator: ",",
        tagTrigger: "Enter, Space, Comma",
        backspace: true,

        clsComponent: "",
        clsInput: "",
        clsClearButton: "",
        clsTag: "",
        clsTagTitle: "",
        clsTagRemover: "",
        clsLabel: "",

        onBeforeTagAdd: Metro.noop_true,
        onTagAdd: Metro.noop,
        onBeforeTagRemove: Metro.noop_true,
        onTagRemove: Metro.noop,
        onTag: Metro.noop,
        onClear: Metro.noop,
        onTagTrigger: Metro.noop,
        onTagInputCreate: Metro.noop
    };

    Metro.tagInputSetup = function (options) {
        TagInputDefaultConfig = $.extend({}, TagInputDefaultConfig, options);
    };

    if (typeof window["metroTagInputSetup"] !== undefined) {
        Metro.tagInputSetup(window["metroTagInputSetup"]);
    }

    Metro.Component('tag-input', {
        init: function( options, elem ) {
            this._super(elem, options, TagInputDefaultConfig, {
                values: [],
                triggers: []
            });

            return this;
        },

        _create: function(){
            this.triggers = (""+this.options.tagTrigger).toArray(",");

            if (this.triggers.contains("Space") || this.triggers.contains("Spacebar")) {
                this.triggers.push(" ");
                this.triggers.push("Spacebar");
            }

            if (this.triggers.contains("Comma")) {
                this.triggers.push(",");
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("tag-input-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container, input, clearButton;
            var values = element.val().trim();

            container = $("<div>").addClass("tag-input "  + element[0].className).addClass(o.clsComponent).insertBefore(element);
            element.appendTo(container);

            container.addClass("input-" + o.size)

            element[0].className = "";

            element.addClass("original-input");
            input = $("<input type='text'>").addClass("input-wrapper").addClass(o.clsInput).attr("size", 1);
            input.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                container.addClass("padding-for-clear");
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (Utils.isValue(values)) {
                $.each(values.toArray(o.tagSeparator), function(){
                    that._addTag(this);
                })
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            if (o.static === true || element.attr("readonly") !== undefined) {
                container.addClass("static-mode");
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");

            input.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            input.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            input.on(Metro.events.inputchange, function(){
                input.attr("size", Math.ceil(input.val().length / 2) + 2);
            });

            input.on(Metro.events.keydown, function(e){
                var val = input.val().trim();
                var key = e.key;

                if (key === "Enter") e.preventDefault();

                if (o.backspace === true && key === "Backspace" && val.length === 0) {
                    if (that.values.length > 0) {
                        that.values.splice(-1,1);
                        element.siblings(".tag").last().remove();
                        element.val(that.values.join(o.tagSeparator));
                    }
                    return ;
                }

                if (val === "") {return ;}

                if (!that.triggers.contains(key)) {
                    return ;
                }

                that._fireEvent("tag-trigger", {
                    key: key
                });

                input.val("");
                that._addTag(val);
                input.attr("size", 1);
            });

            input.on(Metro.events.keyup, function(e){
                var val = input.val();
                var key = e.key;

                if (that.triggers.contains(key) && val[val.length - 1] === key) {
                    input.val(val.slice(0, -1));
                }
            });

            container.on(Metro.events.click, ".tag .remover", function(){
                var tag = $(this).closest(".tag");
                that._delTag(tag);
            });

            container.on(Metro.events.click, function(){
                input.focus();
            });

            container.on(Metro.events.click, ".input-clear-button", function(){
                var val = element.val();
                that.clear();

                that._fireEvent("clear", {
                    val: val
                });
            });
        },

        _addTag: function(val){
            var element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");
            var tag, title, remover;
            var tagSize, tagStatic;

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            if (o.maxTags > 0 && this.values.length === o.maxTags) {
                return ;
            }

            if ((""+val).trim() === "") {
                return ;
            }

            if (!Utils.exec(o.onBeforeTagAdd, [val, this.values], element[0])) {
                return ;
            }


            tag = $("<span>")
                .addClass("tag")
                .addClass(tagSize)
                .addClass(o.clsTag)
                .insertBefore(input);
            tag.data("value", val);

            tagStatic = o.static || container.hasClass("static-mode") || element.readonly || element.disabled || container.hasClass("disabled");
            if (tagStatic) {
                tag.addClass("static");
            }

            title = $("<span>").addClass("title").addClass(o.clsTagTitle).html(val);
            remover = $("<span>").addClass("remover").addClass(o.clsTagRemover).html("&times;");

            title.appendTo(tag);
            remover.appendTo(tag);

            if (o.randomColor === true) {
                var colors = Colors.colors(Colors.PALETTES.ALL), bg, fg, bg_r;

                bg = colors[$.random(0, colors.length - 1)];
                bg_r = Colors.darken(bg, 15);
                fg = Colors.isDark(bg) ? "#ffffff" : "#000000";

                tag.css({
                    backgroundColor: bg,
                    color: fg
                });
                remover.css({
                    backgroundColor: bg_r,
                    color: fg
                });
            }

            this.values.push(val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-add", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });
        },

        _delTag: function(tag) {
            var element = this.element, o = this.options;
            var val = tag.data("value");

            if (!Utils.exec(o.onBeforeTagRemove, [tag, val, this.values], element[0])) {
                return ;
            }

            Utils.arrayDelete(this.values, val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-remove", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            tag.remove();
        },

        tags: function(){
            return this.values;
        },

        val: function(v){
            var that = this, o = this.options;

            if (!Utils.isValue(v)) {
                return this.tags();
            }

            this.values = [];

            if (Utils.isValue(v)) {
                $.each((""+v).toArray(o.tagSeparator), function(){
                    that._addTag(this);
                })
            }
        },

        clear: function(){
            var element = this.element;
            var container = element.closest(".tag-input");

            this.values = [];

            element.val("").trigger("change");

            container.find(".tag").remove();
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleStatic: function(val){
            var container = this.element.closest(".tag-input");
            var staticMode;

            if (Utils.isValue(val)) {
                staticMode = Utils.bool(val);
            } else {
                staticMode = !container.hasClass("static-mode");
            }

            if (staticMode) {
                container.addClass("static-mode");
            } else {
                container.removeClass("static-mode");
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeValue = function(){
                var val = element.attr("value").trim();
                that.clear();
                if (!Utils.isValue(val)) {
                    return ;
                }
                that.val(val.toArray(o.tagSeparator));
            };

            switch (attributeName) {
                case "value": changeValue(); break;
                case "disabled": this.toggleState(); break;
                case "static": this.toggleStatic(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");

            input.off(Metro.events.focus);
            input.off(Metro.events.blur);
            input.off(Metro.events.keydown);
            container.off(Metro.events.click, ".tag .remover");
            container.off(Metro.events.click);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;

    var Engine = function(html, options, conf) {
        var ReEx, re = '<%(.+?)%>',
            reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,
            code = 'with(obj) { var r=[];\n',
            cursor = 0,
            result,
            match;
        var add = function(line, js) {
            /* jshint -W030 */
            js? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
                (code += line !== '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
            return add;
        };

        if (Utils.isValue(conf)) {
            if (($.hasProp(conf, 'beginToken'))) {
                re = re.replace('<%', conf.beginToken);
            }
            if (($.hasProp(conf,'endToken'))) {
                re = re.replace('%>', conf.endToken);
            }
        }

        ReEx = new RegExp(re, 'g');
        match = ReEx.exec(html);

        while(match) {
            add(html.slice(cursor, match.index))(match[1], true);
            cursor = match.index + match[0].length;
            match = ReEx.exec(html);
        }
        add(html.substr(cursor, html.length - cursor));
        code = (code + 'return r.join(""); }').replace(/[\r\t\n]/g, ' ');
        /* jshint -W054 */
        try { result = new Function('obj', code).apply(options, [options]); }
        catch(err) { console.error("'" + err.message + "'", " in \n\nCode:\n", code, "\n"); }
        return result;
    };

    var TemplateDefaultConfig = {
        templateData: null,
        onTemplateCompile: Metro.noop,
        onTemplateCreate: Metro.noop
    };

    Metro.templateSetup = function (options) {
        TemplateDefaultConfig = $.extend({}, TemplateDefaultConfig, options);
    };

    if (typeof window["metroTemplateSetup"] !== undefined) {
        Metro.templateSetup(window["metroTemplateSetup"]);
    }

    Metro.Component('template', {
        init: function( options, elem ) {
            this._super(elem, options, TemplateDefaultConfig, {
                template: null,
                data: {}
            });
            return this;
        },

        _compile: function(){
            var element = this.element;
            var template, compiled;

            template = this.template
                .replace(/(&lt;%)/gm, "<%")
                .replace(/(%&gt;)/gm, "%>")
                .replace(/(&lt;)/gm, "<")
                .replace(/(&gt;)/gm, ">");

            compiled = Engine(template, this.data);
            element.html(compiled);

            this._fireEvent('template-compile', {
                template: template,
                compiled: compiled,
                element: element
            });
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.template = element.html();
            this.data = Utils.isObject(o.templateData) || {};
            this._compile();
            this._fireEvent('template-create', {
                element: element
            });
        },

        buildWith: function(obj){
            var data = Utils.isObject(obj);
            if (!data) {
                return;
            }
            this.data = data;
            this._compile();
        },

        changeAttribute: function(a, v){
            if (a === "data-template-data") {
                this.options.templateData = v;
                this.data = Utils.isObject(v) || {};
                this._compile();
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.template = Engine;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TextareaDefaultConfig = {
        label: "",
        textareaDeferred: 0,
        charsCounter: null,
        charsCounterTemplate: "$1",
        defaultValue: "",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        autoSize: true,
        maxHeight: 0,
        clsPrepend: "",
        clsAppend: "",
        clsComponent: "",
        clsTextarea: "",
        clsLabel: "",
        onChange: Metro.noop,
        onTextareaCreate: Metro.noop
    };

    Metro.textareaSetup = function (options) {
        TextareaDefaultConfig = $.extend({}, TextareaDefaultConfig, options);
    };

    if (typeof window["metroTextareaSetup"] !== undefined) {
        Metro.textareaSetup(window["metroTextareaSetup"]);
    }

    Metro.Component('textarea', {
        init: function( options, elem ) {
            this._super(elem, options, TextareaDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("textarea-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, elem = this.elem, o = this.options;
            var container = $("<div>").addClass("textarea " + element[0].className);
            var fakeTextarea = $("<textarea>").addClass("fake-textarea");
            var clearButton;

            container.insertBefore(element);
            element.appendTo(container);
            fakeTextarea.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "") {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
                clearButton.css({
                    right: append.outerWidth() + 4
                });
            }

            elem.className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = elem.style.length; i < l; i++) {
                    container.css(elem.style[i], element.css(elem.style[i]));
                }
            }

            if (Utils.isValue(o.defaultValue) && element.val().trim() === "") {
                element.val(o.defaultValue);
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsTextarea);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            fakeTextarea.val(element.val());

            if (o.autoSize === true) {
                container.addClass("autosize no-scroll-vertical");

                setTimeout(function(){
                    that.resize();
                }, 100);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var textarea = element.closest(".textarea");
            var fakeTextarea = textarea.find(".fake-textarea");
            var chars_counter = $(o.charsCounter);

            textarea.on(Metro.events.click, ".input-clear-button", function(){
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").trigger('change').trigger('keyup').focus();
            });

            if (o.autoSize) {
                element.on(Metro.events.inputchange + " " + Metro.events.keyup, function(){
                    fakeTextarea.val(this.value);
                    that.resize();
                });
            }

            element.on(Metro.events.blur, function(){textarea.removeClass("focused");});
            element.on(Metro.events.focus, function(){textarea.addClass("focused");});

            element.on(Metro.events.keyup, function(){
                if (Utils.isValue(o.charsCounter) && chars_counter.length > 0) {
                    if (chars_counter[0].tagName === "INPUT") {
                        chars_counter.val(that.length());
                    } else {
                        chars_counter.html(o.charsCounterTemplate.replace("$1", that.length()));
                    }
                }

                that._fireEvent("change", {
                    val: element.val(),
                    length: that.length()
                });

            })
        },

        resize: function(){
            var element = this.element, o = this.options,
                textarea = element.closest(".textarea"),
                fakeTextarea = textarea.find(".fake-textarea"),
                currentHeight = fakeTextarea[0].scrollHeight;

            if (o.maxHeight && currentHeight >= o.maxHeight) {
                textarea.removeClass("no-scroll-vertical");
                return ;
            }

            if (o.maxHeight && currentHeight < o.maxHeight) {
                textarea.addClass("no-scroll-vertical");
            }

            fakeTextarea[0].style.cssText = 'height:auto;';
            fakeTextarea[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
            element[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
        },

        clear: function(){
            this.element.val("").trigger('change').trigger('keyup').focus();
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "").trigger('change').trigger('keyup').focus();
        },

        length: function(){
            var characters = this.elem.value.split('');
            return characters.length;
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var textarea = element.closest(".textarea");

            textarea.off(Metro.events.click, ".input-clear-button");

            if (o.autoSize) {
                element.off(Metro.events.inputchange + " " + Metro.events.keyup);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            element.off(Metro.events.keyup);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide-up", "slide-down", "slide-left", "slide-right", "fade", "zoom", "swirl", "switch"
    ];
    var TileDefaultConfig = {
        tileDeferred: 0,
        size: "medium",
        cover: "",
        coverPosition: "center",
        effect: "", // slide-up, slide-down, slide-left, slide-right, fade, zoom, swirl, switch
        effectInterval: 3000,
        effectDuration: 500,
        target: null,
        canTransform: true,
        onClick: Metro.noop,
        onTileCreate: Metro.noop
    };

    Metro.tileSetup = function (options) {
        TileDefaultConfig = $.extend({}, TileDefaultConfig, options);
    };

    if (typeof window["metroTileSetup"] !== undefined) {
        Metro.tileSetup(window["metroTileSetup"]);
    }

    Metro.Component('tile', {
        init: function( options, elem ) {
            this._super(elem, options, TileDefaultConfig, {
                effectInterval: false,
                images: [],
                slides: [],
                currentSlide: -1,
                unload: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createTile();
            this._createEvents();

            this._fireEvent("tile-create", {
                element: element
            });
        },

        _createTile: function(){
            function switchImage(el, img_src, i){
                $.setTimeout(function(){
                    el.fadeOut(500, function(){
                        el.css("background-image", "url(" + img_src + ")");
                        el.fadeIn();
                    });
                }, i * 300);
            }

            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides2 = element.find(".slide-front, .slide-back");

            element.addClass("tile-" + o.size);

            if (o.effect.indexOf("hover-") > -1) {
                element.addClass("effect-" + o.effect);
                $.each(slides2, function(){
                    var slide = $(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }
                })
            }

            if (effects.includes(o.effect) && slides.length > 1) {
                $.each(slides, function(i){
                    var slide = $(this);

                    that.slides.push(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }

                    if (i > 0) {
                        if (["slide-up", "slide-down"].indexOf(o.effect) > -1) slide.css("top", "100%");
                        if (["slide-left", "slide-right"].indexOf(o.effect) > -1) slide.css("left", "100%");
                        if (["fade", "zoom", "swirl", "switch"].indexOf(o.effect) > -1) slide.css("opacity", 0);
                    }
                });

                this.currentSlide = 0;

                this._runEffects();
            }

            if (o.cover !== "") {
                this._setCover(element, o.cover);
            }

            if (o.effect === "image-set") {
                element.addClass("image-set");

                $.each(element.children("img"), function(){
                    that.images.push(this);
                    $(this).remove();
                });

                var temp = this.images.slice();

                for(var i = 0; i < 5; i++) {
                    var rnd_index = $.random(0, temp.length - 1);
                    var div = $("<div>").addClass("img -js-img-"+i).css("background-image", "url("+temp[rnd_index].src+")");
                    element.prepend(div);
                    temp.splice(rnd_index, 1);
                }

                var a = [0, 1, 4, 3, 2];

                $.setInterval(function(){
                    var temp = that.images.slice();
                    var bg = Utils.randomColor();

                    element.css("background-color", bg);

                    for(var i = 0; i < a.length; i++) {
                        var rnd_index = $.random(0, temp.length - 1);
                        var div = element.find(".-js-img-"+a[i]);
                        switchImage(div, temp[rnd_index].src, i);
                        temp.splice(rnd_index, 1);
                    }

                    a = a.reverse();
                }, 5000);
            }
        },

        _runEffects: function(){
            var that = this, o = this.options;

            if (this.effectInterval === false) this.effectInterval = $.setInterval(function(){
                var current, next;

                current = $(that.slides[that.currentSlide]);

                that.currentSlide++;
                if (that.currentSlide === that.slides.length) {
                    that.currentSlide = 0;
                }

                next = that.slides[that.currentSlide];

                
                if (effects.includes(o.effect)) {
                    Metro.animations[o.effect.camelCase()]($(current), $(next), {duration: o.effectDuration});
                }

                // if (o.effect === "slide-up") Metro.animations.slideUp($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "slide-down") Metro.animations.slideDown($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "slide-left") Metro.animations.slideLeft($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "slide-right") Metro.animations.slideRight($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "fade") Metro.animations.fade($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "zoom") Metro.animations.zoom($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "swirl") Metro.animations.swirl($(current), $(next), {duration: o.effectDuration});
                // if (o.effect === "switch") Metro.animations.swirl($(current), $(next), {duration: o.effectDuration});

            }, o.effectInterval);
        },

        _stopEffects: function(){
            $.clearInterval(this.effectInterval);
            this.effectInterval = false;
        },

        _setCover: function(to, src, pos){
            if (!Utils.isValue(pos)) {
                pos = this.options.coverPosition;
            }
            to.css({
                backgroundImage: "url("+src+")",
                backgroundSize: "cover",
                backgroundRepeat: "no-repeat",
                backgroundPosition: pos
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.startAll, function(e){
                var tile = $(this);
                var dim = {w: element.width(), h: element.height()};
                var X = Utils.pageXY(e).x - tile.offset().left,
                    Y = Utils.pageXY(e).y - tile.offset().top;
                var side;

                if (Utils.isRightMouse(e) === false) {

                    if (X < dim.w * 1 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'left';
                    } else if (X > dim.w * 2 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'right';
                    } else if (X > dim.w * 1 / 3 && X < dim.w * 2 / 3 && Y > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (o.canTransform === true) tile.addClass("transform-" + side);

                    if (o.target !== null) {
                        setTimeout(function(){
                            document.location.href = o.target;
                        }, 100);
                    }

                    that._fireEvent("click", {
                        side: side
                    });
                }
            });

            element.on([Metro.events.stopAll, Metro.events.leave].join(" "), function(){
                $(this)
                    .removeClass("transform-left")
                    .removeClass("transform-right")
                    .removeClass("transform-top")
                    .removeClass("transform-bottom");
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.startAll);

            element.off([Metro.events.stopAll, Metro.events.leave].join(" "));

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TimePickerDefaultConfig = {
        label: "",
        timepickerDeferred: 0,
        hoursStep: 1,
        minutesStep: 1,
        secondsStep: 1,
        value: null,
        locale: METRO_LOCALE,
        distance: 3,
        hours: true,
        minutes: true,
        seconds: true,
        showLabels: true,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        clsLabel: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onTimePickerCreate: Metro.noop
    };

    Metro.timePickerSetup = function (options) {
        TimePickerDefaultConfig = $.extend({}, TimePickerDefaultConfig, options);
    };

    if (typeof window["metroTimePickerSetup"] !== undefined) {
        Metro.timePickerSetup(window["metroTimePickerSetup"]);
    }

    Metro.Component('time-picker', {
        init: function( options, elem ) {
            this._super(elem, options, TimePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: [],
                locale: Metro.locales[METRO_LOCALE]['calendar'],
                listTimer: {
                    hours: null,
                    minutes: null,
                    seconds: null
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i;

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (o.hoursStep < 1) {o.hoursStep = 1;}
            if (o.hoursStep > 23) {o.hoursStep = 23;}

            if (o.minutesStep < 1) {o.minutesStep = 1;}
            if (o.minutesStep > 59) {o.minutesStep = 59;}

            if (o.secondsStep < 1) {o.secondsStep = 1;}
            if (o.secondsStep > 59) {o.secondsStep = 59;}

            if (element.val() === "" && (!Utils.isValue(o.value))) {
                o.value = (new Date()).format("%H:%M:%S");
            }

            this.value = (element.val() !== "" ? element.val() : ""+o.value).toArray(":");

            for(i = 0; i < 3; i++) {
                if (this.value[i] === undefined || this.value[i] === null) {
                    this.value[i] = 0;
                } else {
                    this.value[i] = parseInt(this.value[i]);
                }
            }

            this._normalizeValue();

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("time-picker-create", {
                element: element
            });
        },

        _normalizeValue: function(){
            var o = this.options;

            if (o.hoursStep > 1) {
                this.value[0] = Utils.nearest(this.value[0], o.hoursStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[1] = Utils.nearest(this.value[1], o.minutesStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[2] = Utils.nearest(this.value[2], o.secondsStep, true);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, hours, minutes, seconds, i;
            var timeWrapper, selectWrapper, selectBlock, actionBlock;

            var id = Utils.elementId("time-picker");

            picker = $("<div>").attr("id", id).addClass("wheel-picker time-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.attr("readonly", true).appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            timeWrapper = $("<div>").addClass("time-wrapper").appendTo(picker);

            if (o.hours === true) {
                hours = $("<div>").attr("data-title", this.locale['time']['hours']).addClass("hours").addClass(o.clsPart).addClass(o.clsHours).appendTo(timeWrapper);
            }
            if (o.minutes === true) {
                minutes = $("<div>").attr("data-title", this.locale['time']['minutes']).addClass("minutes").addClass(o.clsPart).addClass(o.clsMinutes).appendTo(timeWrapper);
            }
            if (o.seconds === true) {
                seconds = $("<div>").attr("data-title", this.locale['time']['seconds']).addClass("seconds").addClass(o.clsPart).addClass(o.clsSeconds).appendTo(timeWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);
            if (o.hours === true) {
                hours = $("<ul>").addClass("sel-hours").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
                for (i = 0; i < 24; i = i + o.hoursStep) {
                    $("<li>").addClass("js-hours-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(hours);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
            }
            if (o.minutes === true) {
                minutes = $("<ul>").addClass("sel-minutes").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
                for (i = 0; i < 60; i = i + o.minutesStep) {
                    $("<li>").addClass("js-minutes-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(minutes);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
            }
            if (o.seconds === true) {
                seconds = $("<ul>").addClass("sel-seconds").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
                for (i = 0; i < 60; i = i + o.secondsStep) {
                    $("<li>").addClass("js-seconds-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(seconds);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.showLabels === true) {
                picker.addClass("show-labels");
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: picker.attr("id")});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: picker.attr("id")});
                    $(document).off(Metro.events.stop, {ns: picker.attr("id")});
                }, {ns: picker.attr("id")});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var h, m, s;
                var sh = picker.find(".sel-hours li.active"),
                    sm = picker.find(".sel-minutes li.active"),
                    ss = picker.find(".sel-seconds li.active");

                h = sh.length === 0 ? 0 : sh.data("value");
                m = sm.length === 0 ? 0 : sm.data("value");
                s = ss.length === 0 ? 0 : ss.data("value");

                that.value = [h, m, s];
                that._normalizeValue();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(['hours', 'minutes', 'seconds'], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (that.isOpen) {
                        if (that.listTimer[part]) {
                            clearTimeout(that.listTimer[part]);
                            that.listTimer[part] = null;
                        }

                        if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                            var target, targetElement, scrollTop;

                            that.listTimer[part] = null;

                            target = Math.round((Math.ceil(list.scrollTop()) / 40));

                            targetElement = list.find(".js-" + part + "-" + target);
                            scrollTop = targetElement.position().top - (o.distance * 40);

                            list.find(".active").removeClass("active");

                            list[0].scrollTop = scrollTop;
                            targetElement.addClass("active");
                            Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                        }, scrollLatency);
                    }
                })
            });
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var h = "00", m = "00", s = "00";

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                if (h < 10) {
                    h = "0"+h;
                }
                picker.find(".hours").html(h);
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                if (m < 10) {
                    m = "0"+m;
                }
                picker.find(".minutes").html(m);
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                if (s < 10) {
                    s = "0"+s;
                }
                picker.find(".seconds").html(s);
            }

            element.val([h, m, s].join(":")).trigger("change");

            this._fireEvent("set", {
                val: this.value,
                elementVal: element.val()
            });

        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var h, m, s;
            var h_list, m_list, s_list;
            var items = picker.find("li");
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;
            var h_item, m_item, s_item;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            items.removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            var animateList = function(list, item){
                list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: item.position().top - (o.distance * 40) + list.scrollTop()
                        },
                        dur: 100
                    });
            };

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                h_list = picker.find(".sel-hours");
                h_item = h_list.find("li.js-hours-" + h).addClass("active");
                animateList(h_list, h_item);
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                m_list = picker.find(".sel-minutes");
                m_item = m_list.find("li.js-minutes-" + m).addClass("active");
                animateList(m_list, m_item);
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                s_list = picker.find(".sel-seconds");
                s_item = s_list.find("li.js-seconds-" + s).addClass("active");
                animateList(s_list, s_item);
            }

            this.isOpen = true;

            this._fireEvent("open", {
                val: this.value
            });

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                val: this.value
            });
        },

        _convert: function(t){
            var result;

            if (Array.isArray(t)) {
                result = t;
            } else if (typeof  t.getMonth === 'function') {
                result = [t.getHours(), t.getMinutes(), t.getSeconds()];
            } else if (Utils.isObject(t)) {
                result = [t.h, t.m, t.s];
            } else {
                result = t.toArray(":");
            }

            return result;
        },

        val: function(t){
            if (t === undefined) {
                return this.element.val();
            }
            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        time: function(t){
            if (t === undefined) {
                return {
                    h: this.value[0],
                    m: this.value[1],
                    s: this.value[2]
                }
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        date: function(t){
            if (t === undefined || typeof t.getMonth !== 'function') {
                var ret = new Date();
                ret.setHours(this.value[0]);
                ret.setMinutes(this.value[1]);
                ret.setSeconds(this.value[2]);
                ret.setMilliseconds(0);
                return ret;
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attr, newValue){
            switch (attr) {
                case "data-value":
                    this.val(newValue);
                    break;
                case "disabled":
                    this.toggleState();
                    break;
            }
        },

        destroy: function(){
            var element = this.element;
            var picker = this.picker;

            $.each(['hours', 'minutes', 'seconds'], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }

    });

    $(document).on(Metro.events.click, function(){
        $.each($(".time-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "timepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ToastDefaultConfig = {
        callback: Metro.noop,
        timeout: METRO_TIMEOUT,
        distance: 20,
        showTop: false,
        clsToast: ""
    };

    Metro.toastSetup = function(options){
        ToastDefaultConfig = $.extend({}, ToastDefaultConfig, options);
    };

    if (typeof window["metroToastSetup"] !== undefined) {
        Metro.toastSetup(window["metroToastSetup"]);
    }

    var Toast = {
        create: function(message, /*callback, timeout, cls, */options){
            var o, toast, width;
            var args = Array.from(arguments);
            var timeout, callback, cls;

            if (!$.isPlainObject(options)) {
                options = args[4];
                callback = args[1];
                timeout = args[2];
                cls = args[3];
            }

            o = $.extend({}, ToastDefaultConfig, options);

            toast = $("<div>").addClass("toast").html(message).appendTo($("body"));
            width = toast.outerWidth();
            toast.hide();

            timeout = timeout || o.timeout;
            callback = callback || o.callback;
            cls = cls || o.clsToast;

            if (o.showTop === true) {
                toast.addClass("show-top").css({
                    top: o.distance
                });
            } else {
                toast.css({
                    bottom: o.distance
                })
            }

            toast
                .css({
                    'left': '50%',
                    'margin-left': -(width / 2)
                })
                .addClass(o.clsToast)
                .addClass(cls)
                .fadeIn(METRO_ANIMATION_DURATION, function(){
                    setTimeout(function(){
                        Toast.remove(toast, callback);
                    }, timeout);
                });
        },

        remove: function(toast, cb){
            if (!toast) return ;

            toast.fadeOut(METRO_ANIMATION_DURATION, function(){
                toast.remove();
                Utils.exec(cb, null, toast[0]);
            });
        }
    };

    Metro['toast'] = Toast;
    Metro['createToast'] = Toast.create;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var TokenizerDefaultConfig = {
        textToTokenize: "",
        spaceSymbol: "",
        spaceClass: "space",
        tokenClass: "",
        splitter: "",
        tokenElement: "span",
        useTokenSymbol: true,
        useTokenIndex: true,
        clsTokenizer: "",
        clsToken: "",
        clsTokenOdd: "",
        clsTokenEven: "",
        onTokenCreate: Metro.noop,
        onTokenize: Metro.noop,
        onTokenizerCreate: Metro.noop
    };

    Metro.tokenizerSetup = function (options) {
        TokenizerDefaultConfig = $.extend({}, TokenizerDefaultConfig, options);
    };

    if (typeof window["metroTokenizerSetup"] !== undefined) {
        Metro.tokenizerSetup(window["metroTokenizerSetup"]);
    }

    Metro.Component('tokenizer', {
        init: function( options, elem ) {
            this._super(elem, options, TokenizerDefaultConfig, {
                // define instance vars here
                originalText: ""
            });
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.originalText = o.textToTokenize ? o.textToTokenize.trim() : element.text().trim().replace(/[\r\n\t]/gi, '').replace(/\s\s+/g, " ");

            this._createStructure();
            this._fireEvent('tokenizer-create');
        },

        _tokenize: function(){
            var that = this, element = this.element, o = this.options;
            var index = 0, append, prepend;

            element.clear().attr("aria-label", this.originalText);

            $.each(this.originalText.split(o.splitter), function(i){
                var symbol = this;
                var isSpace = symbol === " ";
                var token;

                token = $("<"+o.tokenElement+">")
                    .html(isSpace ? o.spaceSymbol : symbol)
                    .attr("aria-hidden", true)
                    .addClass(isSpace ? o.spaceClass : "")
                    .addClass(isSpace && o.useTokenSymbol ? "" : "ts-"+symbol.replace(" ", "_"))
                    .addClass(isSpace && o.useTokenIndex ? "" : "ti-" + (i + 1))
                    .addClass(o.tokenClass ? o.tokenClass : "")
                    .addClass(!isSpace ? o.clsToken : "");

                if (!isSpace) {
                    index++;
                    token.addClass(index % 2 === 0 ? "te-even" : "te-odd");
                    token.addClass(index % 2 === 0 ? o.clsTokenEven : o.clsTokenOdd);
                }

                if (o.prepend) {
                    prepend = $.isSelector(o.prepend) ? $(o.prepend) : $("<span>").html(o.prepend);
                    token.prepend(prepend);
                }

                if (o.append) {
                    append = $.isSelector(o.append) ? $(o.append) : $("<span>").html(o.append);
                    token.append(append);
                }

                element.append(token);

                that._fireEvent("token-create", {
                    token: token[0]
                });
            });

            that._fireEvent("tokenize", {
                tokens: element.children().items(),
                originalText: this.originalText
            });
        },

        _createStructure: function(){
            var element = this.element,  o = this.options;
            element.addClass(o.clsTokenizer);
            this._tokenize();
        },

        tokenize: function(v){
            this.originalText = v;
            this._tokenize();
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TouchConst = {
        LEFT : "left",
        RIGHT : "right",
        UP : "up",
        DOWN : "down",
        IN : "in",
        OUT : "out",
        NONE : "none",
        AUTO : "auto",
        SWIPE : "swipe",
        PINCH : "pinch",
        TAP : "tap",
        DOUBLE_TAP : "doubletap",
        LONG_TAP : "longtap",
        HOLD : "hold",
        HORIZONTAL : "horizontal",
        VERTICAL : "vertical",
        ALL_FINGERS : "all",
        DOUBLE_TAP_THRESHOLD : 10,
        PHASE_START : "start",
        PHASE_MOVE : "move",
        PHASE_END : "end",
        PHASE_CANCEL : "cancel",
        SUPPORTS_TOUCH : 'ontouchstart' in window,
        SUPPORTS_POINTER_IE10 : window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !('ontouchstart' in window),
        SUPPORTS_POINTER : (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !('ontouchstart' in window),
        IN_TOUCH: "intouch"
    };

    var TouchDefaultConfig = {
        touchDeferred: 0,
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: true,
        excludedElements: ".no-swipe",
        preventDefaultEvents: true,

        onSwipe: Metro.noop,
        onSwipeLeft: Metro.noop,
        onSwipeRight: Metro.noop,
        onSwipeUp: Metro.noop,
        onSwipeDown: Metro.noop,
        onSwipeStatus: Metro.noop_true, // params: phase, direction, distance, duration, fingerCount, fingerData, currentDirection
        onPinchIn: Metro.noop,
        onPinchOut: Metro.noop,
        onPinchStatus: Metro.noop_true,
        onTap: Metro.noop,
        onDoubleTap: Metro.noop,
        onLongTap: Metro.noop,
        onHold: Metro.noop,

        onTouchCreate: Metro.noop
    };

    Metro.touchSetup = function (options) {
        TouchDefaultConfig = $.extend({}, TouchDefaultConfig, options);
    };

    if (typeof window["metroTouchSetup"] !== undefined) {
        Metro.touchSetup(window["metroTouchSetup"]);
    }

    Metro.Component('touch', {
        init: function( options, elem ) {
            this._super(elem, options, TouchDefaultConfig, {
                useTouchEvents: null,
                START_EV: null,
                MOVE_EV: null,
                END_EV: null,
                LEAVE_EV: null,
                CANCEL_EV: null,

                distance: 0,
                direction: null,
                currentDirection: null,
                duration: 0,
                startTouchesDistance: 0,
                endTouchesDistance: 0,
                pinchZoom: 1,
                pinchDistance: 0,
                pinchDirection: 0,
                maximumsMap: null,

                phase: "start",

                fingerCount: 0,

                fingerData: {},

                startTime: 0,
                endTime: 0,
                previousTouchEndTime: 0,
                fingerCountAtRelease: 0,
                doubleTapStartTime: 0,

                singleTapTimeout: null,
                holdTimeout: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            this.useTouchEvents = (TouchConst.SUPPORTS_TOUCH || TouchConst.SUPPORTS_POINTER || !this.options.fallbackToMouseEvents);
            this.START_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown') : 'touchstart') : 'mousedown';
            this.MOVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove') : 'touchmove') : 'mousemove';
            this.END_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup') : 'touchend') : 'mouseup';
            this.LEAVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? 'mouseleave' : null) : 'mouseleave'; //we manually detect leave on touch devices, so null event here
            this.CANCEL_EV = (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel') : 'touchcancel');

            if (o.allowPageScroll === undefined && (o.onSwipe !== Metro.noop || o.onSwipeStatus !== Metro.noop)) {
                o.allowPageScroll = TouchConst.NONE;
            }

            try {
                element.on(this.START_EV, $.proxy(this.touchStart, that));
                element.on(this.CANCEL_EV, $.proxy(this.touchCancel, that));
            } catch (e) {
                throw new Error('Events not supported ' + this.START_EV + ',' + this.CANCEL_EV + ' on Swipe');
            }

            this._fireEvent("touch-create", {
                element: element
            });
        },

        touchStart: function(e) {
            var element = this.element, options = this.options;

            //If we already in a touch event (a finger already in use) then ignore subsequent ones..
            if (this.getTouchInProgress()) {
                return;
            }

            //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
            if ($(e.target).closest(options.excludedElements).length > 0) {
                return;
            }

            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            this.phase = TouchConst.PHASE_START;

            //If we support touches, get the finger count
            if (touches) {
                // get the total number of fingers touching the screen
                this.fingerCount = touches.length;
            }
            //Else this is the desktop, so stop the browser from dragging content
            else if (options.preventDefaultEvents !== false) {
                e.preventDefault(); //call this on jq event so we are cross browser
            }

            //clear vars..
            this.distance = 0;
            this.direction = null;
            this.currentDirection=null;
            this.pinchDirection = null;
            this.duration = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;
            this.pinchDistance = 0;
            this.maximumsMap = this.createMaximumsData();
            this.cancelMultiFingerRelease();

            //Create the default finger data
            this.createFingerData(0, evt);

            // check the number of fingers is what we are looking for, or we are capturing pinches
            if (!touches || (this.fingerCount === options.fingers || options.fingers === TouchConst.ALL_FINGERS) || this.hasPinches()) {
                // get the coordinates of the touch
                this.startTime = this.getTimeStamp();

                if (this.fingerCount === 2) {
                    //Keep track of the initial pinch distance, so we can calculate the diff later
                    //Store second finger data as start
                    this.createFingerData(1, touches[1]);
                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                }

                if (options.onSwipeStatus !== Metro.noop || options.onPinchStatus !== Metro.noop) {
                    ret = this.triggerHandler(event, this.phase);
                }
            } else {
                //A touch with more or less than the fingers we are looking for, so cancel
                ret = false;
            }

            //If we have a return value from the users handler, then return and cancel
            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
                return ret;
            } else {
                if (options.onHold !== Metro.noop) {
                    this.holdTimeout = setTimeout($.proxy(function() {
                        //Trigger the event
                        element.trigger('hold', [event.target]);
                        //Fire the callback
                        if (options.onHold !== Metro.noop) { // TODO Remove this if
                            ret = Utils.exec(options.onHold, [event, event.target], element[0]);
                            element.fire("hold", {
                                event: event,
                                target: event.target
                            });
                        }
                    }, this), options.longTapThreshold);
                }

                this.setTouchInProgress(true);
            }

            return null;
        },

        touchMove: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
            if (this.phase === TouchConst.PHASE_END || this.phase === TouchConst.PHASE_CANCEL || this.inMultiFingerRelease())
                return;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            //Update the  finger data
            var currentFinger = this.updateFingerData(evt);
            this.endTime = this.getTimeStamp();

            if (touches) {
                this.fingerCount = touches.length;
            }

            if (this.options.onHold !== Metro.noop) {
                clearTimeout(this.holdTimeout);
            }

            this.phase = TouchConst.PHASE_MOVE;

            //If we have 2 fingers get Touches distance as well
            if (this.fingerCount === 2) {

                //Keep track of the initial pinch distance, so we can calculate the diff later
                //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
                if (this.startTouchesDistance === 0) {
                    //Create second finger if this is the first time...
                    this.createFingerData(1, touches[1]);

                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                } else {
                    //Else just update the second finger
                    this.updateFingerData(touches[1]);

                    this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].end, this.fingerData[1].end);
                    this.pinchDirection = this.calculatePinchDirection(this.fingerData[0].end, this.fingerData[1].end);
                }

                this.pinchZoom = this.calculatePinchZoom(this.startTouchesDistance, this.endTouchesDistance);
                this.pinchDistance = Math.abs(this.startTouchesDistance - this.endTouchesDistance);
            }

            if ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !touches || this.hasPinches()) {

                //The overall direction of the swipe. From start to now.
                this.direction = this.calculateDirection(currentFinger.start, currentFinger.end);

                //The immediate direction of the swipe, direction between the last movement and this one.
                this.currentDirection = this.calculateDirection(currentFinger.last, currentFinger.end);

                //Check if we need to prevent default event (page scroll / pinch zoom) or not
                this.validateDefaultEvent(e, this.currentDirection);

                //Distance and duration are all off the main finger
                this.distance = this.calculateDistance(currentFinger.start, currentFinger.end);
                this.duration = this.calculateDuration();

                //Cache the maximum distance we made in this direction
                this.setMaxDistance(this.direction, this.distance);

                //Trigger status handler
                ret = this.triggerHandler(event, this.phase);


                //If we trigger end events when threshold are met, or trigger events when touch leaves element
                if (!this.options.triggerOnTouchEnd || this.options.triggerOnTouchLeave) {

                    var inBounds = true;

                    //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
                    if (this.options.triggerOnTouchLeave) {
                        var bounds = this.getBounds(this);
                        inBounds = this.isInBounds(currentFinger.end, bounds);
                    }

                    //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
                    if (!this.options.triggerOnTouchEnd && inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_MOVE);
                    }
                    //We end if out of bounds here, so set current phase to END, and check if its modified
                    else if (this.options.triggerOnTouchLeave && !inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_END);
                    }

                    if (this.phase === TouchConst.PHASE_CANCEL || this.phase === TouchConst.PHASE_END) {
                        this.triggerHandler(event, this.phase);
                    }
                }
            } else {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }
        },

        touchEnd: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e,
                touches = event.touches;

            //If we are still in a touch with the device wait a fraction and see if the other finger comes up
            //if it does within the threshold, then we treat it as a multi release, not a single release and end the touch / swipe
            if (touches) {
                if (touches.length && !this.inMultiFingerRelease()) {
                    this.startMultiFingerRelease(event);
                    return true;
                } else if (touches.length && this.inMultiFingerRelease()) {
                    return true;
                }
            }

            //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
            //This is used to allow 2 fingers to release fractionally after each other, whilst maintaining the event as containing 2 fingers, not 1
            if (this.inMultiFingerRelease()) {
                this.fingerCount = this.fingerCountAtRelease;
            }

            //Set end of swipe
            this.endTime = this.getTimeStamp();

            //Get duration incase move was never fired
            this.duration = this.calculateDuration();

            //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
            if (this.didSwipeBackToCancel() || !this.validateSwipeDistance()) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            } else if (this.options.triggerOnTouchEnd || (this.options.triggerOnTouchEnd === false && this.phase === TouchConst.PHASE_MOVE)) {
                //call this on jq event so we are cross browser
                if (this.options.preventDefaultEvents !== false) {
                    e.preventDefault();
                }
                this.phase = TouchConst.PHASE_END;
                this.triggerHandler(event, this.phase);
            }
            //Special cases - A tap should always fire on touch end regardless,
            //So here we manually trigger the tap end handler by itself
            //We dont run trigger handler as it will re-trigger events that may have fired already
            else if (!this.options.triggerOnTouchEnd && this.hasTap()) {
                //Trigger the pinch events...
                this.phase = TouchConst.PHASE_END;
                this.triggerHandlerForGesture(event, this.phase, TouchConst.TAP);
            } else if (this.phase === TouchConst.PHASE_MOVE) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            this.setTouchInProgress(false);

            return null;
        },

        touchCancel: function() {
            // reset the variables back to default values
            this.fingerCount = 0;
            this.endTime = 0;
            this.startTime = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;

            //If we were in progress of tracking a possible multi touch end, then re set it.
            this.cancelMultiFingerRelease();

            this.setTouchInProgress(false);
        },

        touchLeave: function(e) {
            if (this.options.triggerOnTouchLeave) {
                this.phase = this.getNextPhase(TouchConst.PHASE_END);
                this.triggerHandler(e, this.phase);
            }
        },

        getNextPhase: function(currentPhase) {
            var options  = this.options;
            var nextPhase = currentPhase;

            // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
            var validTime = this.validateSwipeTime();
            var validDistance = this.validateSwipeDistance();
            var didCancel = this.didSwipeBackToCancel();

            //If we have exceeded our time, then cancel
            if (!validTime || didCancel) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }
            //Else if we are moving, and have reached distance then end
            else if (validDistance && currentPhase === TouchConst.PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
                nextPhase = TouchConst.PHASE_END;
            }
            //Else if we have ended by leaving and didn't reach distance, then cancel
            else if (!validDistance && currentPhase === TouchConst.PHASE_END && options.triggerOnTouchLeave) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }

            return nextPhase;
        },

        triggerHandler: function(event, phase) {
            var ret,
                touches = event.touches;

            // SWIPE GESTURES
            if (this.didSwipe() || this.hasSwipes()) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.SWIPE);
            }

            // PINCH GESTURES (if the above didn't cancel)
            if ((this.didPinch() || this.hasPinches()) && ret !== false) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.PINCH);
            }

            // CLICK / TAP (if the above didn't cancel)
            if (this.didDoubleTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.DOUBLE_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didLongTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.LONG_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didTap() && ret !== false) {
                //Trigger the tap event..
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.TAP);
            }

            // If we are cancelling the gesture, then manually trigger the reset handler
            if (phase === TouchConst.PHASE_CANCEL) {
                this.touchCancel(event);
            }

            // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
            if (phase === TouchConst.PHASE_END) {
                //If we support touch, then check that all fingers are off before we cancel
                if (touches) {
                    if (!touches.length) {
                        this.touchCancel(event);
                    }
                } else {
                    this.touchCancel(event);
                }
            }

            return ret;
        },

        triggerHandlerForGesture: function(event, phase, gesture) {

            var ret, element = this.element, options = this.options;

            //SWIPES....
            if (gesture === TouchConst.SWIPE) {
                //Trigger status every time..
                element.trigger('swipeStatus', [phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection]);

                ret = Utils.exec(options.onSwipeStatus, [event, phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                element.fire("swipestatus", {
                    event: event,
                    phase: phase,
                    direction: this.direction,
                    distance: this.distance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    currentDirection: this.currentDirection
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validateSwipe()) {

                    //Cancel any taps that were in progress...
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    element.trigger('swipe', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);

                    ret = Utils.exec(options.onSwipe, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                    element.fire("swipe", {
                        event: event,
                        direction: this.direction,
                        distance: this.distance,
                        duration: this.duration,
                        fingerCount: this.fingerCount,
                        fingerData: this.fingerData,
                        currentDirection: this.currentDirection
                    });

                    if (ret === false) return false;

                    //trigger direction specific event handlers
                    switch (this.direction) {
                        case TouchConst.LEFT:
                            element.trigger('swipeLeft', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeLeft, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeleft", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.RIGHT:
                            element.trigger('swipeRight', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeRight, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swiperight", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.UP:
                            element.trigger('swipeUp', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeUp, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeup", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.DOWN:
                            element.trigger('swipeDown', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeDown, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipedown", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;
                    }
                }
            }


            //PINCHES....
            if (gesture === TouchConst.PINCH) {
                element.trigger('pinchStatus', [phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);

                ret = Utils.exec(options.onPinchStatus, [event, phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                element.fire("pinchstatus", {
                    event: event,
                    phase: phase,
                    direction: this.pinchDirection,
                    distance: this.pinchDistance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    zoom: this.pinchZoom
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validatePinch()) {

                    switch (this.pinchDirection) {
                        case TouchConst.IN:
                            element.trigger('pinchIn', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchIn, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchin", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;

                        case TouchConst.OUT:
                            element.trigger('pinchOut', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchOut, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchout", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;
                    }
                }
            }

            if (gesture === TouchConst.TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {

                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    //If we are also looking for doubelTaps, wait incase this is one...
                    if (this.hasDoubleTap() && !this.inDoubleTap()) {
                        this.doubleTapStartTime = this.getTimeStamp();

                        //Now wait for the double tap timeout, and trigger this single tap
                        //if its not cancelled by a double tap
                        this.singleTapTimeout = setTimeout($.proxy(function() {
                            this.doubleTapStartTime = null;
                            ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                            element.fire("tap", {
                                event: event,
                                target: event.target
                            });
                        }, this), options.doubleTapThreshold);

                    } else {
                        this.doubleTapStartTime = null;
                        ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                        element.fire("tap", {
                            event: event,
                            target: event.target
                        });
                    }
                }
            } else if (gesture === TouchConst.DOUBLE_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onDoubleTap, [event, event.target], element[0]);
                    element.fire("doubletap", {
                        event: event,
                        target: event.target
                    });
                }
            } else if (gesture === TouchConst.LONG_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onLongTap, [event, event.target], element[0]);
                    element.fire("longtap", {
                        event: event,
                        target: event.target
                    });
                }
            }

            return ret;
        },

        validateSwipeDistance: function() {
            var valid = true;
            //If we made it past the min swipe distance..
            if (this.options.threshold !== null) {
                valid = this.distance >= this.options.threshold;
            }

            return valid;
        },

        didSwipeBackToCancel: function() {
            var options = this.options;
            var cancelled = false;
            if (options.cancelThreshold !== null && this.direction !== null) {
                cancelled = (this.getMaxDistance(this.direction) - this.distance) >= options.cancelThreshold;
            }

            return cancelled;
        },

        validatePinchDistance: function() {
            if (this.options.pinchThreshold !== null) {
                return this.pinchDistance >= this.options.pinchThreshold;
            }
            return true;
        },

        validateSwipeTime: function() {
            var result, options = this.options;

            if (options.maxTimeThreshold) {
                result = this.duration < options.maxTimeThreshold;
            } else {
                result = true;
            }

            return result;
        },

        validateDefaultEvent: function(e, direction) {
            var options = this.options;

            //If the option is set, allways allow the event to bubble up (let user handle weirdness)
            if (options.preventDefaultEvents === false) {
                return;
            }

            if (options.allowPageScroll === TouchConst.NONE) {
                e.preventDefault();
            } else {
                var auto = options.allowPageScroll === TouchConst.AUTO;

                switch (direction) {
                    case TouchConst.LEFT:
                        if ((options.onSwipeLeft !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.RIGHT:
                        if ((options.onSwipeRight !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.UP:
                        if ((options.onSwipeUp !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.DOWN:
                        if ((options.onSwipeDown !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.NONE:

                        break;
                }
            }
        },

        validatePinch: function() {
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var hasCorrectDistance = this.validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        },

        hasPinches: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.options.onPinchStatus || this.options.onPinchIn || this.options.onPinchOut);
        },

        didPinch: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validatePinch() && this.hasPinches());
        },

        validateSwipe: function() {
            //Check validity of swipe
            var hasValidTime = this.validateSwipeTime();
            var hasValidDistance = this.validateSwipeDistance();
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var didCancel = this.didSwipeBackToCancel();

            // if the user swiped more than the minimum length, perform the appropriate action
            // hasValidDistance is null when no distance is set
            return !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
        },

        hasSwipes: function() {
            var o = this.options;
            //Enure we dont return 0 or null for false values
            return !!(
                o.onSwipe !== Metro.noop
                || o.onSwipeStatus  !== Metro.noop
                || o.onSwipeLeft  !== Metro.noop
                || o.onSwipeRight  !== Metro.noop
                || o.onSwipeUp  !== Metro.noop
                || o.onSwipeDown !== Metro.noop
            );
        },

        didSwipe: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateSwipe() && this.hasSwipes());
        },

        validateFingers: function() {
            //The number of fingers we want were matched, or on desktop we ignore
            return ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !TouchConst.SUPPORTS_TOUCH);
        },

        validateEndPoint: function() {
            //We have an end value for the finger
            return this.fingerData[0].end.x !== 0;
        },

        hasTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onTap !== Metro.noop;
        },

        hasDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onDoubleTap !== Metro.noop;
        },

        hasLongTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onLongTap !== Metro.noop;
        },

        validateDoubleTap: function() {
            if (this.doubleTapStartTime == null) {
                return false;
            }
            var now = this.getTimeStamp();
            return (this.hasDoubleTap() && ((now - this.doubleTapStartTime) <= this.options.doubleTapThreshold));
        },

        inDoubleTap: function() {
            return this.validateDoubleTap();
        },

        validateTap: function() {
            return ((this.fingerCount === 1 || !TouchConst.SUPPORTS_TOUCH) && (isNaN(this.distance) || this.distance < this.options.threshold));
        },

        validateLongTap: function() {
            var options = this.options;
            //slight threshold on moving finger
            return ((this.duration > options.longTapThreshold) && (this.distance < TouchConst.DOUBLE_TAP_THRESHOLD)); // check double_tab_threshold where from
        },

        didTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateTap() && this.hasTap());
        },

        didDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateDoubleTap() && this.hasDoubleTap());
        },

        didLongTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateLongTap() && this.hasLongTap());
        },

        startMultiFingerRelease: function(event) {
            this.previousTouchEndTime = this.getTimeStamp();
            this.fingerCountAtRelease = event.touches.length + 1;
        },

        cancelMultiFingerRelease: function() {
            this.previousTouchEndTime = 0;
            this.fingerCountAtRelease = 0;
        },

        inMultiFingerRelease: function() {
            var withinThreshold = false;

            if (this.previousTouchEndTime) {
                var diff = this.getTimeStamp() - this.previousTouchEndTime;
                if (diff <= this.options.fingerReleaseThreshold) {
                    withinThreshold = true;
                }
            }

            return withinThreshold;
        },

        getTouchInProgress: function() {
            var element = this.element;
            //strict equality to ensure only true and false are returned
            return (element.data('intouch') === true);
        },

        setTouchInProgress: function(val) {
            var element = this.element;

            //If destroy is called in an event handler, we have no el, and we have already cleaned up, so return.
            if(!element) { return; }

            //Add or remove event listeners depending on touch status
            if (val === true) {
                element.on(this.MOVE_EV, $.proxy(this.touchMove, this));
                element.on(this.END_EV, $.proxy(this.touchEnd, this));

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.on(this.LEAVE_EV, $.proxy(this.touchLeave, this));
                }
            } else {

                element.off(this.MOVE_EV);
                element.off(this.END_EV);

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.off(this.LEAVE_EV);
                }
            }

            //strict equality to ensure only true and false can update the value
            element.data('intouch', val === true);
        },

        createFingerData: function(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX;
            f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY;
            this.fingerData[id] = f;
            return f;
        },

        updateFingerData: function(evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;
            var f = this.getFingerData(id);

            if (f === null) {
                f = this.createFingerData(id, evt);
            }

            f.last.x = f.end.x;
            f.last.y = f.end.y;

            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;

            return f;
        },

        getFingerData: function(id) {
            return this.fingerData[id] || null;
        },

        setMaxDistance: function(direction, distance) {
            if (direction === TouchConst.NONE) return;
            distance = Math.max(distance, this.getMaxDistance(direction));
            this.maximumsMap[direction].distance = distance;
        },

        getMaxDistance: function(direction) {
            return (this.maximumsMap[direction]) ? this.maximumsMap[direction].distance : undefined;
        },

        createMaximumsData: function() {
            var maxData = {};
            maxData[TouchConst.LEFT] = this.createMaximumVO(TouchConst.LEFT);
            maxData[TouchConst.RIGHT] = this.createMaximumVO(TouchConst.RIGHT);
            maxData[TouchConst.UP] = this.createMaximumVO(TouchConst.UP);
            maxData[TouchConst.DOWN] = this.createMaximumVO(TouchConst.DOWN);

            return maxData;
        },

        createMaximumVO: function(dir) {
            return {
                direction: dir,
                distance: 0
            }
        },

        calculateDuration: function(){
            return this.endTime - this.startTime;
        },

        calculateTouchesDistance: function(startPoint, endPoint){
            var diffX = Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);

            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        },

        calculatePinchZoom: function(startDistance, endDistance){
            var percent = (endDistance / startDistance) * 100; // 1 ? 100
            return percent.toFixed(2);
        },

        calculatePinchDirection: function(){
            if (this.pinchZoom < 1) {
                return TouchConst.OUT;
            } else {
                return TouchConst.IN;
            }
        },

        calculateDistance: function(startPoint, endPoint){
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        },

        calculateAngle: function(startPoint, endPoint){
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x); //radians
            var angle = Math.round(r * 180 / Math.PI); //degrees

            //ensure value is positive
            if (angle < 0) {
                angle = 360 - Math.abs(angle);
            }

            return angle;
        },

        calculateDirection: function(startPoint, endPoint){
            if( this.comparePoints(startPoint, endPoint) ) {
                return TouchConst.NONE;
            }

            var angle = this.calculateAngle(startPoint, endPoint);

            if ((angle <= 45) && (angle >= 0)) {
                return TouchConst.LEFT;
            } else if ((angle <= 360) && (angle >= 315)) {
                return TouchConst.LEFT;
            } else if ((angle >= 135) && (angle <= 225)) {
                return TouchConst.RIGHT;
            } else if ((angle > 45) && (angle < 135)) {
                return TouchConst.DOWN;
            } else {
                return TouchConst.UP;
            }
        },

        getTimeStamp: function(){
            return (new Date()).getTime();
        },

        getBounds: function (el) {
            el = $(el);
            var offset = el.offset();

            return {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            };
        },

        isInBounds: function(point, bounds){
            return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
        },

        comparePoints: function(pointA, pointB) {
            return (pointA.x === pointB.x && pointA.y === pointB.y);
        },

        removeListeners: function() {
            var element = this.element;

            element.off(this.START_EV);
            element.off(this.CANCEL_EV);
            element.off(this.MOVE_EV);
            element.off(this.END_EV);

            //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
            if (this.LEAVE_EV) {
                element.off(this.LEAVE_EV);
            }

            this.setTouchInProgress(false);
        },

        enable: function(){
            this.disable();
            this.element.on(this.START_EV, this.touchStart);
            this.element.on(this.CANCEL_EV, this.touchCancel);
            return this.element;
        },

        disable: function(){
            this.removeListeners();
            return this.element;
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.removeListeners();
        }
    });

    Metro['touch'] = TouchConst;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TreeViewDefaultConfig = {
        treeviewDeferred: 0,
        showChildCount: false,
        duration: 100,
        onNodeClick: Metro.noop,
        onNodeDblClick: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeInsert: Metro.noop,
        onNodeClean: Metro.noop,
        onCheckClick: Metro.noop,
        onRadioClick: Metro.noop,
        onExpandNode: Metro.noop,
        onCollapseNode: Metro.noop,
        onTreeViewCreate: Metro.noop
    };

    Metro.treeViewSetup = function (options) {
        TreeViewDefaultConfig = $.extend({}, TreeViewDefaultConfig, options);
    };

    if (typeof window["metroTreeViewSetup"] !== undefined) {
        Metro.treeViewSetup(window["metroTreeViewSetup"]);
    }

    Metro.Component('tree-view', {
        init: function( options, elem ) {
            this._super(elem, options, TreeViewDefaultConfig);
            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createTree();
            this._createEvents();

            $.each(element.find("input"), function(){
                if (!$(this).is(":checked")) return;
                that._recheck(this);
            });

            this._fireEvent("tree-view-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img src='' alt=''>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<span>").addClass("caption").html(data);
        },


        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },


        _createNode: function(data){
            var node;

            node = $("<li>");

            if (data.caption !== undefined) {
                node.prepend(this._createCaption(data.caption));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (data.html !== undefined) {
                node.append(data.html);
            }

            return node;
        },

        _createTree: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");

            element.addClass("treeview");

            $.each(nodes, function(){
                var node = $(this);
                var caption, icon;

                caption = node.data("caption");
                icon = node.data("icon");

                if (caption !== undefined) {
                    if (node.children("ul").length > 0 && o.showChildCount === true) {
                        caption += " ("+node.children("ul").children("li").length+")"
                    }
                    node.prepend(that._createCaption(caption));
                }

                if (icon !== undefined) {
                    node.prepend(that._createIcon(icon));
                }

                if (node.children("ul").length > 0) {

                    node.addClass("tree-node");

                    node.append(that._createToggle());

                    if (Utils.bool(node.attr("data-collapsed")) !== true) {
                        node.addClass("expanded");
                    } else {
                        node.children("ul").hide();
                    }
                }

            });
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".node-toggle", function(e){
                var toggle = $(this);
                var node = toggle.parent();

                that.toggleNode(node);

                e.preventDefault();
            });

            element.on(Metro.events.click, "li > .caption", function(e){
                var node = $(this).parent();

                that.current(node);

                that._fireEvent("node-click", {
                    node: node[0]
                });

                e.preventDefault();
            });

            element.on(Metro.events.dblclick, "li > .caption", function(e){
                var node = $(this).closest("li");
                var toggle = node.children(".node-toggle");
                var subtree = node.children("ul");

                if (toggle.length > 0 || subtree.length > 0) {
                    that.toggleNode(node);
                }

                that._fireEvent("node-dbl-click", {
                    node: node[0]
                })

                e.preventDefault();
            });

            element.on(Metro.events.click, "input[type=radio]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that.current(node);

                that._fireEvent("radio-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });

            element.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that._recheck(check);

                that._fireEvent("check-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });
        },

        _recheck: function(check){
            var element = this.element;
            var checked, node, checks, all_checks;

            check = $(check);

            checked = check.is(":checked");
            node = check.closest("li");

            this.current(node);

            // down
            checks = check.closest("li").find("ul input[type=checkbox]");
            checks.attr("data-indeterminate", false);
            checks.prop("checked", checked);
            checks.trigger('change');

            all_checks = [];

            $.each(element.find("input[type=checkbox]"), function(){
                all_checks.push(this);
            });

            $.each(all_checks.reverse(), function(){
                var ch = $(this);
                var children = ch.closest("li").children("ul").find("input[type=checkbox]").length;
                var children_checked = ch.closest("li").children("ul").find("input[type=checkbox]").filter(function(el){
                    return el.checked;
                }).length;

                if (children > 0 && children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                    ch.prop("checked", false);
                    ch.trigger('change');
                }

                if (children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                } else {
                    if (children_checked > 0 && children > children_checked) {
                        ch.attr("data-indeterminate", true);
                    } else if (children === children_checked) {
                        ch.attr("data-indeterminate", false);
                        ch.prop("checked", true);
                        ch.trigger('change');
                    }
                }
            });
        },

        current: function(node){
            var element = this.element;

            if (node === undefined) {
                return element.find("li.current")
            }

            element.find("li").removeClass("current");
            node.addClass("current");
        },

        toggleNode: function(n){
            var node = $(n);
            var o = this.options;
            var func;
            var toBeExpanded = !node.data("collapsed");//!node.hasClass("expanded");

            node.toggleClass("expanded");
            node.data("collapsed", toBeExpanded);

            func = toBeExpanded === true ? "slideUp" : "slideDown";

            if (!toBeExpanded) {

                this._fireEvent("expand-node", {
                    node: node[0]
                });

            } else {

                this._fireEvent("collapse-node", {
                    node: node[0]
                });

            }

            node.children("ul")[func](o.duration);
        },

        addTo: function(node, data){
            var element = this.element;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {
                node = $(node);
                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.appendTo(target);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertBefore: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertBefore(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertAfter(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node[0]
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;
            node = $(node);
            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");

            this._fireEvent("node-delete", {
                node: node[0]
            });

            node.remove();

            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }
        },

        clean: function(node){
            node = $(node);
            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, "li > .caption");
            element.off(Metro.events.dblclick, "li > .caption");
            element.off(Metro.events.click, "input[type=radio]");
            element.off(Metro.events.click, "input[type=checkbox]");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Colors = Metro.colors;
    var ValidatorFuncs = {
        required: function(val){
            if (Array.isArray(val)) {
                return val.length > 0 ? val : false;
            } else {
                return Utils.isValue(val) ? val.trim() : false;
            }
        },
        length: function(val, len){
            if (Array.isArray(val)) {return val.length === parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length === parseInt(len);
        },
        minlength: function(val, len){
            if (Array.isArray(val)) {return val.length >= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length >= parseInt(len);
        },
        maxlength: function(val, len){
            if (Array.isArray(val)) {return val.length <= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length <= parseInt(len);
        },
        min: function(val, min_value){
            if (!Utils.isValue(min_value) || isNaN(min_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) >= Number(min_value);
        },
        max: function(val, max_value){
            if (!Utils.isValue(max_value) || isNaN(max_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) <= Number(max_value);
        },
        email: function(val){
            /* eslint-disable-next-line */
            return /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i.test(val);
        },
        domain: function(val){
            /* eslint-disable-next-line */
            return /^((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/.test(val);
        },
        url: function(val){
            /* eslint-disable-next-line */
            return /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(val);
        },
        date: function(val, format, locale){
            if (Utils.isNull(format)) {
                return String(new Date(val)).toLowerCase() !== "invalid date";
            } else {
                return String(val.toDate(format, locale)).toLowerCase() !== "invalid date";
            }
        },
        number: function(val){
            return !isNaN(val);
        },
        integer: function(val){
            return Utils.isInt(val);
        },
        float: function(val){
            return Utils.isFloat(val);
        },
        digits: function(val){
            return /^\d+$/.test(val);
        },
        hexcolor: function(val){
            /* eslint-disable-next-line */
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
        },
        color: function(val){
            if (!Utils.isValue(val)) return false;
            return Colors.color(val, Colors.PALETTES.STANDARD) !== false;
        },
        pattern: function(val, pat){
            if (!Utils.isValue(val)) return false;
            if (!Utils.isValue(pat)) return false;
            var reg = new RegExp(pat);
            return reg.test(val);
        },
        compare: function(val, val2){
            return val === val2;
        },
        not: function(val, not_this){
            return val !== not_this;
        },
        notequals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() !== val2.trim();
        },
        equals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() === val2.trim();
        },
        custom: function(val, func){
            if (Utils.isFunc(func) === false) {
                return false;
            }
            return Utils.exec(func, [val]);
        },

        is_control: function(el){
            return el.parent().hasClass("input")
                || el.parent().hasClass("select")
                || el.parent().hasClass("textarea")
                || el.parent().hasClass("checkbox")
                || el.parent().hasClass("switch")
                || el.parent().hasClass("radio")
                || el.parent().hasClass("spinner")
                ;
        },

        reset_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().removeClass("invalid valid");
            } else {
                input.removeClass("invalid valid");
            }
        },

        set_valid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("valid");
            } else {
                input.addClass("valid");
            }
        },

        set_invalid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("invalid");
            } else {
                input.addClass("invalid");
            }
        },

        reset: function(form){
            var that = this;
            $.each($(form).find("[data-validate]"), function(){
                that.reset_state(this);
            });

            return this;
        },

        validate: function(el, result, cb_ok, cb_error, required_mode){
            var this_result = true;
            var input = $(el);
            var funcs = input.data('validate') !== undefined ? String(input.data('validate')).split(" ").map(function(s){return s.trim();}) : [];
            var errors = [];
            var hasForm = input.closest('form').length > 0;
            var attr_name, radio_checked;

            if (funcs.length === 0) {
                return true;
            }

            this.reset_state(input);

            if (input.attr('type') && input.attr('type').toLowerCase() === "checkbox") {
                if (funcs.indexOf('required') === -1) {
                    this_result = true;
                } else {
                    this_result = input.is(":checked");
                }

                if (this_result === false) {
                    errors.push('required');
                }

                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else if (input.attr('type') && input.attr('type').toLowerCase() === "radio") {
                attr_name = input.attr('name');
                if (typeof attr_name  === undefined) {
                    this_result = true;
                } else {
                    /*
                    * Fix with escaped name by nlared https://github.com/nlared
                    * */
                    radio_checked = $("input[name=" + attr_name.replace("[", "\\\[").replace("]", "\\\]") + "]:checked"); // eslint-disable-line
                    this_result = radio_checked.length > 0;
                }
                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else {
                $.each(funcs, function(){
                    if (this_result === false) return;
                    var rule = this.split("=");
                    var f, a, b;

                    f = rule[0]; rule.shift();
                    a = rule.join("=");

                    if (['compare', 'equals', 'notequals'].indexOf(f) > -1) {
                        a = hasForm ? input[0].form.elements[a].value : $("[name="+a+"]").val();
                    }

                    if (f === 'date') {
                        a = input.attr("data-value-format");
                        b = input.attr("data-value-locale");
                    }

                    if (Utils.isFunc(ValidatorFuncs[f]) === false)  {
                        this_result = true;
                    } else {
                        if (required_mode === true || f === "required") {
                            this_result = ValidatorFuncs[f](input.val(), a, b);
                        } else {
                            if (input.val().trim() !== "") {
                                this_result = ValidatorFuncs[f](input.val(), a, b);
                            } else {
                                this_result = true;
                            }
                        }
                    }

                    if (this_result === false) {
                        errors.push(f);
                    }

                    if (result !== undefined) {
                        result.val += this_result ? 0 : 1;
                    }
                });
            }

            if (this_result === false) {
                this.set_invalid_state(input);

                if (result !== undefined) {
                    result.log.push({
                        input: input[0],
                        name: input.attr("name"),
                        value: input.val(),
                        funcs: funcs,
                        errors: errors
                    });
                }

                if (cb_error !== undefined) Utils.exec(cb_error, [input, input.val()], input[0]);

            } else {
                this.set_valid_state(input);

                if (cb_ok !== undefined) Utils.exec(cb_ok, [input, input.val()], input[0]);
            }

            return this_result;
        }
    };

    Metro['validator'] = ValidatorFuncs;

    var ValidatorDefaultConfig = {
        validatorDeferred: 0,
        submitTimeout: 200,
        interactiveCheck: false,
        clearInvalid: 0,
        requiredMode: true,
        useRequiredClass: true,
        onBeforeSubmit: Metro.noop_true,
        onSubmit: Metro.noop,
        onError: Metro.noop,
        onValidate: Metro.noop,
        onErrorForm: Metro.noop,
        onValidateForm: Metro.noop,
        onValidatorCreate: Metro.noop
    };

    Metro.validatorSetup = function (options) {
        ValidatorDefaultConfig = $.extend({}, ValidatorDefaultConfig, options);
    };

    if (typeof window["metroValidatorSetup"] !== undefined) {
        Metro.validatorSetup(window["metroValidatorSetup"]);
    }

    Metro.Component('validator', {
        name: "Validator",

        init: function( options, elem ) {
            this._super(elem, options, ValidatorDefaultConfig, {
                _onsubmit: null,
                _onreset: null,
                result: []
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var inputs = element.find("[data-validate]");

            element
                .attr("novalidate", 'novalidate');

            $.each(inputs, function(){
                var input = $(this);
                var funcs = input.data("validate");
                var required = funcs.indexOf("required") > -1;
                if (required && o.useRequiredClass === true) {
                    if (ValidatorFuncs.is_control(input)) {
                        input.parent().addClass("required");
                    } else {
                        input.addClass("required");
                    }
                }
                if (o.interactiveCheck === true) {
                    input.on(Metro.events.inputchange, function () {
                        ValidatorFuncs.validate(this, undefined, undefined, undefined, o.requiredMode);
                    });
                }
            });

            this._onsubmit = null;
            this._onreset = null;

            if (element[0].onsubmit !== null) {
                this._onsubmit = element[0].onsubmit;
                element[0].onsubmit = null;
            }

            if (element[0].onreset !== null) {
                this._onreset = element[0].onreset;
                element[0].onreset = null;
            }

            element[0].onsubmit = function(){
                return that._submit();
            };

            element[0].onreset = function(){
                return that._reset();
            };

            this._fireEvent("validator-create", {
                element: element
            });
        },

        _reset: function(){
            ValidatorFuncs.reset(this.element);
            if (this._onsubmit !==  null) Utils.exec(this._onsubmit, null, this.element[0]);
        },

        _submit: function(){
            var that = this, element = this.element, o = this.options;
            var form = this.elem;
            var inputs = element.find("[data-validate]");
            var submit = element.find("input[type=submit], button[type=submit]");
            var result = {
                val: 0,
                log: []
            };
            var formData = $.serializeToArray(element);

            if (submit.length > 0) {
                submit.attr('disabled', 'disabled').addClass('disabled');
            }

            $.each(inputs, function(){
                ValidatorFuncs.validate(this, result, o.onValidate, o.onError, o.requiredMode);
            });

            submit.removeAttr("disabled").removeClass("disabled");

            result.val += Utils.exec(o.onBeforeSubmit, [formData], this.elem) === false ? 1 : 0;

            if (result.val === 0) {

                this._fireEvent("validate-form", {
                    data: formData
                });

                setTimeout(function(){
                    // TODO need fix event name to equivalent
                    Utils.exec(o.onSubmit, [formData], form);
                    element.fire("formsubmit", {
                        data: formData
                    });
                    if (that._onsubmit !==  null) Utils.exec(that._onsubmit, null, form);
                }, o.submitTimeout);
            } else {

                this._fireEvent("error-form", {
                    log: result.log,
                    data: formData
                });

                if (o.clearInvalid > 0) {
                    setTimeout(function(){
                        $.each(inputs, function(){
                            var inp  = $(this);
                            if (ValidatorFuncs.is_control(inp)) {
                                inp.parent().removeClass("invalid");
                            } else {
                                inp.removeClass("invalid");
                            }
                        })
                    }, o.clearInvalid);
                }
            }

            return result.val === 0;
        },

        changeAttribute: function(){
        }
    });
}(Metro, m4q));

/**
 * Component Vegas based on Vegas by Jay Salvat (http://jaysalvat.com/)
 * Original code https://github.com/jaysalvat/vegas
 * MIT License, Copyright 2018 Jay Salvat
 *
 * Adaptation for Metro 4 by Serhii Pimenov,
 * Copyright 2020 Serhii Pimenov
 */

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VegasDefaultConfig = {
        duration: 4000,
        animationDuration: null,
        transitionDuration: null,
        transition: "fade",
        animation: null,
        slides: [],
        shuffle: false,
        align: "center",
        valign: "center",
        loop: true,
        autoplay: true,
        mute: true,
        cover: true,
        preload: true,
        timer: true,
        overlay: 2,
        color: null,
        volume: 1,
        onPlay: Metro.noop,
        onPause: Metro.noop,
        onEnd: Metro.noop,
        onWalk: Metro.noop,
        onNext: Metro.noop,
        onPrev: Metro.noop,
        onJump: Metro.noop,
        onVegasCreate: Metro.noop
    };

    Metro.vegasSetup = function (options) {
        VegasDefaultConfig = $.extend({}, VegasDefaultConfig, options);
    };

    if (typeof window["metroVegasSetup"] !== undefined) {
        Metro.vegasSetup(window["metroVegasSetup"]);
    }

    Metro.Component('vegas', {

        videoCache: {},

        init: function( options, elem ) {
            this.transitions = [
                "fade", "fade2",
                "slideLeft", "slideLeft2",
                "slideRight", "slideRight2",
                "slideUp", "slideUp2",
                "slideDown", "slideDown2",
                "zoomIn", "zoomIn2",
                "zoomOut", "zoomOut2",
                "swirlLeft", "swirlLeft2",
                "swirlRight", "swirlRight2"
            ];
            this.animations = [
                "kenburns",
                "kenburnsUp",
                "kenburnsDown",
                "kenburnsRight",
                "kenburnsLeft",
                "kenburnsUpLeft",
                "kenburnsUpRight",
                "kenburnsDownLeft",
                "kenburnsDownRight"
            ];

            this.support = {
                objectFit:  'objectFit'  in document.body.style,
                video: !/(Android|webOS|Phone|iPad|iPod|BlackBerry|Windows Phone)/i.test(navigator.userAgent)
            }

            this._super(elem, options, VegasDefaultConfig, {
                slide: 0,
                slides: null,
                total: 0,
                noshow: false,
                paused: false,
                ended: false,
                timer: null,
                overlay: null,
                first: true,
                timeout: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this.slides = Utils.isObject(this.options.slides) || [];
            this.total = this.slides.length;
            this.noshow = this.total < 2;
            this.paused = !this.options.autoplay || this.noshow;

            if (this.options.shuffle) {
                this.slides.shuffle();
            }

            if (this.options.preload) {
                this._preload();
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("vegas-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var isBody = element[0].tagName === 'BODY';
            var wrapper;

            if (!isBody) {
                element.css('height', element.css('height')); // it is not clear why this line

                wrapper = $('<div class="vegas-wrapper">')
                    .css('overflow', element.css('overflow'))
                    .css('padding',  element.css('padding'));

                if (!element.css('padding')) {
                    wrapper
                        .css('padding-top',    element.css('padding-top'))
                        .css('padding-bottom', element.css('padding-bottom'))
                        .css('padding-left',   element.css('padding-left'))
                        .css('padding-right',  element.css('padding-right'));
                }

                element.children().appendTo(wrapper);
                element.clear();
            }

            element.addClass("vegas-container");

            if (!isBody) {
                element.append(wrapper);
            }

            if (o.timer) {
                this.timer = $('<div class="vegas-timer"><div class="vegas-timer-progress">');
                element.append(this.timer);
            }

            if (o.overlay) {
                this.overlay = $('<div class="vegas-overlay">').addClass('overlay' + (typeof o.overlay === 'boolean' || isNaN(o.overlay) ? 2 : +o.overlay));
                element.append(this.overlay);
            }

            setTimeout(function(){
                Utils.exec(o.onPlay, null, element[0]);
                that._goto(that.slide);
            },1)
        },

        _createEvents: function(){
        },

        _preload: function(){
            var img, i;

            for (i = 0; i < this.slides.length; i++) {

                var obj = this.slides[i];

                if (obj.src) {
                    img = new Image();
                    img.src = this.slides[i].src;
                }

                if (obj.video) {
                    if (obj.video instanceof Array) {
                        this._video(obj.video);
                    } else {
                        this._video(obj.video.src);
                    }
                }
            }
        },

        _slideShow: function () {
            var that = this, o = this.options;

            if (this.total > 1 && !this.ended && !this.paused && !this.noshow) {
                this.timeout = setTimeout(function () {
                    that.next();
                }, o.duration);
            }
        },

        _timer: function (state) {
            var that = this, o = this.options;

            clearTimeout(this.timeout);

            if (!this.timer) {
                return;
            }

            this.timer
                .removeClass('vegas-timer-running')
                .find('div')
                .css('transition-duration', '0ms');

            if (this.ended || this.paused || this.noshow) {
                return;
            }

            if (state) {
                setTimeout(function () {
                    that.timer
                        .addClass('vegas-timer-running')
                        .find('div')
                        .css('transition-duration', +o.duration - 100 + 'ms');
                }, 100);
            }
        },

        _fadeSoundIn: function(video, duration){
            var o = this.options;

            $.animate({
                el: video,
                draw: {
                    volume: +o.volume
                },
                dur: duration
            })
        },

        _fadeSoundOut: function(video, duration){
            $.animate({
                el: video,
                draw: {
                    volume: 0
                },
                dur: duration
            })
        },

        _video: function(sources){
            var video, source;
            var cacheKey = sources.toString();

            if (this.videoCache[cacheKey]) {
                return this.videoCache[cacheKey];
            }

            if (!Array.isArray(sources)) {
                sources = [sources];
            }

            video = document.createElement("video");
            video.preload = true;

            sources.forEach(function(src){
                source = document.createElement("source");
                source.src = src;
                video.appendChild(source);
            });

            this.videoCache[cacheKey] = video;

            return video;
        },

        _goto: function(n){
            var that = this, element = this.element, o = this.options;

            if (typeof this.slides[n] === 'undefined') {
                n = 0;
            }

            this.slide = n;

            var $slide, $inner, video, img, $video;
            var slides = element.children(".vegas-slide");
            var obj = this.slides[n];
            var cover = o.cover;
            var transition, animation;
            var transitionDuration, animationDuration;

            if (this.first) {
                this.first = false;
            }

            if (cover !== 'repeat') {
                if (cover === true) {
                    cover = 'cover';
                } else if (cover === false) {
                    cover = 'contain';
                }
            }

            if (o.transition === 'random') {
                transition = $.random(this.transitions);
            } else {
                transition = o.transition ? o.transition : this.transitions[0];
            }

            if (o.animation === 'random') {
                animation = $.random(this.animations);
            } else {
                animation = o.animation ? o.animation : this.animations[0];
            }

            if (!o.transitionDuration) {
                transitionDuration = +o.duration;
            } else if (o.transitionDuration === 'auto' || +o.transitionDuration > +o.duration) {
                transitionDuration = +o.duration;
            } else {
                transitionDuration = +o.transitionDuration;
            }

            if (!o.animationDuration) {
                animationDuration = +o.duration;
            } else if (o.animationDuration === 'auto' || +o.animationDuration > +o.duration) {
                animationDuration = +o.duration;
            } else {
                animationDuration = +o.animationDuration;
            }

            $slide = $("<div>").addClass("vegas-slide").addClass('vegas-transition-' + transition);

            if (this.support.video && obj.video) {
                video = obj.video instanceof Array ? this._video(obj.video) : this._video(obj.video.src);
                video.loop = obj.video.loop ? obj.video.loop : o.loop;
                video.muted = obj.video.mute ? obj.video.mute : o.mute;

                if (!video.muted) {
                    this._fadeSoundIn(video, transitionDuration);
                } else {
                    video.pause();
                }

                $video = $(video)
                    .addClass('vegas-video')
                    .css('background-color', o.color || '#000000');

                if (this.support.objectFit) {
                    $video
                        .css('object-position', o.align + ' ' + o.valign)
                        .css('object-fit', cover)
                        .css('width',  '100%')
                        .css('height', '100%');
                } else if (cover === 'contain') {
                    $video
                        .css('width',  '100%')
                        .css('height', '100%');
                }

                $slide.append($video);
            } else {
                img = new Image();
                $inner = $("<div>").addClass('vegas-slide-inner')
                    .css({
                        backgroundImage: 'url("'+obj.src+'")',
                        backgroundColor: o.color || '#000000',
                        backgroundPosition: o.align + ' ' + o.valign
                    });

                if (cover === 'repeat') {
                    $inner.css('background-repeat', 'repeat');
                } else {
                    $inner.css('background-size', cover);
                }

                if (animation) {
                    $inner
                        .addClass('vegas-animation-' + animation)
                        .css('animation-duration',  animationDuration + 'ms');
                }

                $slide.append($inner);
            }

            if (slides.length) {
                slides.eq(slides.length - 1).after($slide);
            } else {
                element.prepend($slide);
            }

            slides
                .css('transition', 'all 0ms')
                .each(function(){
                    this.className  = 'vegas-slide';

                    if (this.tagName === 'VIDEO') {
                        this.className += ' vegas-video';
                    }

                    if (transition) {
                        this.className += ' vegas-transition-' + transition;
                        this.className += ' vegas-transition-' + transition + '-in';
                    }
                }
            );

            this._timer(false);

            function go(){
                that._timer(true);
                setTimeout(function () {
                    slides
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-out');

                    slides.each(function () {
                        var video = slides.find('video').get(0);

                        if (video) {
                            video.volume = 1;
                            that._fadeSoundOut(video, transitionDuration);
                        }
                    });

                    $slide
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-in');

                    for (var i = 0; i < slides.length - 1; i++) {
                        slides.eq(i).remove();
                    }

                    that._fireEvent("walk", {
                        slide: that.current(true)
                    });

                    that._slideShow();
                }, 100);
            }

            if (video) {
                if (video.readyState === 4) {
                    video.currentTime = 0;
                }

                video.play();
                go();
            } else {
                img.src = obj.src;

                if (img.complete) {
                    go();
                } else {
                    img.onload = go;
                }
            }
        },

        _end: function(){
            this.ended = this.options.autoplay;
            this._timer(false);

            this._fireEvent("end", {
                slide: this.current(true)
            });
        },

        play: function(){
            if (!this.paused) {
                return ;
            }

            this._fireEvent("play", {
                slide: this.current(true)
            });

            this.paused = false;
            this.next();
        },

        pause: function(){
            this._timer(false);
            this.paused = true;

            this._fireEvent("pause", {
                slide: this.current(true)
            });
        },

        toggle: function(){
            this.paused ? this.play() : this.pause();
        },

        playing: function(){
            return !this.paused && !this.noshow;
        },

        current: function (advanced) {
            if (advanced) {
                return {
                    slide: this.slide,
                    data:  this.slides[this.slide]
                };
            }
            return this.slide;
        },

        jump: function(n){
            if (n <= 0 || n > this.slides.length || n === this.slide + 1) {
                return this;
            }

            this.slide = n - 1;

            this._fireEvent("jump", {
                slide: this.current(true)
            })

            this._goto(this.slide);
        },

        next: function(){
            var o = this.options;

            this.slide++;

            if (this.slide >= this.slides.length) {
                if (!o.loop) {
                    return this._end();
                }

                this.slide = 0;
            }

            this._fireEvent("next", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        prev: function(){
            var o = this.options;

            this.slide--;

            if (this.slide < 0) {
                if (!o.loop) {
                    this.slide++;
                    return this._end();
                }

                this.slide = this.slides.length - 1;
            }

            this._fireEvent("prev", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var propName = $.camelCase(attributeName.replace("data-", ""));

            if (propName === 'slides') {
                o.slides = element.attr('data-slides');
                this.slides = Utils.isObject(o.slides) || [];
                this.total = this.slides.length;
                this.noshow = this.total < 2;
                this.paused = !this.options.autoplay || this.noshow;
            } else {
                if (typeof VegasDefaultConfig[propName] !== 'undefined')
                    o[propName] = JSON.parse(element.attr(attributeName));
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            clearTimeout(this.timeout);
            element.removeClass('vegas-container');
            element.find('> .vegas-slide').remove();
            element.find('> .vegas-wrapper').children().appendTo(element);
            element.find('> .vegas-wrapper').remove();

            if (o.timer) {
                this.timer.remove();
            }

            if (o.overlay) {
                this.overlay.remove();
            }

            return element[0];
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VideoPlayerDefaultConfig = {
        videoDeferred: 0,
        src: null,

        poster: "",
        logo: "",
        logoHeight: 32,
        logoWidth: "auto",
        logoTarget: "",

        volume: .5,
        loop: false,
        autoplay: false,

        fullScreenMode: Metro.fullScreenMode.DESKTOP,
        aspectRatio: Metro.aspectRatio.HD,

        controlsHide: 3000,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",
        screenMoreIcon: "<span class='default-icon-enlarge'></span>",
        screenLessIcon: "<span class='default-icon-shrink'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onVideoPlayerCreate: Metro.noop
    };

    Metro.videoPlayerSetup = function (options) {
        VideoPlayerDefaultConfig = $.extend({}, VideoPlayerDefaultConfig, options);
    };

    if (typeof window["metroVideoPlayerSetup"] !== undefined) {
        Metro.videoPlayerSetup(window["metroVideoPlayerSetup"]);
    }

    Metro.Component('video-player', {
        init: function( options, elem ) {
            this._super(elem, options, VideoPlayerDefaultConfig, {
                fullscreen: false,
                preloader: null,
                player: null,
                video: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false,
                fullScreenInterval: false,
                isPlaying: false,
                id: Utils.elementId('video-player')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (Metro.fullScreenEnabled === false) {
                o.fullScreenMode = Metro.fullScreenMode.WINDOW;
            }

            this._createPlayer();
            this._createControls();
            this._createEvents();
            this._setAspectRatio();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("video-player-create", {
                element: element,
                player: this.player
            });
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, video = this.video;
            var player = $("<div>").addClass("media-player video-player " + element[0].className);
            var preloader = $("<div>").addClass("preloader").appendTo(player);
            var logo = $("<a>").attr("href", o.logoTarget).addClass("logo").appendTo(player);

            player.insertBefore(element);
            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            if (o.poster !== "") {
                element.attr("poster", o.poster);
            }

            video.volume = o.volume;

            preloader.activity({
                type: "cycle",
                style: "color"
            });

            preloader.hide();

            this.preloader = preloader;

            if (o.logo !== "") {
                $("<img>")
                    .css({
                        height: o.logoHeight,
                        width: o.logoWidth
                    })
                    .attr("src", o.logo).appendTo(logo);
            }

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, video = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);

            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!video.paused) video.pause();
                },
                onStop: function(val){
                    if (video.seekable.length > 0) {
                        video.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (video.paused && video.currentTime > 0) {
                        video.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    video.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);
            if (o.showFull === true) $("<button>").attr("type", "button").addClass("button square full").html(o.screenMoreIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = video.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                video.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, video = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.show();
            });

            element.on("loadedmetadata", function(){
                that.duration = video.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [video, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.hide();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(video.currentTime * 100 / that.duration);
                that._setInfo(video.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [video.currentTime, that.duration, video, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.show();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [video, player], element[0]);
                that._onMouse();
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [video, player], element[0]);
                that._offMouse();
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [video, player], element[0]);
                that._offMouse();
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [video, player], element[0]);
                that._offMouse();
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (video.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });

            player.on(Metro.events.click, ".full", function(){
                that.fullscreen = !that.fullscreen;
                player.find(".full").html(that.fullscreen === true ? o.screenLessIcon : o.screenMoreIcon);
                if (o.fullScreenMode === Metro.fullScreenMode.WINDOW) {
                    if (that.fullscreen === true) {
                        player.addClass("full-screen");
                    } else {
                        player.removeClass("full-screen");
                    }
                } else {
                    if (that.fullscreen === true) {

                        Metro.requestFullScreen(video);

                        if (that.fullScreenInterval === false) that.fullScreenInterval = setInterval(function(){
                            if (Metro.inFullScreen() === false) {
                                that.fullscreen = false;
                                clearInterval(that.fullScreenInterval);
                                that.fullScreenInterval = false;
                                player.find(".full").html(o.screenMoreIcon);
                            }

                        }, 1000);
                    } else {
                        Metro.exitFullScreen();
                    }
                }

                // if (that.fullscreen === true) {
                //     $(document).on(Metro.events.keyup + ".video-player", function(e){
                //         if (e.keyCode === 27) {
                //             player.find(".full").click();
                //         }
                //     });
                // } else {
                //     $(document).off(Metro.events.keyup + ".video-player");
                // }
            });

            $(window).on(Metro.events.keyup, function(e){
                if (that.fullscreen && e.keyCode === 27) {
                    player.find(".full").click();
                }
            }, {ns: this.id});

            $(window).on(Metro.events.resize, function(){
                that._setAspectRatio();
            }, {ns: this.id});

        },

        _onMouse: function(){
            var o = this.options, player = this.player;

            player.on(Metro.events.enter, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && controls.style('display') === 'none') {
                    controls.stop(true).fadeIn(500, function(){
                        controls.css("display", "flex");
                    });
                }
            });

            player.on(Metro.events.leave, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && parseInt(controls.style('opacity')) === 1) {
                    setTimeout(function () {
                        controls.stop(true).fadeOut(500);
                    }, o.controlsHide);
                }
            });
        },

        _offMouse: function(){
            var player = this.player, o = this.options;
            var controls = player.find(".controls");

            player.off(Metro.events.enter);
            player.off(Metro.events.leave);

            if (o.controlsHide > 0 && controls.style('display') === 'none') {
                controls.stop(true).fadeIn(500, function(){
                    controls.css("display", "flex");
                });
            }
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.video.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.video.volume;
                this.video.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.video.buffered.length ? Math.round(Math.floor(this.video.buffered.end(0)) / Math.floor(this.video.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var video = this.video, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = video.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        _setAspectRatio: function(){
            var player = this.player, o = this.options;
            var width = player.outerWidth();
            var height;

            switch (o.aspectRatio) {
                case Metro.aspectRatio.SD: height = Utils.aspectRatioH(width, "4/3"); break;
                case Metro.aspectRatio.CINEMA: height = Utils.aspectRatioH(width, "21/9"); break;
                default: height = Utils.aspectRatioH(width, "16/9");
            }

            player.outerHeight(height);
        },

        aspectRatio: function(ratio){
            this.options.aspectRatio = ratio;
            this._setAspectRatio();
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.isPlaying = true;

            this.video.play();
        },

        pause: function(){
            this.isPlaying = false;
            this.video.pause();
        },

        resume: function(){
            if (this.video.paused) {
                this.play();
            }
        },

        stop: function(){
            this.isPlaying = false;
            this.video.pause();
            this.video.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
            this._offMouse();
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.video.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.video.volume = v;
            Metro.getPlugin(this.volume[0], 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeAspectRatio: function(){
            this.options.aspectRatio = this.element.attr("data-aspect-ratio");
            this._setAspectRatio();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-aspect-ratio": this.changeAspectRatio(); break;
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            element.off("loadstart");
            element.off("loadedmetadata");
            element.off("canplay");
            element.off("progress");
            element.off("timeupdate");
            element.off("waiting");
            element.off("loadeddata");
            element.off("play");
            element.off("pause");
            element.off("stop");
            element.off("ended");
            element.off("volumechange");

            player.off(Metro.events.click, ".play");
            player.off(Metro.events.click, ".stop");
            player.off(Metro.events.click, ".mute");
            player.off(Metro.events.click, ".loop");
            player.off(Metro.events.click, ".full");

            $(window).off(Metro.events.keyup,{ns: this.id});
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WindowDefaultConfig = {
        windowDeferred: 0,
        hidden: false,
        width: "auto",
        height: "auto",
        btnClose: true,
        btnMin: true,
        btnMax: true,
        draggable: true,
        dragElement: ".window-caption .icon, .window-caption .title",
        dragArea: "parent",
        shadow: false,
        icon: "",
        title: "Window",
        content: null,
        resizable: true,
        overlay: false,
        overlayColor: 'transparent',
        overlayAlpha: .5,
        modal: false,
        position: "absolute",
        checkEmbed: true,
        top: "auto",
        left: "auto",
        place: "auto",
        closeAction: Metro.actions.REMOVE,
        customButtons: null,

        clsCustomButton: "",
        clsCaption: "",
        clsContent: "",
        clsWindow: "",

        _runtime: false,

        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onCaptionDblClick: Metro.noop,
        onCloseClick: Metro.noop,
        onMaxClick: Metro.noop,
        onMinClick: Metro.noop,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onWindowCreate: Metro.noop,
        onShow: Metro.noop,
        onWindowDestroy: Metro.noop,
        onCanClose: Metro.noop_true,
        onClose: Metro.noop
    };

    Metro.windowSetup = function (options) {
        WindowDefaultConfig = $.extend({}, WindowDefaultConfig, options);
    };

    if (typeof window["metroWindowSetup"] !== undefined) {
        Metro.windowSetup(window["metroWindowSetup"]);
    }

    Metro.Component('window', {
        init: function( options, elem ) {
            this._super(elem, options, WindowDefaultConfig, {
                win: null,
                overlay: null,
                position: {
                    top: 0,
                    left: 0
                },
                hidden: false,
                content: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var win, overlay;
            var parent = o.dragArea === "parent" ? element.parent() : $(o.dragArea);

            if (o.modal === true) {
                o.btnMax = false;
                o.btnMin = false;
                o.resizable = false;
            }

            if (Utils.isNull(o.content)) {
                o.content = element;
            } else {
                if (Utils.isUrl(o.content) && Utils.isVideoUrl(o.content)) {
                    o.content = Utils.embedUrl(o.content);
                    element.css({
                        height: "100%"
                    });
                } else

                if (!Utils.isQ(o.content) && Utils.isFunc(o.content)) {
                    o.content = Utils.exec(o.content);
                }

                element.append(o.content);
                o.content = element;
            }

            if (o._runtime === true) {
                this._runtime(element, "window");
            }

            win = this._window(o);
            win.addClass("no-visible");

            parent.append(win);

            if (o.overlay === true) {
                overlay = this._overlay();
                overlay.appendTo(win.parent());
                this.overlay = overlay;
            }

            this.win = win;

            this._fireEvent("window-create", {
                win: this.win[0],
                element: element
            });

            setTimeout(function(){
                that._setPosition();

                if (o.hidden !== true) {
                    that.win.removeClass("no-visible");
                }

                that._fireEvent("show", {
                    win: that.win[0],
                    element: element
                });
            }, 100);
        },

        _setPosition: function(){
            var o = this.options;
            var win = this.win;
            var parent = o.dragArea === "parent" ? win.parent() : $(o.dragArea);
            var top_center = parent.height() / 2 - win[0].offsetHeight / 2;
            var left_center = parent.width() / 2 - win[0].offsetWidth / 2;
            var top, left, right, bottom;

            if (o.place !== 'auto') {

                switch (o.place.toLowerCase()) {
                    case "top-left": top = 0; left = 0; right = "auto"; bottom = "auto"; break;
                    case "top-center": top = 0; left = left_center; right = "auto"; bottom = "auto"; break;
                    case "top-right": top = 0; right = 0; left = "auto"; bottom = "auto"; break;
                    case "right-center": top = top_center; right = 0; left = "auto"; bottom = "auto"; break;
                    case "bottom-right": bottom = 0; right = 0; left = "auto"; top = "auto"; break;
                    case "bottom-center": bottom = 0; left = left_center; right = "auto"; top = "auto"; break;
                    case "bottom-left": bottom = 0; left = 0; right = "auto"; top = "auto"; break;
                    case "left-center": top = top_center; left = 0; right = "auto"; bottom = "auto"; break;
                    default: top = top_center; left = left_center; bottom = "auto"; right = "auto";
                }

                win.css({
                    top: top,
                    left: left,
                    bottom: bottom,
                    right: right
                });
            }
        },

        _window: function(o){
            var that = this;
            var win, caption, content, icon, title, buttons, btnClose, btnMin, btnMax, resizer, status;
            var width = o.width, height = o.height;

            win = $("<div>").addClass("window");

            if (o.modal === true) {
                win.addClass("modal");
            }

            caption = $("<div>").addClass("window-caption");
            content = $("<div>").addClass("window-content");

            win.append(caption);
            win.append(content);

            if (o.status === true) {
                status = $("<div>").addClass("window-status");
                win.append(status);
            }

            if (o.shadow === true) {
                win.addClass("win-shadow");
            }

            if (Utils.isValue(o.icon)) {
                icon = $("<span>").addClass("icon").html(o.icon);
                icon.appendTo(caption);
            }

            title = $("<span>").addClass("title").html(Utils.isValue(o.title) ? o.title : "&nbsp;");
            title.appendTo(caption);

            if (!Utils.isNull(o.content)) {

                if (Utils.isQ(o.content)) {
                    o.content.appendTo(content);
                } else {
                    content.html(o.content);
                }
            }

            buttons = $("<div>").addClass("buttons");
            buttons.appendTo(caption);

            if (o.btnMax === true) {
                btnMax = $("<span>").addClass("button btn-max sys-button");
                btnMax.appendTo(buttons);
            }

            if (o.btnMin === true) {
                btnMin = $("<span>").addClass("button btn-min sys-button");
                btnMin.appendTo(buttons);
            }

            if (o.btnClose === true) {
                btnClose = $("<span>").addClass("button btn-close sys-button");
                btnClose.appendTo(buttons);
            }

            if (Utils.isValue(o.customButtons)) {
                var customButtons = [];

                if (Utils.isObject(o.customButtons) !== false) {
                    o.customButtons = Utils.isObject(o.customButtons);
                }

                if (typeof o.customButtons === "string" && o.customButtons.indexOf("{") > -1) {
                    customButtons = JSON.parse(o.customButtons);
                } else if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                    customButtons = o.customButtons;
                } else {
                    console.warn("Unknown format for custom buttons");
                }

                $.each(customButtons, function(){
                    var item = this;
                    var customButton = $("<span>");

                    customButton
                        .addClass("button btn-custom")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr($.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    buttons.prepend(customButton);
                });
            }

            caption.on(Metro.events.stop, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            win.attr("id", o.id === undefined ? Utils.elementId("window") : o.id);

            win.on(Metro.events.dblclick, ".window-caption", function(e){
                that.maximized(e);
            });

            caption.on(Metro.events.click, ".btn-max, .btn-min, .btn-close", function(e){
                if (Utils.isRightMouse(e)) return;
                var target = $(e.target);
                if (target.hasClass("btn-max")) that.maximized(e);
                if (target.hasClass("btn-min")) that.minimized(e);
                if (target.hasClass("btn-close")) that.close(e);
            });

            if (o.draggable === true) {
                Metro.makePlugin(win, "draggable", {
                    dragContext: win[0],
                    dragElement: o.dragElement,
                    dragArea: o.dragArea,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            win.addClass(o.clsWindow);
            caption.addClass(o.clsCaption);
            content.addClass(o.clsContent);

            if (o.minWidth === 0) {
                o.minWidth = 34;
                $.each(buttons.children(".btn-custom"), function(){
                    o.minWidth += Utils.hiddenElementSize(this).width;
                });
                if (o.btnMax) o.minWidth += 34;
                if (o.btnMin) o.minWidth += 34;
                if (o.btnClose) o.minWidth += 34;
            }

            if (o.minWidth > 0 && !isNaN(o.width) && o.width < o.minWidth) {
                width = o.minWidth;
            }
            if (o.minHeight > 0 && !isNaN(o.height) && o.height > o.minHeight) {
                height = o.minHeight;
            }

            if (o.resizable === true) {
                resizer = $("<span>").addClass("resize-element");
                resizer.appendTo(win);
                win.addClass("resizable");

                Metro.makePlugin(win, "resizable", {
                    minWidth: o.minWidth,
                    minHeight: o.minHeight,
                    maxWidth: o.maxWidth,
                    maxHeight: o.maxHeight,
                    resizeElement: ".resize-element",
                    onResizeStart: o.onResizeStart,
                    onResizeStop: o.onResizeStop,
                    onResize: o.onResize
                });
            }

            win.css({
                width: width,
                height: height,
                position: o.position,
                top: o.top,
                left: o.left
            });

            return win;
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay");

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        width: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.width();
            }

            win.css("width", parseInt(v));

            return this;
        },

        height: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.height();
            }

            win.css("height", parseInt(v));

            return this;
        },

        maximized: function(e){
            var win = this.win, o = this.options;
            var target = $(e.currentTarget);

            if (o.btnMax) {
                win.removeClass("minimized");
                win.toggleClass("maximized");
            }

            if (target.hasClass && target.hasClass("window-caption")) {

                this._fireEvent("caption-dbl-click", {
                    win: win[0]
                });

            } else {

                this._fireEvent("max-click", {
                    win: win[0]
                });

            }
        },

        minimized: function(){
            var win = this.win, o = this.options;

            if (o.btnMin) {
                win.removeClass("maximized");
                win.toggleClass("minimized");
            }

            this._fireEvent("min-click", {
                win: win[0]
            });
        },

        close: function(){
            var that = this, win = this.win,  o = this.options;

            if (Utils.exec(o.onCanClose, [win]) === false) {
                return false;
            }

            var timeout = 0;

            if (o.onClose !== Metro.noop) {
                timeout = 500;
            }

            this._fireEvent("close", {
                win: win[0]
            });

            setTimeout(function(){
                if (o.modal === true) {
                    win.siblings(".overlay").remove();
                }

                that._fireEvent("close-click", {
                    win: win[0]
                });

                if (o.closeAction === Metro.actions.REMOVE) {
                    that._fireEvent("window-destroy", {
                        win: win[0]
                    });
                    win.remove();
                } else {
                    that.hide();
                }

            }, timeout);
        },

        hide: function(){
            var win = this.win;

            win.css({
                display: "none"
            });

            this._fireEvent("hide", {
                win: win[0]
            });
        },

        show: function(){
            var win = this.win;

            win
                .removeClass("no-visible")
                .css({
                    display: "flex"
                });

            this._fireEvent("show", {
                win: win[0]
            });

        },

        toggle: function(){
            if (this.win.css("display") === "none" || this.win.hasClass("no-visible")) {
                this.show();
            } else {
                this.hide();
            }
        },

        isOpen: function(){
            return this.win.hasClass("no-visible");
        },

        min: function(a){
            a ? this.win.addClass("minimized") : this.win.removeClass("minimized");
        },

        max: function(a){
            a ? this.win.addClass("maximized") : this.win.removeClass("maximized");
        },

        changeClass: function(a){
            var element = this.element, win = this.win, o = this.options;

            if (a === "data-cls-window") {
                win[0].className = "window " + (o.resizable ? " resizable " : " ") + element.attr("data-cls-window");
            }
            if (a === "data-cls-caption") {
                win.find(".window-caption")[0].className = "window-caption " + element.attr("data-cls-caption");
            }
            if (a === "data-cls-content") {
                win.find(".window-content")[0].className = "window-content " + element.attr("data-cls-content");
            }
        },

        toggleShadow: function(){
            var element = this.element, win = this.win;
            var flag = JSON.parse(element.attr("data-shadow"));
            if (flag === true) {
                win.addClass("win-shadow");
            } else {
                win.removeClass("win-shadow");
            }
        },

        setContent: function(c){
            var element = this.element, win = this.win;
            var content = Utils.isValue(c) ? c : element.attr("data-content");
            var result;

            if (!Utils.isQ(content) && Utils.isFunc(content)) {
                result = Utils.exec(content);
            } else if (Utils.isQ(content)) {
                result = content.html();
            } else {
                result = content;
            }

            win.find(".window-content").html(result);
        },

        setTitle: function(t){
            var element = this.element, win = this.win;
            var title = Utils.isValue(t) ? t : element.attr("data-title");
            win.find(".window-caption .title").html(title);
        },

        setIcon: function(i){
            var element = this.element, win = this.win;
            var icon = Utils.isValue(i) ? i : element.attr("data-icon");
            win.find(".window-caption .icon").html(icon);
        },

        getIcon: function(){
            return this.win.find(".window-caption .icon").html();
        },

        getTitle: function(){
            return this.win.find(".window-caption .title").html();
        },

        toggleDraggable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var drag = Metro.getPlugin(win, "draggable");
            if (flag === true) {
                drag.on();
            } else {
                drag.off();
            }
        },

        toggleResizable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var resize = Metro.getPlugin(win, "resizable");
            if (flag === true) {
                resize.on();
                win.find(".resize-element").removeClass("resize-element-disabled");
            } else {
                resize.off();
                win.find(".resize-element").addClass("resize-element-disabled");
            }
        },

        changePlace: function (p) {
            var element = this.element, win = this.win;
            var place = Utils.isValue(p) ? p : element.attr("data-place");
            win.addClass(place);
        },

        pos: function(top, left){
            var win = this.win;
            win.css({
                top: top,
                left: left
            });
            return this;
        },

        top: function(v){
            this.win.css({
                top: v
            });
            return this;
        },

        left: function(v){
            this.win.css({
                left: v
            });
            return this;
        },

        changeAttribute: function(attr, value){
            var changePos = function(a, v){
                var win = this.win;
                var pos;
                if (a === "data-top") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("top", pos);
                }
                if (a === "data-left") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("left", pos);
                }
            };

            var toggleButtons = function(a, v) {
                var win = this.win;
                var btnClose = win.find(".btn-close");
                var btnMin = win.find(".btn-min");
                var btnMax = win.find(".btn-max");
                var _v = Utils.bool(v);
                var func = _v ? "show" : "hide";

                switch (a) {
                    case "data-btn-close": btnClose[func](); break;
                    case "data-btn-min": btnMin[func](); break;
                    case "data-btn-max": btnMax[func](); break;
                }
            };

            var changeSize = function(a, v){
                var win = this.win;
                if (a === "data-width") {
                    win.css("width", +v);
                }
                if (a === "data-height") {
                    win.css("height", +v);
                }
            };

            switch (attr) {
                case "data-btn-close":
                case "data-btn-min":
                case "data-btn-max": toggleButtons(attr, value); break;
                case "data-width":
                case "data-height": changeSize(attr, value); break;
                case "data-cls-window":
                case "data-cls-caption":
                case "data-cls-content": this.changeClass(attr); break;
                case "data-shadow": this.toggleShadow(); break;
                case "data-icon": this.setIcon(); break;
                case "data-title": this.setTitle(); break;
                case "data-content": this.setContent(); break;
                case "data-draggable": this.toggleDraggable(value); break;
                case "data-resizable": this.toggleResizable(value); break;
                case "data-top":
                case "data-left": changePos(attr, value); break;
                case "data-place": this.changePlace(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['window'] = {

        isWindow: function(el){
            return Utils.isMetroObject(el, "window");
        },

        min: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el,"window").min(a);
        },

        max: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").max(a);
        },

        show: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").show();
        },

        hide: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").hide();
        },

        toggle: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").toggle();
        },

        isOpen: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            var win = Metro.getPlugin(el,"window");
            return win.isOpen();
        },

        close: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").close();
        },

        pos: function(el, top, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").pos(top, left);
        },

        top: function(el, top){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").top(top);
        },

        left: function(el, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").left(left);
        },

        width: function(el, width){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").width(width);
        },

        height: function(el, height){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").height(height);
        },

        create: function(options){
            var w;

            w = $("<div>").appendTo($("body"));

            var w_options = $.extend({}, {
            }, (options !== undefined ? options : {}));

            w_options._runtime = true;

            return Metro.makePlugin(w, "window", w_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WizardDefaultConfig = {
        wizardDeferred: 0,
        start: 1,
        finish: 0,
        iconHelp: "<span class='default-icon-help'></span>",
        iconPrev: "<span class='default-icon-left-arrow'></span>",
        iconNext: "<span class='default-icon-right-arrow'></span>",
        iconFinish: "<span class='default-icon-check'></span>",

        buttonMode: "cycle", // default, cycle, square
        buttonOutline: true,
        duration: 300,

        clsWizard: "",
        clsActions: "",
        clsHelp: "",
        clsPrev: "",
        clsNext: "",
        clsFinish: "",

        onPage: Metro.noop,
        onNextPage: Metro.noop,
        onPrevPage: Metro.noop,
        onFirstPage: Metro.noop,
        onLastPage: Metro.noop,
        onFinishPage: Metro.noop,
        onHelpClick: Metro.noop,
        onPrevClick: Metro.noop,
        onNextClick: Metro.noop,
        onFinishClick: Metro.noop,
        onBeforePrev: Metro.noop_true,
        onBeforeNext: Metro.noop_true,
        onWizardCreate: Metro.noop
    };

    Metro.wizardSetup = function (options) {
        WizardDefaultConfig = $.extend({}, WizardDefaultConfig, options);
    };

    if (typeof window["metroWizardSetup"] !== undefined) {
        Metro.wizardSetup(window["metroWizardSetup"]);
    }

    Metro.Component('wizard', {
        init: function( options, elem ) {
            this._super(elem, options, WizardDefaultConfig, {
                id: Utils.elementId('wizard')
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createWizard();
            this._createEvents();

            this._fireEvent("wizard-create", {
                element: element
            });
        },

        _createWizard: function(){
            var element = this.element, o = this.options;
            var bar;

            element.addClass("wizard").addClass(o.view).addClass(o.clsWizard);

            bar = $("<div>").addClass("action-bar").addClass(o.clsActions).appendTo(element);

            var buttonMode = o.buttonMode === "button" ? "" : o.buttonMode;
            if (o.buttonOutline === true) {
                buttonMode += " outline";
            }

            if (o.iconHelp !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-help").addClass(buttonMode).addClass(o.clsHelp).html(Utils.isTag(o.iconHelp) ? o.iconHelp : $("<img>").attr('src', o.iconHelp)).appendTo(bar);
            if (o.iconPrev !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-prev").addClass(buttonMode).addClass(o.clsPrev).html(Utils.isTag(o.iconPrev) ? o.iconPrev : $("<img>").attr('src', o.iconPrev)).appendTo(bar);
            if (o.iconNext !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-next").addClass(buttonMode).addClass(o.clsNext).html(Utils.isTag(o.iconNext) ? o.iconNext : $("<img>").attr('src', o.iconNext)).appendTo(bar);
            if (o.iconFinish !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-finish").addClass(buttonMode).addClass(o.clsFinish).html(Utils.isTag(o.iconFinish) ? o.iconFinish : $("<img>").attr('src', o.iconFinish)).appendTo(bar);

            this.toPage(o.start);

            this._setHeight();
        },

        _setHeight: function(){
            var element = this.element;
            var pages = element.children("section");
            var max_height = 0;

            pages.children(".page-content").css("max-height", "none");

            $.each(pages, function(){
                var h = $(this).height();
                if (max_height < parseInt(h)) {
                    max_height = h;
                }
            });

            element.height(max_height);
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".wizard-btn-help", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("help-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-prev", function(){
                that.prev();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("prev-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-next", function(){
                that.next();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("next-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-finish", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("finish-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".complete", function(){
                var index = $(this).index() + 1;
                that.toPage(index);
            });

            $(window).on(Metro.events.resize, function(){
                that._setHeight();
            }, {ns: this.id});
        },

        next: function(){
            var that = this, element = this.element, o = this.options;
            var pages = element.children("section");
            var page = $(element.children("section").get(this.current - 1));

            if (this.current + 1 > pages.length || Utils.exec(o.onBeforeNext, [this.current, page, element]) === false) {
                return ;
            }

            this.current++;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("next-page", {
                index: that.current,
                page: page[0]
            });
        },

        prev: function(){
            var that = this, element = this.element, o = this.options;
            var page = $(element.children("section").get(this.current - 1));

            if (this.current - 1 === 0 || Utils.exec(o.onBeforePrev, [this.current, page, element]) === false) {
                return ;
            }

            this.current--;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("prev-page", {
                index: that.current,
                page: page[0]
            });
        },

        last: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(element.children("section").length);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("last-page", {
                index: that.current,
                page: page[0]
            });
        },

        first: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(1);

            page = $(element.children("section").get(0));

            this._fireEvent("first-page", {
                index: that.current,
                page: page[0]
            });
        },

        toPage: function(page){
            var element = this.element, o = this.options;
            var target = $(element.children("section").get(page - 1));
            var sections = element.children("section");
            var actions = element.find(".action-bar");

            if (target.length === 0) {
                return ;
            }

            var finish = element.find(".wizard-btn-finish").addClass("disabled");
            var next = element.find(".wizard-btn-next").addClass("disabled");
            var prev = element.find(".wizard-btn-prev").addClass("disabled");

            this.current = page;

            element.children("section")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            var border_size = element.children("section.complete").length === 0 ? 0 : parseInt(Utils.getStyleOne(element.children("section.complete")[0], "border-left-width"));

            actions.animate({
                draw: {
                    left: element.children("section.complete").length * border_size + 41
                },
                dur: o.duration
            });

            if (
                (this.current === sections.length) || (o.finish > 0 && this.current >= o.finish)
            ) {
                finish.removeClass("disabled");
            }

            if (parseInt(o.finish) > 0 && this.current === parseInt(o.finish)) {

                this._fireEvent("finish-page", {
                    index: this.current,
                    page: target[0]
                });
            }

            if (this.current < sections.length) {
                next.removeClass("disabled");
            }

            if (this.current > 1) {
                prev.removeClass("disabled");
            }

            this._fireEvent("page", {
                index: this.current,
                page: target[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".wizard-btn-help");
            element.off(Metro.events.click, ".wizard-btn-prev");
            element.off(Metro.events.click, ".wizard-btn-next");
            element.off(Metro.events.click, ".wizard-btn-finish");
            element.off(Metro.events.click, ".complete");
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));